@menu
* PIM Compatible::Basic PIM Compatible and additional libraries
* M2 ISO Libraries::ISO defined libraries
@end menu


@c =====================================================================


@node PIM Compatible, M2 ISO Libraries, , Libraries
@section PIM Compatible


These libraries are based on the modules expressed in Programming in
Modula-2.  They include a number of alterations and a number of extra
libraries to allow access to compiler built-ins and underlying
operating system features. Perhaps the largest addition is the
@code{DynamicString} module which declares the type @code{String}
which results in a number of equivalent modules that can either handle
@code{ARRAY OF CHAR} or @code{String}.

These modules have been extensively tested and are used throughout
gm2.
@menu
* gm2-libs/ASCII::ASCII.def
* gm2-libs/Args::Args.def
* gm2-libs/Assertion::Assertion.def
* gm2-libs/Break::Break.def
* gm2-libs/Builtins::Builtins.def
* gm2-libs/CmdArgs::CmdArgs.def
* gm2-libs/Debug::Debug.def
* gm2-libs/DebugPMD::DebugPMD.def
* gm2-libs/DynamicStrings::DynamicStrings.def
* gm2-libs/Environment::Environment.def
* gm2-libs/FIO::FIO.def
* gm2-libs/FormatStrings::FormatStrings.def
* gm2-libs/FpuIO::FpuIO.def
* gm2-libs/IO::IO.def
* gm2-libs/M2RTS::M2RTS.def
* gm2-libs/MathLib0::MathLib0.def
* gm2-libs/MemUtils::MemUtils.def
* gm2-libs/NumberIO::NumberIO.def
* gm2-libs/PushBackInput::PushBackInput.def
* gm2-libs/SArgs::SArgs.def
* gm2-libs/SEnvironment::SEnvironment.def
* gm2-libs/SFIO::SFIO.def
* gm2-libs/SYSTEM::SYSTEM.def
* gm2-libs/Scan::Scan.def
* gm2-libs/Selective::Selective.def
* gm2-libs/StdIO::StdIO.def
* gm2-libs/Storage::Storage.def
* gm2-libs/StrCase::StrCase.def
* gm2-libs/StrIO::StrIO.def
* gm2-libs/StrLib::StrLib.def
* gm2-libs/StringConvert::StringConvert.def
* gm2-libs/SysStorage::SysStorage.def
* gm2-libs/TimeString::TimeString.def
* gm2-libs/UnixArgs::UnixArgs.def
* gm2-libs/cbuiltin::cbuiltin.def
* gm2-libs/libc::libc.def
* gm2-libs/libm::libm.def
* gm2-libs/wrapc::wrapc.def
@end menu


@node gm2-libs/ASCII, gm2-libs/Args, , PIM Compatible
@subsection gm2-libs/ASCII

@example
DEFINITION MODULE ASCII ;

(*
   Desciption: Defines all ascii constants (as in man ASCII)
               Note that lf, eof and EOL are added
*)

EXPORT QUALIFIED
     nul, soh, stx, etx, eot, enq, ack, bel,
     bs , ht , nl , vt , np , cr , so , si ,
     dle, dc1, dc2, dc3, dc4, nak, syn, etb,
     can, em , sub, esc, fs , gs , rs , us ,
     sp ,  (* All the above are in order *)
     lf, ff, eof, del, tab, EOL ;

CONST
     nul=000C; soh=001C; stx=002C; etx=003C;
     eot=004C; enq=005C; ack=006C; bel=007C;
     bs =010C; ht =011C; nl =012C; vt =013C;
     np =014C; cr =015C; so =016C; si =017C;
     dle=020C; dc1=021C; dc2=022C; dc3=023C;
     dc4=024C; nak=025C; syn=026C; etb=027C;
     can=030C; em =031C; sub=032C; esc=033C;
     fs =034C; gs =035C; rs =036C; us =037C;
     sp =040C; (* All the above are in order *)
     lf =nl  ; ff =np  ; eof=eot ; tab=ht  ;
     del=177C; EOL=cr  ;

END ASCII.
@end example
@page


@node gm2-libs/Args, gm2-libs/Assertion, gm2-libs/ASCII, PIM Compatible
@subsection gm2-libs/Args

@example
DEFINITION MODULE Args ;

(*
    Description: provides a simple interface to the command
                 line arguments.
*)

EXPORT QUALIFIED GetArg, Narg ;


(*
   GetArg - returns the nth argument from the command line.
            The success of the operation is returned.
*)

@findex GetArg
PROCEDURE GetArg (VAR a: ARRAY OF CHAR ; i: CARDINAL) : BOOLEAN ;


(*
   Narg - returns the number of arguments available from
          command line.
*)

@findex Narg
PROCEDURE Narg() : CARDINAL ;


END Args.
@end example
@page


@node gm2-libs/Assertion, gm2-libs/Break, gm2-libs/Args, PIM Compatible
@subsection gm2-libs/Assertion

@example
DEFINITION MODULE Assertion ;

(*
   Description: Provides an assert procedure.
*)

EXPORT QUALIFIED Assert ;


(*
   Assert - tests the boolean Condition, if it fails then HALT is called.
*)

@findex Assert
PROCEDURE Assert (Condition: BOOLEAN) ;


END Assertion.
@end example
@page


@node gm2-libs/Break, gm2-libs/Builtins, gm2-libs/Assertion, PIM Compatible
@subsection gm2-libs/Break

@example
DEFINITION MODULE Break ;

END Break.
@end example
@page


@node gm2-libs/Builtins, gm2-libs/CmdArgs, gm2-libs/Break, PIM Compatible
@subsection gm2-libs/Builtins

@example
DEFINITION MODULE Builtins ;

(*
    Description: provides a convenient place to list all the GNU Modula-2
                 built-in functions. These functions should be copied into
                 more generic modules.

                 For example the mathematical functions can be applied to
                 gm2-iso/LongMath. But each built-in function is here for
                 reference.
*)

FROM SYSTEM IMPORT ADDRESS ;

@findex sinf
PROCEDURE __BUILTIN__ sinf (x: SHORTREAL) : SHORTREAL ;
@findex sin
PROCEDURE __BUILTIN__ sin (x: REAL) : REAL ;
@findex sinl
PROCEDURE __BUILTIN__ sinl (x: LONGREAL) : LONGREAL ;

@findex cosf
PROCEDURE __BUILTIN__ cosf (x: SHORTREAL) : SHORTREAL ;
@findex cos
PROCEDURE __BUILTIN__ cos (x: REAL) : REAL ;
@findex cosl
PROCEDURE __BUILTIN__ cosl (x: LONGREAL) : LONGREAL ;

@findex sqrtf
PROCEDURE __BUILTIN__ sqrtf (x: SHORTREAL) : SHORTREAL ;
@findex sqrt
PROCEDURE __BUILTIN__ sqrt (x: REAL) : REAL ;
@findex sqrtl
PROCEDURE __BUILTIN__ sqrtl (x: LONGREAL) : LONGREAL ;

@findex fabsf
PROCEDURE __BUILTIN__ fabsf (x: SHORTREAL) : SHORTREAL ;
@findex fabs
PROCEDURE __BUILTIN__ fabs (x: REAL) : REAL ;
@findex fabsl
PROCEDURE __BUILTIN__ fabsl (x: LONGREAL) : LONGREAL ;

@findex alloca
PROCEDURE __BUILTIN__ alloca (i: CARDINAL) : ADDRESS ;
@findex memcpy
PROCEDURE __BUILTIN__ memcpy (dest, src: ADDRESS; n: CARDINAL) : ADDRESS ;
@findex index
PROCEDURE __BUILTIN__ index (s: ADDRESS; c: INTEGER) : ADDRESS ;
@findex rindex
PROCEDURE __BUILTIN__ rindex (s: ADDRESS; c: INTEGER) : ADDRESS ;
@findex memcmp
PROCEDURE __BUILTIN__ memcmp (s1, s2: ADDRESS; n: CARDINAL) : INTEGER ;
@findex memset
PROCEDURE __BUILTIN__ memset (s: ADDRESS; c: INTEGER; n: CARDINAL) : ADDRESS ;
@findex strcat
PROCEDURE __BUILTIN__ strcat (dest, src: ADDRESS) : ADDRESS ;
@findex strncat
PROCEDURE __BUILTIN__ strncat (dest, src: ADDRESS; n: CARDINAL) : ADDRESS ;
@findex strcpy
PROCEDURE __BUILTIN__ strcpy (dest, src: ADDRESS) : ADDRESS ;
@findex strncpy
PROCEDURE __BUILTIN__ strncpy (dest, src: ADDRESS; n: CARDINAL) : ADDRESS ;
@findex strcmp
PROCEDURE __BUILTIN__ strcmp (s1, s2: ADDRESS) : INTEGER ;
@findex strncmp
PROCEDURE __BUILTIN__ strncmp (s1, s2: ADDRESS; n: CARDINAL) : INTEGER ;
@findex strlen
PROCEDURE __BUILTIN__ strlen (s: ADDRESS) : INTEGER ;
@findex strstr
PROCEDURE __BUILTIN__ strstr (haystack, needle: ADDRESS) : ADDRESS ;
@findex strpbrk
PROCEDURE __BUILTIN__ strpbrk (s, accept: ADDRESS) : ADDRESS ;
@findex strspn
PROCEDURE __BUILTIN__ strspn (s, accept: ADDRESS) : CARDINAL ;
@findex strcspn
PROCEDURE __BUILTIN__ strcspn (s, accept: ADDRESS) : CARDINAL ;
@findex strchr
PROCEDURE __BUILTIN__ strchr (s: ADDRESS; c: INTEGER) : ADDRESS ;
@findex strrchr
PROCEDURE __BUILTIN__ strrchr (s: ADDRESS; c: INTEGER) : ADDRESS ;

END Builtins.
@end example
@page


@node gm2-libs/CmdArgs, gm2-libs/Debug, gm2-libs/Builtins, PIM Compatible
@subsection gm2-libs/CmdArgs

@example
DEFINITION MODULE CmdArgs ;

(*
   Description: CmdArgs - implements procedures to retrieve arguments from
                a string.
*)

EXPORT QUALIFIED GetArg, Narg ;


(*
   GetArg - returns the nth argument from the command line, CmdLine
            the success of the operation is returned.
*)

@findex GetArg
PROCEDURE GetArg (CmdLine: ARRAY OF CHAR;
                  n: CARDINAL; VAR Argi: ARRAY OF CHAR) : BOOLEAN ;


(*
   Narg - returns the number of arguments available from
          command line, CmdLine.
*)

@findex Narg
PROCEDURE Narg (CmdLine: ARRAY OF CHAR) : CARDINAL ;


END CmdArgs.
@end example
@page


@node gm2-libs/Debug, gm2-libs/DebugPMD, gm2-libs/CmdArgs, PIM Compatible
@subsection gm2-libs/Debug

@example
DEFINITION MODULE Debug ;

(*
    Description: provides some simple debugging routines.
*)

EXPORT QUALIFIED Halt, DebugString ;


(*
   Halt - writes a message in the format:
          Module:Line:Message

          It then terminates by calling HALT.
*)

@findex Halt
PROCEDURE Halt (Message: ARRAY OF CHAR;
                LineNo: CARDINAL;
                Module: ARRAY OF CHAR) ;


(*
   DebugString - writes a string to the debugging device (Scn.Write).
                 It interprets \n as carriage return, linefeed.
*)

@findex DebugString
PROCEDURE DebugString (a: ARRAY OF CHAR) ;


END Debug.
@end example
@page


@node gm2-libs/DebugPMD, gm2-libs/DynamicStrings, gm2-libs/Debug, PIM Compatible
@subsection gm2-libs/DebugPMD

@example
DEFINITION MODULE DebugPMD ;

END DebugPMD.
@end example
@page


@node gm2-libs/DynamicStrings, gm2-libs/Environment, gm2-libs/DebugPMD, PIM Compatible
@subsection gm2-libs/DynamicStrings

@example
DEFINITION MODULE DynamicStrings ;

(*
    Description: provides a dynamic string type and common methods.
*)

FROM SYSTEM IMPORT ADDRESS ;
EXPORT QUALIFIED String,
                 InitString, KillString, Fin, InitStringCharStar, InitStringChar,
                 Index, RIndex,
                 Mark, Length, ConCat, ConCatChar, Assign, Dup, Add,
                 Equal, EqualCharStar, EqualArray, ToUpper, ToLower,
                 Mult, Slice, RemoveWhitePrefix, char, string ;

TYPE
   String ;


(*
   InitString - creates and returns a String type object.
                Initial contents are, a.
*)

@findex InitString
PROCEDURE InitString (a: ARRAY OF CHAR) : String ;


(*
   KillString - frees String, s, and its contents.
                NIL is returned.
*)

@findex KillString
PROCEDURE KillString (s: String) : String ;


(*
   Fin - finishes with a string, it calls KillString with, s.
         The purpose of the procedure is to provide a short cut
         to calling KillString and then testing the return result.
*)

@findex Fin
PROCEDURE Fin (s: String) ;


(*
   InitStringCharStar - initializes and returns a String to contain the C string.
*)

@findex InitStringCharStar
PROCEDURE InitStringCharStar (a: ADDRESS) : String ;


(*
   InitStringChar - initializes and returns a String to contain the single character, ch.
*)

@findex InitStringChar
PROCEDURE InitStringChar (ch: CHAR) : String ;


(*
   Mark - marks String, s, ready for garbage collection.
*)

@findex Mark
PROCEDURE Mark (s: String) : String ;

(*
   Length - returns the length of the String, s.
*)

@findex Length
PROCEDURE Length (s: String) : CARDINAL ;


(*
   ConCat - returns String, a, after the contents of, b, have been appended.
*)

@findex ConCat
PROCEDURE ConCat (a, b: String) : String ;


(*
   ConCatChar - returns String, a, after character, ch, has been appended.
*)

@findex ConCatChar
PROCEDURE ConCatChar (a: String; ch: CHAR) : String ;


(*
   Assign - assigns the contents of, b, into, a.
            String, a, is returned.
*)

@findex Assign
PROCEDURE Assign (a, b: String) : String ;


(*
   Dup - duplicate a String, s, returning the copy of s.
*)

@findex Dup
PROCEDURE Dup (s: String) : String ;


(*
   Add - returns a new String which contains the contents of a and b.
*)

@findex Add
PROCEDURE Add (a, b: String) : String ;


(*
   Equal - returns TRUE if String, a, and, b, are equal.
*)

@findex Equal
PROCEDURE Equal (a, b: String) : BOOLEAN ;


(*
   EqualCharStar - returns TRUE if contents of String, s, is the same as the
                   string, a.
*)

@findex EqualCharStar
PROCEDURE EqualCharStar (s: String; a: ADDRESS) : BOOLEAN ;


(*
   EqualArray - returns TRUE if contents of String, s, is the same as the
                string, a.
*)

@findex EqualArray
PROCEDURE EqualArray (s: String; a: ARRAY OF CHAR) : BOOLEAN ;


(*
   Mult - returns a new string which is n concatenations of String, s.
          If n<=0 then an empty string is returned.
*)

@findex Mult
PROCEDURE Mult (s: String; n: CARDINAL) : String ;


(*
   Slice - returns a new string which contains the elements
           low..high-1

           strings start at element 0
           Slice(s, 0, 2)  will return elements 0, 1 but not 2
           Slice(s, 1, 3)  will return elements 1, 2 but not 3
           Slice(s, 2, 0)  will return elements 2..max
           Slice(s, 3, -1) will return elements 3..max-1
           Slice(s, 4, -2) will return elements 4..max-2
*)

@findex Slice
PROCEDURE Slice (s: String; low, high: INTEGER) : String ;


(*
   Index - returns the indice of the first occurance of, ch, in
           String, s. -1 is returned if, ch, does not exist.
           The search starts at position, o.
           -1 is returned if, ch, is not found.
*)

@findex Index
PROCEDURE Index (s: String; ch: CHAR; o: CARDINAL) : INTEGER ;


(*
   RIndex - returns the indice of the last occurance of, ch,
            in String, s. The search starts at position, o.
            -1 is returned if, ch, is not found.
*)

@findex RIndex
PROCEDURE RIndex (s: String; ch: CHAR; o: CARDINAL) : INTEGER ;


(*
   RemoveWhitePrefix - removes any leading white space from String, s.
                       A new string is returned.
*)

@findex RemoveWhitePrefix
PROCEDURE RemoveWhitePrefix (s: String) : String ;


(*
   ToUpper - returns string, s, after it has had its lower case characters
             replaced by upper case characters.
             The string, s, is not duplicated.
*)

@findex ToUpper
PROCEDURE ToUpper (s: String) : String ;


(*
   ToLower - returns string, s, after it has had its upper case characters
             replaced by lower case characters.
             The string, s, is not duplicated.
*)

@findex ToLower
PROCEDURE ToLower (s: String) : String ;


(*
   char - returns the character, ch, at position, i, in String, s.
*)

@findex char
PROCEDURE char (s: String; i: CARDINAL) : CHAR ;


(*
   string - returns the C style char * of String, s.
*)

@findex string
PROCEDURE string (s: String) : ADDRESS ;


END DynamicStrings.
@end example
@page


@node gm2-libs/Environment, gm2-libs/FIO, gm2-libs/DynamicStrings, PIM Compatible
@subsection gm2-libs/Environment

@example
DEFINITION MODULE Environment ;

(*
    Description: provides access to the environment settings of a process.
*)

EXPORT QUALIFIED GetEnvironment ;


(*
   GetEnvironment - gets the environment variable, Env, and places
      	       	    a copy of its value into string, a.
*)

@findex GetEnvironment
PROCEDURE GetEnvironment (Env: ARRAY OF CHAR; VAR a: ARRAY OF CHAR) : BOOLEAN ;


END Environment.
@end example
@page


@node gm2-libs/FIO, gm2-libs/FormatStrings, gm2-libs/Environment, PIM Compatible
@subsection gm2-libs/FIO

@example
DEFINITION MODULE FIO ;

(*
    Description: provides a simple buffered file input/output library.
*)


FROM SYSTEM IMPORT ADDRESS, BYTE ;

EXPORT QUALIFIED (* types *)
                 File,
                 (* procedures *)
                 OpenToRead, OpenToWrite, OpenForRandom, Close,
                 EOF, EOLN, IsNoError, Exists,
                 exists, openToRead, openToWrite, openForRandom,
                 SetPositionFromBeginning, FindPosition, (* Rewind, *)
                 ReadChar, ReadString, (* ReadLine, *)
                 WriteChar, WriteString, WriteLine,
                 WriteCardinal, ReadCardinal,
                 (* WriteShort, ReadShort, *)
                 UnReadChar,
                 WriteNBytes, ReadNBytes, (* WriteBase, *)
                 GetUnixFileDescriptor,
                 (* variables *)
                 StdIn, StdOut, StdErr ;

TYPE
   File = CARDINAL ;

(* the following variables are initialized to their UNIX equivalents *)
VAR
   StdIn, StdOut, StdErr: File ;



(*
   IsNoError - returns a TRUE if no error has occured on file, f.
*)

@findex IsNoError
PROCEDURE IsNoError (f: File) : BOOLEAN ;


(*
   Exists - returns TRUE if a file named, fname exists for reading.
*)

@findex Exists
PROCEDURE Exists (fname: ARRAY OF CHAR) : BOOLEAN ;


(*
   OpenToRead - attempts to open a file, fname, for reading and
                it returns this file.
                The success of this operation can be checked by
                calling IsNoError.
*)

@findex OpenToRead
PROCEDURE OpenToRead (fname: ARRAY OF CHAR) : File ;


(*
   OpenToWrite - attempts to open a file, fname, for write and
                 it returns this file.
                 The success of this operation can be checked by
                 calling IsNoError.
*)

@findex OpenToWrite
PROCEDURE OpenToWrite (fname: ARRAY OF CHAR) : File ;


(*
   OpenForRandom - attempts to open a file, fname, for random access
                   read or write and it returns this file.
                   The success of this operation can be checked by
                   calling IsNoError.
                   towrite, determines whether the file should be
                   opened for writing or reading.
*)

@findex OpenForRandom
PROCEDURE OpenForRandom (fname: ARRAY OF CHAR; towrite: BOOLEAN) : File ;


(*
   Close - close a file which has been previously opened using:
           OpenToRead, OpenToWrite, OpenForRandom.
           It is correct to close a file which has an error status.
*)

@findex Close
PROCEDURE Close (f: File) ;


(* the following functions are functionally equivalent to the above
   except they allow C style names.
*)

@findex exists
PROCEDURE exists        (fname: ADDRESS; flength: CARDINAL) : BOOLEAN ;
@findex openToRead
PROCEDURE openToRead    (fname: ADDRESS; flength: CARDINAL) : File ;
@findex openToWrite
PROCEDURE openToWrite   (fname: ADDRESS; flength: CARDINAL) : File ;
@findex openForRandom
PROCEDURE openForRandom (fname: ADDRESS; flength: CARDINAL; towrite: BOOLEAN) : File ;


(*
   ReadNBytes - reads nBytes of a file into memory area, a, returning
                the number of bytes actually read.
                This function will consume from the buffer and then
                perform direct libc reads. It is ideal for large reads.
*)

@findex ReadNBytes
PROCEDURE ReadNBytes (f: File; nBytes: CARDINAL; a: ADDRESS) : CARDINAL ;


(*
   ReadAny - reads HIGH(a) bytes into, a. All input
             is fully buffered, unlike ReadNBytes and thus is more
             suited to small reads.
*)

@findex ReadAny
PROCEDURE ReadAny (f: File; VAR a: ARRAY OF BYTE) ;


(*
   WriteNBytes - writes nBytes of a file into memory area, a, returning
                 the number of bytes actually written.
                 This function will flush the buffer and then
                 write the nBytes using a direct write from libc.
                 It is ideal for large writes.
*)

@findex WriteNBytes
PROCEDURE WriteNBytes (f: File; nBytes: CARDINAL; a: ADDRESS) : CARDINAL ;


(*
   WriteAny - writes HIGH(a) bytes onto, file, f. All output
              is fully buffered, unlike WriteNBytes and thus is more
              suited to small writes.
*)

@findex WriteAny
PROCEDURE WriteAny (f: File; VAR a: ARRAY OF BYTE) ;


(*
   WriteChar - writes a single character to file, f.
*)

@findex WriteChar
PROCEDURE WriteChar (f: File; ch: CHAR) ;


(*
   EOF - tests to see whether a file, f, has reached end of file.
*)

@findex EOF
PROCEDURE EOF (f: File) : BOOLEAN ;


(*
   EOLN - tests to see whether a file, f, is upon a newline.
          It does NOT consume the newline.
*)

@findex EOLN
PROCEDURE EOLN (f: File) : BOOLEAN ;


(*
   ReadChar - returns a character read from file, f.
              Sensible to check with IsNoError or EOF after calling
              this function.
*)

@findex ReadChar
PROCEDURE ReadChar (f: File) : CHAR ;


(*
   UnReadChar - replaces a character, ch, back into file, f.
                This character must have been read by ReadChar
                and it does not allow successive calls.
*)

@findex UnReadChar
PROCEDURE UnReadChar (f: File ; ch: CHAR) ;


(*
   WriteLine - writes out a linefeed to file, f.
*)

@findex WriteLine
PROCEDURE WriteLine (f: File) ;


(*
   WriteString - writes a string to file, f.
*)

@findex WriteString
PROCEDURE WriteString (f: File; a: ARRAY OF CHAR) ;


(*
   ReadString - reads a string from file, f, into string, a.
                It terminates the string if HIGH is reached or
                if a newline is seen or an error occurs.
*)

@findex ReadString
PROCEDURE ReadString (f: File; VAR a: ARRAY OF CHAR) ;


(*
   WriteCardinal - writes a CARDINAL to file, f.
                   (Suggest that WriteAny be used instead - here for compatibility)
*)

@findex WriteCardinal
PROCEDURE WriteCardinal (f: File; c: CARDINAL) ;


(*
   ReadCardinal - reads a CARDINAL from file, f.
                  (Suggest that ReadAny be used instead - here for compatibility)
*)

@findex ReadCardinal
PROCEDURE ReadCardinal (f: File) : CARDINAL ;


(*
   GetUnixFileDescriptor - returns the UNIX file descriptor of a file.
                           Useful when combining FIO.mod with select
                           (in Selective.def - but note the comments in
                            Selective about using read/write primatives)
*)

@findex GetUnixFileDescriptor
PROCEDURE GetUnixFileDescriptor (f: File) : INTEGER ;


(*
   SetPositionFromBeginning - sets the position from the beginning of the file.
*)

@findex SetPositionFromBeginning
PROCEDURE SetPositionFromBeginning (f: File; pos: CARDINAL) ;


(*
   FindPosition - returns the current absolute position in file, f.
*)

@findex FindPosition
PROCEDURE FindPosition (f: File) : CARDINAL ;


END FIO.
@end example
@page


@node gm2-libs/FormatStrings, gm2-libs/FpuIO, gm2-libs/FIO, PIM Compatible
@subsection gm2-libs/FormatStrings

@example
DEFINITION MODULE FormatStrings ;

(*
    Description: provides a pseudo printf capability for GM2.
*)

FROM SYSTEM IMPORT WORD ;
FROM DynamicStrings IMPORT String ;
EXPORT QUALIFIED Sprintf0, Sprintf1, Sprintf2, Sprintf3, Sprintf4 ;


(*
   Sprintf0 - returns a String containing, s, after it has had its
              escape sequences translated.
*)

@findex Sprintf0
PROCEDURE Sprintf0 (s: String) : String ;


(*
   Sprintf1 - returns a String containing, s, together with encapsulated
              entity, w. It only formats the first %s or %d with n.
*)

@findex Sprintf1
PROCEDURE Sprintf1 (s: String; w: WORD) : String ;


(*
   Sprintf2 - returns a string, s, which has been formatted.
*)

@findex Sprintf2
PROCEDURE Sprintf2 (s: String; w1, w2: WORD) : String ;


(*
   Sprintf3 - returns a string, s, which has been formatted.
*)

@findex Sprintf3
PROCEDURE Sprintf3 (s: String; w1, w2, w3: WORD) : String ;


(*
   Sprintf4 - returns a string, s, which has been formatted.
*)

@findex Sprintf4
PROCEDURE Sprintf4 (s: String; w1, w2, w3, w4: WORD) : String ;


END FormatStrings.
@end example
@page


@node gm2-libs/FpuIO, gm2-libs/IO, gm2-libs/FormatStrings, PIM Compatible
@subsection gm2-libs/FpuIO

@example
DEFINITION MODULE FpuIO ;

(*
   Description: Implements a fixed format input/output for REAL, LONGREAL and LONGINT numbers
*)

EXPORT QUALIFIED ReadReal, WriteReal, StrToReal, RealToStr,
                 ReadLongReal, WriteLongReal, StrToLongReal, LongRealToStr,
                 ReadLongInt, WriteLongInt, StrToLongInt, LongIntToStr ;


@findex ReadReal
PROCEDURE ReadReal (VAR x: REAL) ;
@findex WriteReal
PROCEDURE WriteReal (x: REAL; TotalWidth, FractionWidth: CARDINAL) ;
@findex StrToReal
PROCEDURE StrToReal (a: ARRAY OF CHAR ; VAR x: REAL) ;
@findex RealToStr
PROCEDURE RealToStr (x: REAL; TotalWidth, FractionWidth: CARDINAL; VAR a: ARRAY OF CHAR) ;

@findex ReadLongReal
PROCEDURE ReadLongReal (VAR x: LONGREAL) ;
@findex WriteLongReal
PROCEDURE WriteLongReal (x: LONGREAL; TotalWidth, FractionWidth: CARDINAL) ;
@findex StrToLongReal
PROCEDURE StrToLongReal (a: ARRAY OF CHAR ; VAR x: LONGREAL) ;
@findex LongRealToStr
PROCEDURE LongRealToStr (x: LONGREAL; TotalWidth, FractionWidth: CARDINAL; VAR a: ARRAY OF CHAR) ;

@findex ReadLongInt
PROCEDURE ReadLongInt (VAR x: LONGINT) ;
@findex WriteLongInt
PROCEDURE WriteLongInt (x: LONGINT; n: CARDINAL) ;
@findex StrToLongInt
PROCEDURE StrToLongInt (a: ARRAY OF CHAR ; VAR x: LONGINT) ;
@findex LongIntToStr
PROCEDURE LongIntToStr (x: LONGINT; n: CARDINAL; VAR a: ARRAY OF CHAR) ;


END FpuIO.
@end example
@page


@node gm2-libs/IO, gm2-libs/M2RTS, gm2-libs/FpuIO, PIM Compatible
@subsection gm2-libs/IO

@example
DEFINITION MODULE IO ;

(*
   Description: provides Read, Write, Errors procedures that map onto UNIX
                file descriptors 0, 1 and 2. This is achieved by using
                FIO if we are in buffered mode and using libc.write
                if not.
*)

EXPORT QUALIFIED Read, Write, Error,
                 IOInRawMode, IOInBufferedMode ;


@findex Read
PROCEDURE Read (VAR ch: CHAR) ;
@findex Write
PROCEDURE Write (ch: CHAR) ;
@findex Error
PROCEDURE Error (ch: CHAR) ;
@findex IOInRawMode
PROCEDURE IOInRawMode ;
@findex IOInBufferedMode
PROCEDURE IOInBufferedMode ;


END IO.
@end example
@page


@node gm2-libs/M2RTS, gm2-libs/MathLib0, gm2-libs/IO, PIM Compatible
@subsection gm2-libs/M2RTS

@example
DEFINITION MODULE M2RTS ;

(*
   Description: Implements the run time system facilities of Modula-2.
*)

EXPORT QUALIFIED HALT,
                 SubrangeAssignmentError, ArraySubscriptError,
                 FunctionReturnError,
                 InstallTerminationProcedure, Terminate,
                 ExitOnHalt, Length ;


(*
   HALT - terminate the current program calling creating a core dump.
          The procedure Terminate is called before the core dump is
          created.
*)

@findex HALT
PROCEDURE HALT ;


(*
   SubrangeAssignmentError - part of the runtime checking, called if a
                             subrange variable is just about to be assigned an illegal value.
*)

@findex SubrangeAssignmentError
PROCEDURE SubrangeAssignmentError (file: ARRAY OF CHAR; line: CARDINAL) ;


(*
   ArraySubscriptError -  part of the runtime checking, called if an
                          array indice is out of range.
*)

@findex ArraySubscriptError
PROCEDURE ArraySubscriptError (file: ARRAY OF CHAR; line: CARDINAL) ;


(*
   FunctionReturnError -  part of the runtime checking, called if a
                          function exits without a RETURN statement.
*)

@findex FunctionReturnError
PROCEDURE FunctionReturnError (file: ARRAY OF CHAR; line: CARDINAL) ;


(*
   ExitOnHalt - if HALT is executed then call exit with the exit code, e.
*)

@findex ExitOnHalt
PROCEDURE ExitOnHalt (e: INTEGER) ;


(*
   InstallTerminationProcedure - installs a procedure, p, which will
                                 be called when the procedure Terminate
                                 is ionvoked.
*)

@findex InstallTerminationProcedure
PROCEDURE InstallTerminationProcedure (p: PROC) ;


(*
   Terminate - calls each installed termination procedure in turn.
*)

@findex Terminate
PROCEDURE Terminate ;


(*
   Length - returns the length of a string, a. This is called whenever
            the user calls LENGTH and the parameter cannot be calculated
            at compile time.
*)

@findex Length
PROCEDURE Length (a: ARRAY OF CHAR) : CARDINAL ;


END M2RTS.
@end example
@page


@node gm2-libs/MathLib0, gm2-libs/MemUtils, gm2-libs/M2RTS, PIM Compatible
@subsection gm2-libs/MathLib0

@example
DEFINITION MODULE MathLib0 ;

(*
    Description: provides access to math functions.
*)

CONST
   pi   = 3.1415926535897932384626433832795028841972;
   exp1 = 2.7182818284590452353602874713526624977572;


@findex sqrt
PROCEDURE __BUILTIN__ sqrt (x: REAL) : REAL ;
@findex sqrtl
PROCEDURE __BUILTIN__ sqrtl (x: LONGREAL) : LONGREAL ;
@findex sqrts
PROCEDURE __BUILTIN__ sqrts (x: SHORTREAL) : SHORTREAL ;

@findex exp
PROCEDURE exp (x: REAL) : REAL ;
@findex exps
PROCEDURE exps (x: SHORTREAL) : SHORTREAL ;

@findex ln
PROCEDURE ln (x: REAL) : REAL ;
@findex lns
PROCEDURE lns (x: SHORTREAL) : SHORTREAL ;

@findex sin
PROCEDURE __BUILTIN__ sin (x: REAL) : REAL ;
@findex sinl
PROCEDURE __BUILTIN__ sinl (x: LONGREAL) : LONGREAL ;
@findex sins
PROCEDURE __BUILTIN__ sins (x: SHORTREAL) : SHORTREAL ;

@findex cos
PROCEDURE __BUILTIN__ cos (x: REAL) : REAL ;
@findex cosl
PROCEDURE __BUILTIN__ cosl (x: LONGREAL) : LONGREAL ;
@findex coss
PROCEDURE __BUILTIN__ coss (x: SHORTREAL) : SHORTREAL ;

@findex tan
PROCEDURE tan (x: REAL) : REAL ;
@findex tans
PROCEDURE tans (x: SHORTREAL) : SHORTREAL ;

@findex arctan
PROCEDURE arctan (x: REAL) : REAL ;
@findex arctans
PROCEDURE arctans (x: SHORTREAL) : SHORTREAL ;

@findex entier
PROCEDURE entier (x: REAL) : INTEGER ;
@findex entiers
PROCEDURE entiers (x: SHORTREAL) : INTEGER ;

END MathLib0.
@end example
@page


@node gm2-libs/MemUtils, gm2-libs/NumberIO, gm2-libs/MathLib0, PIM Compatible
@subsection gm2-libs/MemUtils

@example
DEFINITION MODULE MemUtils ;

(*
    Description: provides some basic memory utilities.
*)

FROM SYSTEM IMPORT ADDRESS ;
EXPORT QUALIFIED MemCopy, MemZero ;


(*
   MemCopy - copys a region of memory to the required destination.
*)

@findex MemCopy
PROCEDURE MemCopy (from: ADDRESS; length: CARDINAL; to: ADDRESS) ;


(*
   MemZero - sets a region of memory: a..a+length to zero.
*)

@findex MemZero
PROCEDURE MemZero (a: ADDRESS; length: CARDINAL) ;


END MemUtils.
@end example
@page


@node gm2-libs/NumberIO, gm2-libs/PushBackInput, gm2-libs/MemUtils, PIM Compatible
@subsection gm2-libs/NumberIO

@example
DEFINITION MODULE NumberIO ;

(*
   Description: Provides all the input/output of numbers, and also the conversion
                of numbers to strings and visa versa.
*)

EXPORT QUALIFIED ReadCard, WriteCard, ReadHex, WriteHex, ReadInt, WriteInt,
                 CardToStr, StrToCard, StrToHex, HexToStr, StrToInt, IntToStr,
                 ReadOct, WriteOct, OctToStr, StrToOct,
                 ReadBin, WriteBin, BinToStr, StrToBin,
                 StrToBinInt, StrToHexInt, StrToOctInt ;


@findex ReadCard
PROCEDURE ReadCard (VAR x: CARDINAL) ;

@findex WriteCard
PROCEDURE WriteCard (x, n: CARDINAL) ;

@findex ReadHex
PROCEDURE ReadHex (VAR x: CARDINAL) ;

@findex WriteHex
PROCEDURE WriteHex (x, n: CARDINAL) ;

@findex ReadInt
PROCEDURE ReadInt (VAR x: INTEGER) ;

@findex WriteInt
PROCEDURE WriteInt (x: INTEGER ; n: CARDINAL) ;

@findex CardToStr
PROCEDURE CardToStr (x, n: CARDINAL ; VAR a: ARRAY OF CHAR) ;

@findex StrToCard
PROCEDURE StrToCard (a: ARRAY OF CHAR ; VAR x: CARDINAL) ;

@findex HexToStr
PROCEDURE HexToStr (x, n: CARDINAL ; VAR a: ARRAY OF CHAR) ;

@findex StrToHex
PROCEDURE StrToHex (a: ARRAY OF CHAR ; VAR x: CARDINAL) ;

@findex IntToStr
PROCEDURE IntToStr (x: INTEGER ; n: CARDINAL ; VAR a: ARRAY OF CHAR) ;

@findex StrToInt
PROCEDURE StrToInt (a: ARRAY OF CHAR ; VAR x: INTEGER) ;

@findex ReadOct
PROCEDURE ReadOct (VAR x: CARDINAL) ;

@findex WriteOct
PROCEDURE WriteOct (x, n: CARDINAL) ;

@findex OctToStr
PROCEDURE OctToStr (x, n: CARDINAL ; VAR a: ARRAY OF CHAR) ;

@findex StrToOct
PROCEDURE StrToOct (a: ARRAY OF CHAR ; VAR x: CARDINAL) ;

@findex ReadBin
PROCEDURE ReadBin (VAR x: CARDINAL) ;

@findex WriteBin
PROCEDURE WriteBin (x, n: CARDINAL) ;

@findex BinToStr
PROCEDURE BinToStr (x, n: CARDINAL ; VAR a: ARRAY OF CHAR) ;

@findex StrToBin
PROCEDURE StrToBin (a: ARRAY OF CHAR ; VAR x: CARDINAL) ;

@findex StrToBinInt
PROCEDURE StrToBinInt (a: ARRAY OF CHAR ; VAR x: INTEGER) ;

@findex StrToHexInt
PROCEDURE StrToHexInt (a: ARRAY OF CHAR ; VAR x: INTEGER) ;

@findex StrToOctInt
PROCEDURE StrToOctInt (a: ARRAY OF CHAR ; VAR x: INTEGER) ;


END NumberIO.
@end example
@page


@node gm2-libs/PushBackInput, gm2-libs/SArgs, gm2-libs/NumberIO, PIM Compatible
@subsection gm2-libs/PushBackInput

@example
DEFINITION MODULE PushBackInput ;

(*
    Description: provides a method for pushing back and consuming input
                 from a standard file descriptor. Insipred by software
                 tools.
*)

FROM FIO IMPORT File ;
FROM DynamicStrings IMPORT String ;

EXPORT QUALIFIED Open, PutCh, GetCh, Error, WarnError, WarnString, Close, SetDebug, GetExitStatus,
                 PutString, GetColumnPosition, GetCurrentLine ;


(*
   Open - opens a file for reading.
*)

@findex Open
PROCEDURE Open (a: ARRAY OF CHAR) : File ;


(*
   GetCh - gets a character from either the push back stack or
           from file, f.
*)

@findex GetCh
PROCEDURE GetCh (f: File) : CHAR ;


(*
   PutCh - pushes a character onto the push back stack, it also
           returns the character which has been pushed.
*)

@findex PutCh
PROCEDURE PutCh (f: File; ch: CHAR) : CHAR ;


(*
   PutString - pushes a string onto the push back stack.
*)

@findex PutString
PROCEDURE PutString (f: File; a: ARRAY OF CHAR) ;


(*
   Error - emits an error message with the appropriate file, line combination.
*)

@findex Error
PROCEDURE Error (a: ARRAY OF CHAR) ;


(*
   WarnError - emits an error message with the appropriate file, line combination.
               It does not terminate but when the program finishes an exit status of
               1 will be issued.
*)

@findex WarnError
PROCEDURE WarnError (a: ARRAY OF CHAR) ;


(*
   WarnString - emits an error message with the appropriate file, line combination.
                It does not terminate but when the program finishes an exit status of
                1 will be issued.
*)

@findex WarnString
PROCEDURE WarnString (s: String) ;


(*
   Close - closes the opened file.
*)

@findex Close
PROCEDURE Close (f: File) ;


(*
   GetExitStatus - returns the exit status which will be 1 if any warnings were issued.
*)

@findex GetExitStatus
PROCEDURE GetExitStatus () : CARDINAL ;


(*
   SetDebug - sets the debug flag on or off.
*)

@findex SetDebug
PROCEDURE SetDebug (d: BOOLEAN) ;


(*
   GetColumnPosition - returns the column position of the current character.
*)

@findex GetColumnPosition
PROCEDURE GetColumnPosition () : CARDINAL ;


(*
   GetCurrentLine - returns the current line number.
*)

@findex GetCurrentLine
PROCEDURE GetCurrentLine () : CARDINAL ;


END PushBackInput.
@end example
@page


@node gm2-libs/SArgs, gm2-libs/SEnvironment, gm2-libs/PushBackInput, PIM Compatible
@subsection gm2-libs/SArgs

@example
DEFINITION MODULE SArgs ;

(*
    Description: provides a String interface to the command line arguments.
*)

FROM DynamicStrings IMPORT String ;
EXPORT QUALIFIED GetArg, Narg ;


(*
   GetArg - returns the nth argument from the command line.
            The success of the operation is returned.
            If TRUE is returned then the string, s, contains a
            new string, otherwise s is set to NIL.
*)

@findex GetArg
PROCEDURE GetArg (VAR s: String ; i: CARDINAL) : BOOLEAN ;


(*
   Narg - returns the number of arguments available from
          command line.
*)

@findex Narg
PROCEDURE Narg() : CARDINAL ;


END SArgs.
@end example
@page


@node gm2-libs/SEnvironment, gm2-libs/SFIO, gm2-libs/SArgs, PIM Compatible
@subsection gm2-libs/SEnvironment

@example
DEFINITION MODULE SEnvironment ;

(*
    Description: provides access to the environment settings of a process.
*)

FROM DynamicStrings IMPORT String ;
EXPORT QUALIFIED GetEnvironment ;


(*
   GetEnvironment - gets the environment variable, env, and places
      	       	    a copy of its value into String, s.
                    TRUE is returned if successful.
*)

@findex GetEnvironment
PROCEDURE GetEnvironment (env: String; VAR s: String) : BOOLEAN ;


END SEnvironment.
@end example
@page


@node gm2-libs/SFIO, gm2-libs/SYSTEM, gm2-libs/SEnvironment, PIM Compatible
@subsection gm2-libs/SFIO

@example
DEFINITION MODULE SFIO ;

(*
    Description: provides a String interface to the opening routines of FIO
*)

FROM DynamicStrings IMPORT String ;
FROM FIO IMPORT File ;

EXPORT QUALIFIED OpenToRead, OpenToWrite, OpenForRandom, Exists, WriteS, ReadS ;


(*
   Exists - returns TRUE if a file named, fname exists for reading.
*)

@findex Exists
PROCEDURE Exists (fname: String) : BOOLEAN ;


(*
   OpenToRead - attempts to open a file, fname, for reading and
                it returns this file.
                The success of this operation can be checked by
                calling IsNoError.
*)

@findex OpenToRead
PROCEDURE OpenToRead (fname: String) : File ;


(*
   OpenToWrite - attempts to open a file, fname, for write and
                 it returns this file.
                 The success of this operation can be checked by
                 calling IsNoError.
*)

@findex OpenToWrite
PROCEDURE OpenToWrite (fname: String) : File ;


(*
   OpenForRandom - attempts to open a file, fname, for random access
                   read or write and it returns this file.
                   The success of this operation can be checked by
                   calling IsNoError.
                   towrite, determines whether the file should be
                   opened for writing or reading.
*)

@findex OpenForRandom
PROCEDURE OpenForRandom (fname: String; towrite: BOOLEAN) : File ;


(*
   WriteS - writes a string, s, to, file. It returns the String, s.
*)

@findex WriteS
PROCEDURE WriteS (file: File; s: String) : String ;


(*
   ReadS - reads a string, s, from, file. It returns the String, s.
           It stops reading the string at the end of line or end of file.
           It consumes the newline at the end of line but does not place
           this into the returned string.
*)

@findex ReadS
PROCEDURE ReadS (file: File) : String ;


END SFIO.
@end example
@page


@node gm2-libs/SYSTEM, gm2-libs/Scan, gm2-libs/SFIO, PIM Compatible
@subsection gm2-libs/SYSTEM

@example
DEFINITION MODULE SYSTEM ;

(*
   Description: Implements the SYSTEM dependent module
                in the Modula-2 compiler.
*)

EXPORT QUALIFIED (* the following are built into the compiler: *)
                 ADDRESS, WORD, BYTE, BITSET, ADR, TSIZE, SIZE ;

END SYSTEM.
@end example
@page


@node gm2-libs/Scan, gm2-libs/Selective, gm2-libs/SYSTEM, PIM Compatible
@subsection gm2-libs/Scan

@example
DEFINITION MODULE Scan ;

(*
   Description: Provides a primitive symbol fetching from input.
                Symbols are delimited by spaces and tabs.
                Limitation - only allows one source file at
                             a time to deliver symbols.
*)


EXPORT QUALIFIED GetNextSymbol, WriteError,
                 OpenSource, CloseSource,
                 TerminateOnError, DefineComments ;


(* OpenSource - opens a source file for reading.                  *)

@findex OpenSource
PROCEDURE OpenSource (a: ARRAY OF CHAR) : BOOLEAN ;


(* CloseSource - closes the current source file from reading.     *)

@findex CloseSource
PROCEDURE CloseSource ;


(* GetNextSymbol gets the next source symbol and returns it in a. *)

@findex GetNextSymbol
PROCEDURE GetNextSymbol (VAR a: ARRAY OF CHAR) ;


(* WriteError writes a message, a, under the source line, which   *)
(* attempts to pinpoint the Symbol at fault.                      *)

@findex WriteError
PROCEDURE WriteError (a: ARRAY OF CHAR) ;


(*
   TerminateOnError - exits with status 1 if we call WriteError.
*)

@findex TerminateOnError
PROCEDURE TerminateOnError ;


(*
   DefineComments - defines the start of comments within the source
                    file.

                    The characters in Start define the comment start
                    and characters in End define the end.
                    The BOOLEAN eoln determine whether the comment
                    is terminated by end of line. If eoln is TRUE
                    then End is ignored.

                    If this procedure is never called then no comments
                    are allowed.
*)

@findex DefineComments
PROCEDURE DefineComments (Start, End: ARRAY OF CHAR; eoln: BOOLEAN) ;


END Scan.
@end example
@page


@node gm2-libs/Selective, gm2-libs/StdIO, gm2-libs/Scan, PIM Compatible
@subsection gm2-libs/Selective

@example
DEFINITION MODULE Selective ;

(*
    Description: provides Modula-2 with access to the select(2) primitive.
*)

FROM SYSTEM IMPORT ADDRESS ;

EXPORT QUALIFIED SetOfFd, Timeval,
                 InitSet, KillSet, InitTime, KillTime,
                 FdZero, FdSet, FdClr, FdIsSet, Select,
                 MaxFdsPlusOne, WriteCharRaw, ReadCharRaw ;

TYPE
   SetOfFd = ADDRESS ;    (* Hidden type in Selective.c *)
   Timeval = ADDRESS ;    (* Hidden type in Selective.c *)


@findex Select
PROCEDURE Select (nooffds: CARDINAL;
                  readfds, writefds, exceptfds: SetOfFd;
                  timeout: Timeval) : INTEGER ;

@findex InitTime
PROCEDURE InitTime (sec, usec: CARDINAL) : Timeval ;
@findex KillTime
PROCEDURE KillTime (t: Timeval) : Timeval ;
@findex InitSet
PROCEDURE InitSet () : SetOfFd ;
@findex KillSet
PROCEDURE KillSet (s: SetOfFd) : SetOfFd ;
@findex FdZero
PROCEDURE FdZero (s: SetOfFd) ;
@findex FdSet
PROCEDURE FdSet (fd: INTEGER; s: SetOfFd) ;
@findex FdClr
PROCEDURE FdClr (fd: INTEGER; s: SetOfFd) ;
@findex FdIsSet
PROCEDURE FdIsSet (fd: INTEGER; s: SetOfFd) : BOOLEAN ;
@findex MaxFdsPlusOne
PROCEDURE MaxFdsPlusOne (a, b: INTEGER) : INTEGER ;

(* you must use the raw routines with select - not the FIO buffered routines *)
@findex WriteCharRaw
PROCEDURE WriteCharRaw (fd: INTEGER; ch: CHAR) ;
@findex ReadCharRaw
PROCEDURE ReadCharRaw (fd: INTEGER) : CHAR ;


END Selective.
@end example
@page


@node gm2-libs/StdIO, gm2-libs/Storage, gm2-libs/Selective, PIM Compatible
@subsection gm2-libs/StdIO

@example
DEFINITION MODULE StdIO ;

(*
   Description: Exports a general Read and Write procedure that ALL character
                processes should use.
*)

EXPORT QUALIFIED ProcRead, ProcWrite,
                 Read, Write, PushOutput, PopOutput, GetCurrentOutput ;


TYPE
   ProcWrite = PROCEDURE (CHAR) ;
   ProcRead  = PROCEDURE (VAR CHAR) ;


(*
   Read - is the generic procedure that all higher application layers
          should use to receive a character.
*)

@findex Read
PROCEDURE Read (VAR ch: CHAR) ;


(*
   Write - is the generic procedure that all higher application layers
           should use to emit a character.
*)

@findex Write
PROCEDURE Write (ch: CHAR) ;


(*
   PushOutput - pushes the current Write procedure onto a stack,
                any future references to Write will actually invoke
                procedure, p.
*)

@findex PushOutput
PROCEDURE PushOutput (p: ProcWrite) ;


(*
   PopOutput - restores Write to use the previous output procedure.
*)

@findex PopOutput
PROCEDURE PopOutput ;


(*
   GetCurrentOutput - returns the current output procedure.
*)

@findex GetCurrentOutput
PROCEDURE GetCurrentOutput () : ProcWrite ;


END StdIO.
@end example
@page


@node gm2-libs/Storage, gm2-libs/StrCase, gm2-libs/StdIO, PIM Compatible
@subsection gm2-libs/Storage

@example
DEFINITION MODULE Storage ;

(*
   Description: Implements the dynamic Storage handler for the
                Modula-2 compiler.
*)

FROM SYSTEM IMPORT ADDRESS ;

EXPORT QUALIFIED ALLOCATE, DEALLOCATE, Available ;



(*
   ALLOCATE - attempt to allocate memory from the heap.
              NIL is returned in, a, if ALLOCATE fails.
*)

@findex ALLOCATE
PROCEDURE ALLOCATE (VAR a: ADDRESS ; Size: CARDINAL) ;


(*
   DEALLOCATE - return, Size, bytes to the heap.
                The variable, a, is set to NIL.
*)

@findex DEALLOCATE
PROCEDURE DEALLOCATE (VAR a: ADDRESS ; Size: CARDINAL) ;


(*
   Available - returns TRUE if, Size, bytes can be allocated.
*)

@findex Available
PROCEDURE Available (Size: CARDINAL) : BOOLEAN;


END Storage.

@end example
@page


@node gm2-libs/StrCase, gm2-libs/StrIO, gm2-libs/Storage, PIM Compatible
@subsection gm2-libs/StrCase

@example
DEFINITION MODULE StrCase ;


EXPORT QUALIFIED StrToUpperCase, StrToLowerCase, Cap, Lower ;


(*
   StrToUpperCase - converts string, a, to uppercase returning the
                    result in, b.
*)

@findex StrToUpperCase
PROCEDURE StrToUpperCase (a: ARRAY OF CHAR ; VAR b: ARRAY OF CHAR) ;


(*
   StrToLowerCase - converts string, a, to lowercase returning the
                    result in, b.
*)

@findex StrToLowerCase
PROCEDURE StrToLowerCase (a: ARRAY OF CHAR ; VAR b: ARRAY OF CHAR) ;


(*
   Cap - converts a lower case character into a capital character.
         If the character is not a lower case character 'a'..'z'
         then the character is simply returned unaltered.
*)

@findex Cap
PROCEDURE Cap (ch: CHAR) : CHAR ;


(*
   Lower - converts an upper case character into a lower case character.
           If the character is not an upper case character 'A'..'Z'
           then the character is simply returned unaltered.
*)

@findex Lower
PROCEDURE Lower (ch: CHAR) : CHAR ;


END StrCase.
@end example
@page


@node gm2-libs/StrIO, gm2-libs/StrLib, gm2-libs/StrCase, PIM Compatible
@subsection gm2-libs/StrIO

@example
DEFINITION MODULE StrIO ;

(*
   Description: Provides simple string input output routines.
*)

EXPORT QUALIFIED ReadString, WriteString,
                 WriteLn ;


(*
   WriteLn - writes a carriage return and a newline
             character.
*)

@findex WriteLn
PROCEDURE WriteLn ;


(*
   ReadString - reads a sequence of characters into a string.
                Line editing accepts Del, Ctrl H, Ctrl W and
                Ctrl U.
*)

@findex ReadString
PROCEDURE ReadString (VAR a: ARRAY OF CHAR) ;


(*
   WriteString - writes a string to the default output.
*)

@findex WriteString
PROCEDURE WriteString (a: ARRAY OF CHAR) ;



END StrIO.
@end example
@page


@node gm2-libs/StrLib, gm2-libs/StringConvert, gm2-libs/StrIO, PIM Compatible
@subsection gm2-libs/StrLib

@example
DEFINITION MODULE StrLib ;

(*
   Description: Provides string manipulation
*)

EXPORT QUALIFIED StrLen, StrCopy, StrEqual, StrConCat, StrLess,
      	       	 IsSubString, StrRemoveWhitePrefix ;


(*
   StrLess - returns TRUE if string, a, alphabetically occurs before
             string, b.
*)

@findex StrLess
PROCEDURE StrLess (a, b: ARRAY OF CHAR) : BOOLEAN ;


(*
   StrEqual - performs a = b on two strings.
*)

@findex StrEqual
PROCEDURE StrEqual (a, b: ARRAY OF CHAR) : BOOLEAN ;


(*
   StrLen - returns the length of string, a.
*)

@findex StrLen
PROCEDURE StrLen (a: ARRAY OF CHAR) : CARDINAL ;


(*
   StrCopy - effectively performs b := a with two strings.
*)

@findex StrCopy
PROCEDURE StrCopy (a: ARRAY OF CHAR ; VAR b: ARRAY OF CHAR) ;


(*
   StrConCat - combines a and b into c.
*)

@findex StrConCat
PROCEDURE StrConCat (a, b: ARRAY OF CHAR; VAR c: ARRAY OF CHAR) ;


(*
   IsSubString - returns true if b is a subcomponent of a.
*)

@findex IsSubString
PROCEDURE IsSubString (a, b: ARRAY OF CHAR) : BOOLEAN ;


(*
   StrRemoveWhitePrefix - copies string, into string, b, excluding any white
                          space infront of a.
*)

@findex StrRemoveWhitePrefix
PROCEDURE StrRemoveWhitePrefix (a: ARRAY OF CHAR; VAR b: ARRAY OF CHAR) ;


END StrLib.
@end example
@page


@node gm2-libs/StringConvert, gm2-libs/SysStorage, gm2-libs/StrLib, PIM Compatible
@subsection gm2-libs/StringConvert

@example
DEFINITION MODULE StringConvert ;

(*
    Description: provides functions to convert numbers to and from strings.
*)

FROM DynamicStrings IMPORT String ;
EXPORT QUALIFIED IntegerToString, CardinalToString, StringToInteger,
                 stoi, itos, ctos, stoc, hstoi, ostoi, bstoi,
                 hstoc, ostoc, bstoc,
                 StringToLongreal, stor, stolr ;


(*
   IntegerToString - converts INTEGER, i, into a String. The field with can be specified
                     if non zero. Leading characters are defined by padding and this
                     function will prepend a + if sign is set to TRUE.
                     The base allows the caller to generate binary, octal, decimal, hexidecimal
                     numbers. The value of lower is only used when hexidecimal numbers are
                     generated and if TRUE then digits abcdef are used, and if FALSE then ABCDEF
                     are used.
*)

@findex IntegerToString
PROCEDURE IntegerToString (i: INTEGER; width: CARDINAL; padding: CHAR; sign: BOOLEAN;
                           base: CARDINAL; lower: BOOLEAN) : String ;


(*
   CardinalToString - converts CARDINAL, c, into a String. The field with can be specified
                      if non zero. Leading characters are defined by padding.
                      The base allows the caller to generate binary, octal, decimal, hexidecimal
                      numbers. The value of lower is only used when hexidecimal numbers are
                      generated and if TRUE then digits abcdef are used, and if FALSE then ABCDEF
                      are used.
*)

@findex CardinalToString
PROCEDURE CardinalToString (c: CARDINAL; width: CARDINAL; padding: CHAR;
                            base: CARDINAL; lower: BOOLEAN) : String ;


(*
   StringToInteger - converts a string, s, of, base, into an INTEGER.
                     Leading white space is ignored. It stops converting
                     when either the string is exhausted or if an illegal
                     numeral is found.
                     The parameter found is set TRUE if a number was found.
*)

@findex StringToInteger
PROCEDURE StringToInteger (s: String; base: CARDINAL; VAR found: BOOLEAN) : INTEGER ;


(*
   stoi - decimal string to INTEGER
*)

@findex stoi
PROCEDURE stoi (s: String) : INTEGER ;


(*
   itos - integer to decimal string.
*)

@findex itos
PROCEDURE itos (i: INTEGER; width: CARDINAL; padding: CHAR; sign: BOOLEAN) : String ;


(*
   ctos - cardinal to decimal string.
*)

@findex ctos
PROCEDURE ctos (c: CARDINAL; width: CARDINAL; padding: CHAR) : String ;


(*
   stoc - decimal string to CARDINAL
*)

@findex stoc
PROCEDURE stoc (s: String) : CARDINAL ;


(*
   hstoi - hexidecimal string to INTEGER
*)

@findex hstoi
PROCEDURE hstoi (s: String) : INTEGER ;


(*
   ostoi - octal string to INTEGER
*)

@findex ostoi
PROCEDURE ostoi (s: String) : INTEGER ;


(*
   bstoi - binary string to INTEGER
*)

@findex bstoi
PROCEDURE bstoi (s: String) : INTEGER ;


(*
   hstoc - hexidecimal string to CARDINAL
*)

@findex hstoc
PROCEDURE hstoc (s: String) : CARDINAL ;


(*
   ostoc - octal string to CARDINAL
*)

@findex ostoc
PROCEDURE ostoc (s: String) : CARDINAL ;


(*
   bstoc - binary string to CARDINAL
*)

@findex bstoc
PROCEDURE bstoc (s: String) : CARDINAL ;


(*
   StringToLongreal - returns a LONGREAL and sets found to TRUE if a legal number is seen.
*)

@findex StringToLongreal
PROCEDURE StringToLongreal (s: String; VAR found: BOOLEAN) : LONGREAL ;


(*
   stor - returns a REAL given a string.
*)

@findex stor
PROCEDURE stor (s: String) : REAL ;


(*
   stolr - returns a LONGREAL given a string.
*)

@findex stolr
PROCEDURE stolr (s: String) : LONGREAL ;


END StringConvert.
@end example
@page


@node gm2-libs/SysStorage, gm2-libs/TimeString, gm2-libs/StringConvert, PIM Compatible
@subsection gm2-libs/SysStorage

@example
DEFINITION MODULE SysStorage ;

(*
    Description: provides dynamic allocation for the system components
                 of a realtime system. This allows the application to
                 use the traditional Storage module which can be
                 handled differently.
*)

FROM SYSTEM IMPORT ADDRESS ;

EXPORT QUALIFIED ALLOCATE, DEALLOCATE, Available, Init ;


(*
   ALLOCATE - attempt to allocate memory from the heap.
              NIL is returned in, a, if ALLOCATE fails.
*)

@findex ALLOCATE
PROCEDURE ALLOCATE (VAR a: ADDRESS ; Size: CARDINAL) ;


(*
   DEALLOCATE - return, Size, bytes to the heap.
                The variable, a, is set to NIL.
*)

@findex DEALLOCATE
PROCEDURE DEALLOCATE (VAR a: ADDRESS ; Size: CARDINAL) ;


(*
   Available - returns TRUE if, Size, bytes can be allocated.
*)

@findex Available
PROCEDURE Available (Size: CARDINAL) : BOOLEAN;


(*
   Init - initializes the heap.
*)

@findex Init
PROCEDURE Init ;


END SysStorage.

@end example
@page


@node gm2-libs/TimeString, gm2-libs/UnixArgs, gm2-libs/SysStorage, PIM Compatible
@subsection gm2-libs/TimeString

@example
DEFINITION MODULE TimeString ;

(*
    Description: Provides time related string manipulation procedures.
*)


EXPORT QUALIFIED GetTimeString ;


(*
   GetTimeString - places the time in ascii format into array, a.

*)

@findex GetTimeString
PROCEDURE GetTimeString (VAR a: ARRAY OF CHAR) ;


END TimeString.
@end example
@page


@node gm2-libs/UnixArgs, gm2-libs/cbuiltin, gm2-libs/TimeString, PIM Compatible
@subsection gm2-libs/UnixArgs

@example
DEFINITION MODULE UnixArgs ;

(*
   Description: Implements access to the C arguments argc and argv.
*)

FROM SYSTEM IMPORT ADDRESS ;

EXPORT QUALIFIED ArgC, ArgV ;


VAR
   ArgC: CARDINAL ;
   ArgV: ADDRESS ;


END UnixArgs.
@end example
@page


@node gm2-libs/cbuiltin, gm2-libs/libc, gm2-libs/UnixArgs, PIM Compatible
@subsection gm2-libs/cbuiltin

@example
DEFINITION MODULE FOR "C" cbuiltin ;

(*
    Description: provides replacement routines in case the builtins are not used
                 by GNU Modula-2. This module is called by implementation modules
                 which implement builtins (see Builtins.mod for an example).
*)

FROM SYSTEM IMPORT ADDRESS ;
EXPORT UNQUALIFIED alloca, memcpy,
                   sinf, sinl, sin,
                   cosf, cosl, cos,
                   sqrtf, sqrtl, sqrt,
                   fabsf, fabsl, fabs,
                   index, rindex,
                   memcmp, memset,
                   strcat, strncat, strcpy, strncpy, strcmp, strncmp,
                   strlen, strstr, strpbrk, strspn, strcspn, strchr, strrchr ;

@findex alloca
PROCEDURE alloca (i: CARDINAL) : ADDRESS ;
@findex memcpy
PROCEDURE memcpy (dest, src: ADDRESS; n: CARDINAL) : ADDRESS ;
@findex sinf
PROCEDURE sinf (x: SHORTREAL) : SHORTREAL ;
@findex sin
PROCEDURE sin (x: REAL) : REAL ;
@findex sinl
PROCEDURE sinl (x: LONGREAL) : LONGREAL ;
@findex cosf
PROCEDURE cosf (x: SHORTREAL) : SHORTREAL ;
@findex cos
PROCEDURE cos (x: REAL) : REAL ;
@findex cosl
PROCEDURE cosl (x: LONGREAL) : LONGREAL ;
@findex sqrtf
PROCEDURE sqrtf (x: SHORTREAL) : SHORTREAL ;
@findex sqrt
PROCEDURE sqrt (x: REAL) : REAL ;
@findex sqrtl
PROCEDURE sqrtl (x: LONGREAL) : LONGREAL ;
@findex fabsf
PROCEDURE fabsf (x: SHORTREAL) : SHORTREAL ;
@findex fabs
PROCEDURE fabs (x: REAL) : REAL ;
@findex fabsl
PROCEDURE fabsl (x: LONGREAL) : LONGREAL ;
@findex index
PROCEDURE index (s: ADDRESS; c: INTEGER) : ADDRESS ;
@findex rindex
PROCEDURE rindex (s: ADDRESS; c: INTEGER) : ADDRESS ;
@findex memcmp
PROCEDURE memcmp (s1, s2: ADDRESS; n: CARDINAL) : INTEGER ;
@findex memset
PROCEDURE memset (s: ADDRESS; c: INTEGER; n: CARDINAL) : ADDRESS ;
@findex strcat
PROCEDURE strcat (dest, src: ADDRESS) : ADDRESS ;
@findex strncat
PROCEDURE strncat (dest, src: ADDRESS; n: CARDINAL) : ADDRESS ;
@findex strcpy
PROCEDURE strcpy (dest, src: ADDRESS) : ADDRESS ;
@findex strncpy
PROCEDURE strncpy (dest, src: ADDRESS; n: CARDINAL) : ADDRESS ;
@findex strcmp
PROCEDURE strcmp (s1, s2: ADDRESS) : INTEGER ;
@findex strncmp
PROCEDURE strncmp (s1, s2: ADDRESS; n: CARDINAL) : INTEGER ;
@findex strlen
PROCEDURE strlen (s: ADDRESS) : INTEGER ;
@findex strstr
PROCEDURE strstr (haystack, needle: ADDRESS) : ADDRESS ;
@findex strpbrk
PROCEDURE strpbrk (s, accept: ADDRESS) : ADDRESS ;
@findex strspn
PROCEDURE strspn (s, accept: ADDRESS) : CARDINAL ;
@findex strcspn
PROCEDURE strcspn (s, accept: ADDRESS) : CARDINAL ;
@findex strchr
PROCEDURE strchr (s: ADDRESS; c: INTEGER) : ADDRESS ;
@findex strrchr
PROCEDURE strrchr (s: ADDRESS; c: INTEGER) : ADDRESS ;

END cbuiltin.
@end example
@page


@node gm2-libs/libc, gm2-libs/libm, gm2-libs/cbuiltin, PIM Compatible
@subsection gm2-libs/libc

@example
DEFINITION MODULE FOR "C" libc ;

(*
   Description: Provides an interface to the C library functions.
*)

FROM SYSTEM IMPORT ADDRESS ;

EXPORT UNQUALIFIED write, read,
                   system, abort,
                   malloc, free,
                   exit, isatty,
                   getenv, getpid,
                   dup, close, open, lseek,
                   readv, writev,
                   perror, creat,
                   getcwd, chown, strlen, strcpy, strncpy,
                   unlink,
                   memcpy, memset, printf ;


(*
     int write(d, buf, nbytes)
     int d;
     char *buf;
     int nbytes;
*)

@findex write
PROCEDURE write (d: INTEGER; buf: ADDRESS; nbytes: INTEGER) : INTEGER ;


(*
     int read(d, buf, nbytes)
     int d;
     char *buf;
     int nbytes;
*)

@findex read
PROCEDURE read (d: INTEGER; buf: ADDRESS; nbytes: INTEGER) : INTEGER ;


(*
     int system(string)
     char *string;
*)

@findex system
PROCEDURE system (a: ADDRESS) : INTEGER ;


(*
     abort - generate a fault

     abort() first closes all open files if possible, then sends
     an IOT signal to the process.  This signal usually results
     in termination with a core dump, which may be used for
     debugging.

     It is possible for abort() to return control if is caught or
     ignored, in which case the value returned is that of the
     kill(2V) system call.
*)

@findex abort
PROCEDURE abort ;


(*
     malloc - memory allocator.

     char *malloc(size)
     unsigned size;

     malloc() returns a pointer to a block of at least size
     bytes, which is appropriately aligned.  If size is zero,
     malloc() returns a non-NULL pointer, but this pointer should
     not be dereferenced.
*)

@findex malloc
PROCEDURE malloc (size: CARDINAL) : ADDRESS ;


(*
     free - memory deallocator.

     free(ptr)
     char *ptr;

     free() releases a previously allocated block.  Its argument
     is a pointer to a block previously allocated by malloc, cal-
     loc, realloc, malloc, or memalign.
*)

@findex free
PROCEDURE free (ptr: ADDRESS) ;


(*
   isatty - does this descriptor refer to a terminal.
*)

@findex isatty
PROCEDURE isatty (fd: INTEGER) : INTEGER ;


(*
   exit - returns control to the invoking process. Result, r, is
          returned.
*)

@findex exit
PROCEDURE exit (r: INTEGER) ;


(*
   getenv - returns the C string for the equivalent C environment
            variable.
*)

@findex getenv
PROCEDURE getenv (s: ADDRESS) : ADDRESS ;


(*
   getpid - returns the UNIX process identification number.
*)

@findex getpid
PROCEDURE getpid () : INTEGER ;


(*
   dup - duplicates the file descriptor, d.
*)

@findex dup
PROCEDURE dup (d: INTEGER) : INTEGER ;


(*
   close - closes the file descriptor, d.
*)

@findex close
PROCEDURE close (d: INTEGER) : INTEGER ;


(*
   open - open the file, filename with flag and mode.
*)

@findex open
PROCEDURE open (filename: ADDRESS; flag, mode: CARDINAL) : INTEGER ;


(*
   creat - creates a new file
*)

@findex creat
PROCEDURE creat (filename : ADDRESS; mode : CARDINAL) : INTEGER;


(*
   lseek - calls unix lseek:

           off_t lseek(int fildes, off_t offset, int whence);
*)

@findex lseek
PROCEDURE lseek (fd: INTEGER; offset: INTEGER; whence: INTEGER) : INTEGER ;


(*
   perror - writes errno and string
*)

@findex perror
PROCEDURE perror (string: ADDRESS);


(*
   readv - reads an io vector of bytes.
*)

@findex readv
PROCEDURE readv (fd: INTEGER; v: ADDRESS; n: INTEGER) : INTEGER ;


(*
   writev - writes an io vector of bytes.
*)

@findex writev
PROCEDURE writev (fd: INTEGER; v: ADDRESS; n: INTEGER) : INTEGER ;


(*
   getcwd - copies the absolute pathname of  the
            current  working directory to the array pointed to by buf,
            which is of length size.

            If the current absolute path name would require  a  buffer
            longer  than size elements, NULL is returned, and errno is
            set to ERANGE; an application should check for this error,
            and allocate a larger buffer if necessary.
*)

@findex getcwd
PROCEDURE getcwd (buf: ADDRESS; size: INTEGER) : ADDRESS ;


(*
   chown - The  owner  of  the  file  specified  by  path or by fd is
           changed.  Only the super-user may change the  owner  of  a
           file.   The  owner  of  a file may change the group of the
           file to any group of which that owner is  a  member.   The
           super-user may change the group arbitrarily.

           If  the owner or group is specified as -1, then that ID is
           not changed.

           On success, zero is returned.  On error, -1  is  returned,
           and errno is set appropriately.
*)

@findex chown
PROCEDURE chown (filename: ADDRESS; uid, gid: INTEGER) : INTEGER ;


(*
   strlen - returns the length of string, a.
*)

@findex strlen
PROCEDURE strlen (a: ADDRESS) : INTEGER ;


(*
   strcpy - copies string, src, into, dest.
            It returns dest.
*)

@findex strcpy
PROCEDURE strcpy (dest, src: ADDRESS) : ADDRESS ;


(*
   strncpy - copies string, src, into, dest, copying at most, n, bytes.
             It returns dest.
*)

@findex strncpy
PROCEDURE strncpy (dest, src: ADDRESS; n: CARDINAL) : ADDRESS ;


(*
   unlink - removes file and returns 0 if successful.
*)

@findex unlink
PROCEDURE unlink (file: ADDRESS) : INTEGER ;


(*
   memcpy - copy memory area

   SYNOPSIS

   #include <string.h>

   void *memcpy(void *dest, const void *src, size_t n);
   It returns dest.
*)

@findex memcpy
PROCEDURE memcpy (dest, src: ADDRESS; size: CARDINAL) : ADDRESS ;


(*
   memset - fill memory with a constant byte

   SYNOPSIS

   #include <string.h>

   void *memset(void *s, int c, size_t n);
*)

@findex memset
PROCEDURE memset (s: ADDRESS; c: INTEGER; size: CARDINAL) : ADDRESS ;


(*
   int printf(const char *format, ...);
*)

@findex printf
PROCEDURE printf (format: ARRAY OF CHAR; ...) : INTEGER ;


END libc.
@end example
@page


@node gm2-libs/libm, gm2-libs/wrapc, gm2-libs/libc, PIM Compatible
@subsection gm2-libs/libm

@example
DEFINITION MODULE FOR "C" libm ;

(*
    Description: provides access to libm. Users are strongly advised to
                 use MathLib0 or RealMath as call to functions within
                 these modules will generate inline code. This module
                 is used by MathLib0 and RealMath when inline code cannot
                 be generated.
*)

EXPORT UNQUALIFIED sin, cos, tan, sqrt,
                   asin, acos, atan, exp, log, pow ;

@findex sin
PROCEDURE sin (x: REAL) : REAL ;
@findex cos
PROCEDURE cos (x: REAL) : REAL ;
@findex tan
PROCEDURE tan (x: REAL) : REAL ;
@findex sqrt
PROCEDURE sqrt (x: REAL) : REAL ;
@findex asin
PROCEDURE asin (x: REAL) : REAL ;
@findex acos
PROCEDURE acos (x: REAL) : REAL ;
@findex atan
PROCEDURE atan (x: REAL) : REAL ;
@findex exp
PROCEDURE exp (x: REAL) : REAL ;
@findex log
PROCEDURE log (x: REAL) : REAL ;
@findex pow
PROCEDURE pow (x, y: REAL) : REAL ;
@findex floor
PROCEDURE floor (x: REAL) : REAL ;
@findex ceil
PROCEDURE ceil (x: REAL) : REAL ;

END libm.
@end example
@page


@node gm2-libs/wrapc, , gm2-libs/libm, PIM Compatible
@subsection gm2-libs/wrapc

@example
DEFINITION MODULE wrapc ;

(*
   Description: Provides a Modula-2 interface to the C
                library functionality.
*)

FROM SYSTEM IMPORT ADDRESS ;

EXPORT QUALIFIED strtime, filesize, getrand, getusername, filemtime,
                 getnameuidgid ;


(*
   strtime - returns the C string for the equivalent C asctime
             function.
*)

@findex strtime
PROCEDURE strtime () : ADDRESS ;


(*
   filesize - returns the size of a file, f.
*)

@findex filesize
PROCEDURE filesize (f: INTEGER) : CARDINAL ;


(*
   filemtime - returns the mtime of a file, f.
*)

@findex filemtime
PROCEDURE filemtime (f: INTEGER) : INTEGER ;


(*
   getrand - returns a random number between 0..n-1
*)

@findex getrand
PROCEDURE getrand (n: INTEGER) : INTEGER ;


(*
   getusername - returns a C string describing the current user.
*)

@findex getusername
PROCEDURE getusername () : ADDRESS ;


(*
   getnameuidgid - fills in the, uid, and, gid, which represents
                   user, name.
*)

@findex getnameuidgid
PROCEDURE getnameuidgid (name: ADDRESS; VAR uid, gid: INTEGER) ;


END wrapc.
@end example
@page



@c ---------------------------------------------------------------------
@node M2 ISO Libraries, , PIM Compatible, Libraries
@section M2 ISO Libraries


This directory contains the ISO definition modules and some corresponding
implementation modules. Currently this is work in progress and the code
is incomplete and probably highly buggy.

@menu
* gm2-iso/COROUTINES::COROUTINES.def
* gm2-iso/ChanConsts::ChanConsts.def
* gm2-iso/CharClass::CharClass.def
* gm2-iso/ComplexMath::ComplexMath.def
* gm2-iso/ConvTypes::ConvTypes.def
* gm2-iso/EXCEPTIONS::EXCEPTIONS.def
* gm2-iso/GeneralUser::GeneralUser.def
* gm2-iso/IOChan::IOChan.def
* gm2-iso/IOConsts::IOConsts.def
* gm2-iso/IOLink::IOLink.def
* gm2-iso/IOResult::IOResult.def
* gm2-iso/LongComplex::LongComplex.def
* gm2-iso/LongConv::LongConv.def
* gm2-iso/LongIO::LongIO.def
* gm2-iso/LongMath::LongMath.def
* gm2-iso/LongStr::LongStr.def
* gm2-iso/LowLong::LowLong.def
* gm2-iso/LowReal::LowReal.def
* gm2-iso/M2EXCEPTION::M2EXCEPTION.def
* gm2-iso/Processes::Processes.def
* gm2-iso/ProgramArgs::ProgramArgs.def
* gm2-iso/RawIO::RawIO.def
* gm2-iso/RealConv::RealConv.def
* gm2-iso/RealIO::RealIO.def
* gm2-iso/RealMath::RealMath.def
* gm2-iso/RealStr::RealStr.def
* gm2-iso/RndFile::RndFile.def
* gm2-iso/SIOResult::SIOResult.def
* gm2-iso/SLongIO::SLongIO.def
* gm2-iso/SRawIO::SRawIO.def
* gm2-iso/SRealIO::SRealIO.def
* gm2-iso/STextIO::STextIO.def
* gm2-iso/SWholeIO::SWholeIO.def
* gm2-iso/SYSTEM::SYSTEM.def
* gm2-iso/Semaphores::Semaphores.def
* gm2-iso/SeqFile::SeqFile.def
* gm2-iso/StdChans::StdChans.def
* gm2-iso/Storage::Storage.def
* gm2-iso/StreamFile::StreamFile.def
* gm2-iso/Strings::Strings.def
* gm2-iso/SysClock::SysClock.def
* gm2-iso/TERMINATION::TERMINATION.def
* gm2-iso/TermFile::TermFile.def
* gm2-iso/TextIO::TextIO.def
* gm2-iso/WholeConv::WholeConv.def
* gm2-iso/WholeIO::WholeIO.def
* gm2-iso/WholeStr::WholeStr.def
@end menu


@node gm2-iso/COROUTINES, gm2-iso/ChanConsts, , M2 ISO Libraries
@subsection gm2-iso/COROUTINES

@example
DEFINITION MODULE COROUTINES;

(* Facilities for coroutines and the handling of interrupts *)

IMPORT SYSTEM;

TYPE
  COROUTINE; (* Values of this type are created dynamically by NEWCOROUTINE
                and identify the coroutine in subsequent operations *)
  INTERRUPTSOURCE = <implementation-defined>;

@findex NEWCOROUTINE
PROCEDURE NEWCOROUTINE (procBody: PROC; workspace: SYSTEM.ADDRESS; size: CARDINAL;
                        VAR cr: COROUTINE[; initProtection: PROTECTION]);
  (* Creates a new coroutine whose body is given by procBody, and returns the identity
     of the coroutine in cr.  workspace is a pointer to the work space allocated to
     the coroutine; size specifies the size of this workspace in terms of SYSTEM.LOC.
     initProtection is an optional parameter that specifies the initial protection
     level of the coroutine.
  *)

@findex TRANSFER
PROCEDURE TRANSFER (VAR from: COROUTINE; to: COROUTINE);
  (* Returns the identity of the calling coroutine in from, and transfers control to
     the coroutine specified by to.
  *)

@findex IOTRANSFER
PROCEDURE IOTRANSFER (VAR from: COROUTINE; to: COROUTINE);
  (* Returns the identity of the calling coroutine in from and transfers control to
     the coroutine specified by to.  On occurrence of an interrupt, associated with the
     caller, control is transferred back to the caller, and the identity of the
     interrupted coroutine is returned in from.  The calling coroutine must be
     associated with a source of interrupts.
  *)

@findex ATTACH
PROCEDURE ATTACH (source: INTERRUPTSOURCE);
  (* Associates the specified source of interrupts with the calling coroutine. *)

@findex DETACH
PROCEDURE DETACH (source: INTERRUPTSOURCE);
  (* Dissociates the specified source of interrupts from the calling coroutine. *)

@findex IsATTACHED
PROCEDURE IsATTACHED (source: INTERRUPTSOURCE): BOOLEAN;
  (* Returns TRUE if and only if the specified source of interrupts is currently
     associated with a coroutine; otherwise returns FALSE.
  *)

@findex HANDLER
PROCEDURE HANDLER (source: INTERRUPTSOURCE): COROUTINE;
  (* Returns the coroutine, if any, that is associated with the source of interrupts.
     The result is undefined if IsATTACHED(source) = FALSE.
  *)

@findex CURRENT
PROCEDURE CURRENT (): COROUTINE;
  (* Returns the identity of the calling coroutine. *)

@findex LISTEN
PROCEDURE LISTEN (p: PROTECTION);
  (* Momentarily changes the protection of the calling coroutine to p. *)

@findex PROT
PROCEDURE PROT (): PROTECTION;
  (* Returns the protection of the calling coroutine. *)

END COROUTINES.
@end example
@page


@node gm2-iso/ChanConsts, gm2-iso/CharClass, gm2-iso/COROUTINES, M2 ISO Libraries
@subsection gm2-iso/ChanConsts

@example
DEFINITION MODULE ChanConsts;

  (* Common types and values for channel open requests and results *)

TYPE
  ChanFlags =        (* Request flags possibly given when a channel is opened *)
  ( readFlag,        (* input operations are requested/available *)
    writeFlag,       (* output operations are requested/available *)
    oldFlag,         (* a file may/must/did exist before the channel is opened *)
    textFlag,        (* text operations are requested/available *)
    rawFlag,         (* raw operations are requested/available *)
    interactiveFlag, (* interactive use is requested/applies *)
    echoFlag         (* echoing by interactive device on removal of characters from input
                        stream requested/applies *)
  );

  FlagSet = SET OF ChanFlags;

  (* Singleton values of FlagSet, to allow for example, read + write *)

CONST
  read = FlagSet@{readFlag@};   (* input operations are requested/available *)
  write = FlagSet@{writeFlag@}; (* output operations are requested/available *)
  old = FlagSet@{oldFlag@};     (* a file may/must/did exist before the channel is opened *)
  text = FlagSet@{textFlag@};   (* text operations are requested/available *)
  raw = FlagSet@{rawFlag@};     (* raw operations are requested/available *)
  interactive = FlagSet@{interactiveFlag@}; (* interactive use is requested/applies *)
  echo = FlagSet@{echoFlag@};   (* echoing by interactive device on removal of characters from
                                 input stream requested/applies *)

TYPE
  OpenResults =        (* Possible results of open requests *)
    (opened,           (* the open succeeded as requested *)
     wrongNameFormat,  (* given name is in the wrong format for the implementation *)
     wrongFlags,       (* given flags include a value that does not apply to the device *)
     tooManyOpen,      (* this device cannot support any more open channels *)
     outOfChans,       (* no more channels can be allocated *)
     wrongPermissions, (* file or directory permissions do not allow request *)
     noRoomOnDevice,   (* storage limits on the device prevent the open *)
     noSuchFile,       (* a needed file does not exist *)
     fileExists,       (* a file of the given name already exists when a new one is required *)
     wrongFileType,    (* the file is of the wrong type to support the required operations *)
      noTextOperations, (* text operations have been requested, but are not supported *)
     noRawOperations,  (* raw operations have been requested, but are not supported *)
     noMixedOperations,(* text and raw operations have been requested, but they
                          are not supported in combination *)
     alreadyOpen,      (* the source/destination is already open for operations not supported
                          in combination with the requested operations *)
     otherProblem      (* open failed for some other reason *)
    );

END ChanConsts.

@end example
@page


@node gm2-iso/CharClass, gm2-iso/ComplexMath, gm2-iso/ChanConsts, M2 ISO Libraries
@subsection gm2-iso/CharClass

@example
DEFINITION MODULE CharClass;

  (* Classification of values of the type CHAR *)

@findex IsNumeric
PROCEDURE IsNumeric (ch: CHAR): BOOLEAN;
  (* Returns TRUE if and only if ch is classified as a numeric character *)

@findex IsLetter
PROCEDURE IsLetter (ch: CHAR): BOOLEAN;
  (* Returns TRUE if and only if ch is classified as a letter *)

@findex IsUpper
PROCEDURE IsUpper (ch: CHAR): BOOLEAN;
  (* Returns TRUE if and only if ch is classified as an upper case letter *)

@findex IsLower
PROCEDURE IsLower (ch: CHAR): BOOLEAN;
  (* Returns TRUE if and only if ch is classified as a lower case letter *)

@findex IsControl
PROCEDURE IsControl (ch: CHAR): BOOLEAN;
  (* Returns TRUE if and only if ch represents a control function *)

@findex IsWhiteSpace
PROCEDURE IsWhiteSpace (ch: CHAR): BOOLEAN;
  (* Returns TRUE if and only if ch represents a space character or a format effector *)

END CharClass.

@end example
@page


@node gm2-iso/ComplexMath, gm2-iso/ConvTypes, gm2-iso/CharClass, M2 ISO Libraries
@subsection gm2-iso/ComplexMath

@example
DEFINITION MODULE ComplexMath;

  (* Mathematical functions for the type COMPLEX *)

CONST
  i =    CMPLX (0.0, 1.0);
  one =  CMPLX (1.0, 0.0);
  zero = CMPLX (0.0, 0.0);

@findex abs
PROCEDURE abs (z: COMPLEX): REAL;
  (* Returns the length of z *)

@findex arg
PROCEDURE arg (z: COMPLEX): REAL;
  (* Returns the angle that z subtends to the positive real axis *)

@findex conj
PROCEDURE conj (z: COMPLEX): COMPLEX;
  (* Returns the complex conjugate of z *)

@findex power
PROCEDURE power (base: COMPLEX; exponent: REAL): COMPLEX;
  (* Returns the value of the number base raised to the power exponent *)

@findex sqrt
PROCEDURE sqrt (z: COMPLEX): COMPLEX;
  (* Returns the principal square root of z *)

@findex exp
PROCEDURE exp (z: COMPLEX): COMPLEX;
  (* Returns the complex exponential of z *)

@findex ln
PROCEDURE ln (z: COMPLEX): COMPLEX;
  (* Returns the principal value of the natural logarithm of z *)

@findex sin
PROCEDURE sin (z: COMPLEX): COMPLEX;
  (* Returns the sine of z *)

@findex cos
PROCEDURE cos (z: COMPLEX): COMPLEX;
  (* Returns the cosine of z *)

@findex tan
PROCEDURE tan (z: COMPLEX): COMPLEX;
  (* Returns the tangent of z *)

@findex arcsin
PROCEDURE arcsin (z: COMPLEX): COMPLEX;
  (* Returns the arcsine of z *)

@findex arccos
PROCEDURE arccos (z: COMPLEX): COMPLEX;
  (* Returns the arccosine of z *)

@findex arctan
PROCEDURE arctan (z: COMPLEX): COMPLEX;
  (* Returns the arctangent of z *)

@findex polarToComplex
PROCEDURE polarToComplex (abs, arg: REAL): COMPLEX;
  (* Returns the complex number with the specified polar coordinates *)

@findex scalarMult
PROCEDURE scalarMult (scalar: REAL; z: COMPLEX): COMPLEX;
  (* Returns the scalar product of scalar with z *)

@findex IsCMathException
PROCEDURE IsCMathException (): BOOLEAN;
  (* Returns TRUE if the current coroutine is in the exceptional execution state
     because of the raising of an exception in a routine from this module; otherwise
     returns FALSE.
  *)

END ComplexMath.

@end example
@page


@node gm2-iso/ConvTypes, gm2-iso/EXCEPTIONS, gm2-iso/ComplexMath, M2 ISO Libraries
@subsection gm2-iso/ConvTypes

@example
DEFINITION MODULE ConvTypes;

  (* Common types used in the string conversion modules *)

TYPE
  ConvResults =     (* Values of this type are used to express the format of a string *)
  (
    strAllRight,    (* the string format is correct for the corresponding conversion *)
    strOutOfRange,  (* the string is well-formed but the value cannot be represented *)
    strWrongFormat, (* the string is in the wrong format for the conversion *)
    strEmpty        (* the given string is empty *)
  );

  ScanClass =  (* Values of this type are used to classify input to finite state scanners *)
  (
    padding,   (* a leading or padding character at this point in the scan - ignore it *)
    valid,     (* a valid character at this point in the scan - accept it *)
    invalid,   (* an invalid character at this point in the scan - reject it *)
    terminator (* a terminating character at this point in the scan (not part of token) *)
  );

  ScanState =  (* The type of lexical scanning control procedures *)
    PROCEDURE (CHAR, VAR ScanClass, VAR ScanState);

END ConvTypes.

@end example
@page


@node gm2-iso/EXCEPTIONS, gm2-iso/GeneralUser, gm2-iso/ConvTypes, M2 ISO Libraries
@subsection gm2-iso/EXCEPTIONS

@example
DEFINITION MODULE EXCEPTIONS;

(* Provides facilities for raising user exceptions
   and for making enquiries concerning the current execution state.
*)

TYPE
  ExceptionSource;                (* values of this type are used within library modules to
                                     identify the source of raised exceptions
 *)
  ExceptionNumber = CARDINAL;

@findex AllocateSource
PROCEDURE AllocateSource(VAR newSource: ExceptionSource);
  (* Allocates a unique value of type ExceptionSource *)

@findex RAISE
PROCEDURE RAISE (source: ExceptionSource; number: ExceptionNumber; message: ARRAY OF CHAR);
  (* Associates the given values of source, number and message with the current context
     and raises an exception.
  *)

@findex CurrentNumber
PROCEDURE CurrentNumber (source: ExceptionSource): ExceptionNumber;
  (* If the current coroutine is in the exceptional execution state because of the raising
     of an exception from source, returns the corresponding number, and otherwise
     raises an exception.
  *)

@findex GetMessage
PROCEDURE GetMessage (VAR text: ARRAY OF CHAR);
  (* If the current coroutine is in the exceptional execution state, returns the possibly
     truncated string associated with the current context.
     Otherwise, in normal execution state, returns the empty string.
  *)

@findex IsCurrentSource
PROCEDURE IsCurrentSource (source: ExceptionSource): BOOLEAN;
  (* If the current coroutine is in the exceptional execution state because of the raising
     of an exception from source, returns TRUE, and otherwise returns FALSE.
  *)

@findex IsExceptionalExecution
PROCEDURE IsExceptionalExecution (): BOOLEAN;
  (* If the current coroutine is in the exceptional execution state because of the raising
     of an exception, returns TRUE, and otherwise returns FALSE.
  *)

END EXCEPTIONS.
@end example
@page


@node gm2-iso/GeneralUser, gm2-iso/IOChan, gm2-iso/EXCEPTIONS, M2 ISO Libraries
@subsection gm2-iso/GeneralUser

@example
DEFINITION MODULE GeneralUserExceptions;

(* Provides facilities for general user-defined exceptions *)

TYPE
  GeneralExceptions = (problem, disaster);

@findex RaiseGeneralException
PROCEDURE RaiseGeneralException (exception: GeneralExceptions; text: ARRAY OF CHAR);
  (* Raises exception using text as the associated message *)

@findex IsGeneralException
PROCEDURE IsGeneralException (): BOOLEAN;
  (* Returns TRUE if the current coroutine is in the exceptional execution state
     because of the raising of an exception from GeneralExceptions;
     otherwise returns FALSE.
  *)

@findex GeneralException
PROCEDURE GeneralException(): GeneralExceptions;
  (* If the current coroutine is in the exceptional execution state because of the
     raising of an exception from GeneralExceptions, returns the corresponding
     enumeration value, and otherwise raises an exception.
  *)

END GeneralUserExceptions.
@end example
@page


@node gm2-iso/IOChan, gm2-iso/IOConsts, gm2-iso/GeneralUser, M2 ISO Libraries
@subsection gm2-iso/IOChan

@example
DEFINITION MODULE IOChan;

  (* Types and procedures forming the interface to channels for
device-independent data
     transfer modules
  *)

IMPORT IOConsts, ChanConsts, SYSTEM;

TYPE
  ChanId; (* Values of this type are used to identify channels *)

  (* There is one pre-defined value identifying an invalid channel on which no data transfer
     operations are available.  It may be used to initialize variables of type ChanId.
  *)

@findex InvalidChan
PROCEDURE InvalidChan (): ChanId;
  (* Returns the value identifying the invalid channel. *)

  (* For each of the following operations, if the device supports the operation on the
     channel, the behaviour of the procedure conforms with the description below.  The full
     behaviour is defined for each device module.  If the device does not support the
     operation on the channel, the behaviour of the procedure is to raise the exception
     notAvailable.
  *)

  (* Text operations - these perform any required translation between the internal and
     external representation of text.
  *)

@findex Look
PROCEDURE Look (cid: ChanId; VAR ch: CHAR; VAR res: IOConsts.ReadResults);
  (* If there is a character as the next item in the input stream cid, assigns its value to
     ch without removing it from the stream; otherwise the value of ch is not defined.  res
     (and the stored read result) are set to the value allRight, endOfLine, or endOfInput.
  *)

@findex Skip
PROCEDURE Skip (cid: ChanId);
  (* If the input stream cid has ended, the exception skipAtEnd is raised; otherwise the
     next character or line mark in cid is removed, and the stored read result is set to the
     value allRight.
  *)

@findex SkipLook
PROCEDURE SkipLook (cid: ChanId; VAR ch: CHAR; VAR res: IOConsts.ReadResults);
  (* If the input stream cid has ended, the exception skipAtEnd is raised; otherwise the
     next character or line mark in cid is removed.  If there is a character as the next
     item in cid stream, assigns its value to ch without removing it from the stream.
     Otherwise, the value of ch is not defined.  res (and the stored read result) are set to
     the value allRight, endOfLine, or endOfInput.
  *)

@findex WriteLn
PROCEDURE WriteLn (cid: ChanId);
  (* Writes a line mark over the channel cid. *)

@findex TextRead
PROCEDURE TextRead (cid: ChanId; to: SYSTEM.ADDRESS; maxChars: CARDINAL;
                    VAR charsRead: CARDINAL);
  (* Reads at most maxChars characters from the current line in cid, and assigns
     corresponding values to successive components of an ARRAY OF CHAR variable for which
     the address of the first component is to. The number of characters read is assigned
     to charsRead. The stored read result is set to allRight, endOfLine, or endOfInput.
  *)

@findex TextWrite
PROCEDURE TextWrite (cid: ChanId; from: SYSTEM.ADDRESS; charsToWrite: CARDINAL);
  (* Writes a number of characters given by the value of charsToWrite, from successive
     components of an ARRAY OF CHAR variable for which the address of the first component
     is from, to the channel cid.
  *)

  (* Direct raw operations  - these do not effect translation between the internal and
     external representation of data
  *)

@findex RawRead
PROCEDURE RawRead (cid: ChanId; to: SYSTEM.ADDRESS; maxLocs: CARDINAL;
                   VAR locsRead: CARDINAL);
  (* Reads at most maxLocs items from cid, and assigns corresponding values to successive
     components of an ARRAY OF LOC variable for which the address of the first component
     is to. The number of characters read is assigned to charsRead. The stored read result
     is set to the value allRight, or endOfInput.
  *)

@findex RawWrite
PROCEDURE RawWrite (cid: ChanId; from: SYSTEM.ADDRESS; locsToWrite: CARDINAL);
  (* Writes a number of items given by the value of charsToWrite, from successive
     components of an ARRAY OF LOC variable for which the address of the first component
     is from, to the channel cid.
  *)

  (* Common operations *)

@findex GetName
PROCEDURE GetName (cid: ChanId; VAR s: ARRAY OF CHAR);
  (* Copies to s a name associated with the channel cid, possibly truncated
     (depending on the capacity of s).
  *)

@findex Reset
PROCEDURE Reset (cid: ChanId);
  (* Resets the channel cid to a state defined by the device module. *)

@findex Flush
PROCEDURE Flush (cid: ChanId);
  (* Flushes any data buffered by the device module out to the channel cid. *)

  (* Access to read results *)

@findex SetReadResult
PROCEDURE SetReadResult (cid: ChanId; res: IOConsts.ReadResults);
  (* Sets the read result value for the channel cid to the value res. *)

@findex ReadResult
PROCEDURE ReadResult (cid: ChanId): IOConsts.ReadResults;
  (* Returns the stored read result value for the channel cid. (This is initially the value
     notKnown).
  *)

  (* Users can discover which flags actually apply to a channel *)

@findex CurrentFlags
PROCEDURE CurrentFlags (cid: ChanId): ChanConsts.FlagSet;
  (* Returns the set of flags that currently apply to the channel cid. *)

  (* The following exceptions are defined for this module and its clients *)

TYPE
  ChanExceptions =
    (wrongDevice,      (* device specific operation on wrong device *)
     notAvailable,     (* operation attempted that is not available on that channel *)
     skipAtEnd,        (* attempt to skip data from a stream that has ended *)
     softDeviceError,  (* device specific recoverable error *)
     hardDeviceError,  (* device specific non-recoverable error *)
     textParseError,   (* input data does not correspond to a character or line mark -
                          optional detection *)
     notAChannel       (* given value does not identify a channel - optional detection *)
    );

@findex IsChanException
PROCEDURE IsChanException (): BOOLEAN;
  (* Returns TRUE if the current coroutine is in the exceptional execution state
     because of the raising of an exception from ChanExceptions;
     otherwise returns FALSE.
  *)

@findex ChanException
PROCEDURE ChanException (): ChanExceptions;
  (* If the current coroutine is in the exceptional execution state because of the
     raising of an exception from ChanExceptions, returns the corresponding
     enumeration value, and otherwise raises an exception.
  *)

  (* When a device procedure detects a device error, it raises the exception softDeviceError
     or hardDeviceError.  If these exceptions are handled, the following facilities may be
     used to discover an implementation-defined error number for the channel.
  *)

TYPE
  DeviceErrNum = INTEGER;

@findex DeviceError
PROCEDURE DeviceError (cid: ChanId): DeviceErrNum;
  (* If a device error exception has been raised for the channel cid, returns the error
     number stored by the device module.
  *)

END IOChan.

@end example
@page


@node gm2-iso/IOConsts, gm2-iso/IOLink, gm2-iso/IOChan, M2 ISO Libraries
@subsection gm2-iso/IOConsts

@example
DEFINITION MODULE IOConsts;

  (* Types and constants for input/output modules *)

TYPE
  ReadResults =  (* This type is used to classify the result of an input operation *)
  (
    notKnown,    (* no read result is set *)
    allRight,    (* data is as expected or as required *)
    outOfRange,  (* data cannot be represented *)
    wrongFormat, (* data not in expected format *)
    endOfLine,   (* end of line seen before expected data *)
    endOfInput   (* end of input seen before expected data *)
  );

END IOConsts.

@end example
@page


@node gm2-iso/IOLink, gm2-iso/IOResult, gm2-iso/IOConsts, M2 ISO Libraries
@subsection gm2-iso/IOLink

@example
DEFINITION MODULE IOLink;

  (* Types and procedures for the standard implementation of channels *)

IMPORT IOChan, IOConsts, ChanConsts, SYSTEM;

TYPE
  DeviceId;
    (* Values of this type are used to identify new device modules, and are normally
       obtained by them during their initialization.
    *)

@findex AllocateDeviceId
PROCEDURE AllocateDeviceId (VAR did: DeviceId);
  (* Allocates a unique value of type DeviceId, and assigns this value to did. *)

@findex MakeChan
PROCEDURE MakeChan (did: DeviceId; VAR cid: IOChan.ChanId);
  (* Attempts to make a new channel for the device module identified by did. If no more
     channels can be made, the identity of the invalid channel is assigned to cid.
     Otherwise, the identity of a new channel is assigned to cid.
  *)

@findex UnMakeChan
PROCEDURE UnMakeChan (did: DeviceId; VAR cid: IOChan.ChanId);
  (* If the device module identified by did is not the module that made the channel
     identified by cid, the exception wrongDevice is raised; otherwise the channel is
     deallocated, and the value identifying the invalid channel is assigned to cid.
  *)

TYPE
  DeviceTablePtr = POINTER TO DeviceTable;
    (* Values of this type are used to refer to device tables *)

TYPE
  LookProc =      PROCEDURE (DeviceTablePtr, VAR CHAR, VAR IOConsts.ReadResults);
  SkipProc =      PROCEDURE (DeviceTablePtr);
  SkipLookProc =  PROCEDURE (DeviceTablePtr, VAR CHAR, VAR IOConsts.ReadResults);
  WriteLnProc =   PROCEDURE (DeviceTablePtr);
  TextReadProc =  PROCEDURE (DeviceTablePtr, SYSTEM.ADDRESS, CARDINAL, VAR CARDINAL);
  TextWriteProc = PROCEDURE (DeviceTablePtr, SYSTEM.ADDRESS, CARDINAL);
  RawReadProc =   PROCEDURE (DeviceTablePtr, SYSTEM.ADDRESS, CARDINAL, VAR CARDINAL);
  RawWriteProc =  PROCEDURE (DeviceTablePtr, SYSTEM.ADDRESS, CARDINAL);
  GetNameProc =   PROCEDURE (DeviceTablePtr, VAR ARRAY OF CHAR);
  ResetProc =     PROCEDURE (DeviceTablePtr);
  FlushProc =     PROCEDURE (DeviceTablePtr);
  FreeProc =      PROCEDURE (DeviceTablePtr);
      (* Carry out the operations involved in closing the corresponding channel, including
         flushing buffers, but do not unmake the channel.
      *)

TYPE
  DeviceData = SYSTEM.ADDRESS;

  DeviceTable =
    RECORD                         (* Initialized by MakeChan to: *)
      cd: DeviceData;              (* the value NIL *)
      did: DeviceId;               (* the value given in the call of MakeChan *)
      cid: IOChan.ChanId;          (* the identity of the channel *)
      result: IOConsts.ReadResults;(* the value notKnown *)
      errNum: IOChan.DeviceErrNum; (* undefined *)
      flags: ChanConsts.FlagSet;   (* ChanConsts.FlagSet@{@} *)
      doLook: LookProc;            (* raise exception notAvailable *)
      doSkip: SkipProc;            (* raise exception notAvailable *)
      doSkipLook: SkipLookProc;    (* raise exception notAvailable *)
      doLnWrite: WriteLnProc;      (* raise exception notAvailable *)
      doTextRead: TextReadProc;    (* raise exception notAvailable *)
      doTextWrite: TextWriteProc;  (* raise exception notAvailable *)
      doRawRead: RawReadProc;      (* raise exception notAvailable *)
      doRawWrite: RawWriteProc;    (* raise exception notAvailable *)
      doGetName: GetNameProc;      (* return the empty string *)
      doReset: ResetProc;          (* do nothing *)
      doFlush: FlushProc;          (* do nothing *)
      doFree: FreeProc;            (* do nothing *)
    END;


  (* The pointer to the device table for a channel is obtained using the
     following procedure: *)

@findex DeviceTablePtrValue
PROCEDURE DeviceTablePtrValue (cid: IOChan.ChanId; did: DeviceId;
                               x: DevExceptionRange; s:  ARRAY OF CHAR): DeviceTablePtr;
  (* If the device module identified by did is not the module that made the channel
     identified by cid, the exception wrongDevice is raised; otherwise the given exception
     is raised, and the string value in s is included in the exception message.
  *)


@findex IsDevice
PROCEDURE IsDevice (cid: IOChan.ChanId; did: DeviceId) : BOOLEAN;
  (* Tests if the device module identified by did is the module that made the channel
     identified by cid.
  *)


TYPE
  DevExceptionRange = [IOChan.notAvailable ..  IOChan.textParseError];

@findex RAISEdevException
PROCEDURE RAISEdevException (cid: IOChan.ChanId; did: DeviceId;
                             x: DevExceptionRange; s: ARRAY OF CHAR);

  (* If the device module identified by did is not the module that made the channel
     identified by cid, the exception wrongDevice is raised; otherwise the given exception
     is raised, and the string value in s is included in the exception message.
  *)

@findex IsIOException
PROCEDURE IsIOException () : BOOLEAN;
  (* Returns TRUE if the current coroutine is in the exceptional execution state
     because of the raising af an exception from ChanExceptions;
     otherwise FALSE.
  *)

@findex IOException
PROCEDURE IOException () : IOChan.ChanExceptions;
  (* If the current coroutine is in the exceptional execution state because of the
     raising af an exception from ChanExceptions, returns the corresponding
     enumeration value, and otherwise raises an exception.
  *)

END IOLink.
@end example
@page


@node gm2-iso/IOResult, gm2-iso/LongComplex, gm2-iso/IOLink, M2 ISO Libraries
@subsection gm2-iso/IOResult

@example
DEFINITION MODULE IOResult;

  (* Read results for specified channels *)

IMPORT IOConsts, IOChan;

TYPE
  ReadResults = IOConsts.ReadResults;

  (*
    ReadResults =  (* This type is used to classify the result of an input operation *)
    (
      notKnown,    (* no read result is set *)
      allRight,    (* data is as expected or as required *)
      outOfRange,  (* data cannot be represented *)
      wrongFormat, (* data not in expected format *)
      endOfLine,   (* end of line seen before expected data *)
      endOfInput   (* end of input seen before expected data *)
    );
  *)

@findex ReadResult
PROCEDURE ReadResult (cid: IOChan.ChanId): ReadResults;
  (* Returns the result for the last read operation on the channel cid. *)

END IOResult.

@end example
@page


@node gm2-iso/LongComplex, gm2-iso/LongConv, gm2-iso/IOResult, M2 ISO Libraries
@subsection gm2-iso/LongComplex

@example
DEFINITION MODULE LongComplexMath;

  (* Mathematical functions for the type LONGCOMPLEX *)

CONST
  i =    CMPLX (0.0, 1.0);
  one =  CMPLX (1.0, 0.0);
  zero = CMPLX (0.0, 0.0);

@findex abs
PROCEDURE abs (z: LONGCOMPLEX): LONGREAL;
  (* Returns the length of z *)

@findex arg
PROCEDURE arg (z: LONGCOMPLEX): LONGREAL;
  (* Returns the angle that z subtends to the positive real axis *)

@findex conj
PROCEDURE conj (z: LONGCOMPLEX): LONGCOMPLEX;
  (* Returns the complex conjugate of z *)

@findex power
PROCEDURE power (base: LONGCOMPLEX; exponent: LONGREAL): LONGCOMPLEX;
  (* Returns the value of the number base raised to the power exponent *)

@findex sqrt
PROCEDURE sqrt (z: LONGCOMPLEX): LONGCOMPLEX;
  (* Returns the principal square root of z *)

@findex exp
PROCEDURE exp (z: LONGCOMPLEX): LONGCOMPLEX;
  (* Returns the complex exponential of z *)

@findex ln
PROCEDURE ln (z: LONGCOMPLEX): LONGCOMPLEX;
  (* Returns the principal value of the natural logarithm of z *)

@findex sin
PROCEDURE sin (z: LONGCOMPLEX): LONGCOMPLEX;
  (* Returns the sine of z *)

@findex cos
PROCEDURE cos (z: LONGCOMPLEX): LONGCOMPLEX;
  (* Returns the cosine of z *)

@findex tan
PROCEDURE tan (z: LONGCOMPLEX): LONGCOMPLEX;
  (* Returns the tangent of z *)

@findex arcsin
PROCEDURE arcsin (z: LONGCOMPLEX): LONGCOMPLEX;
  (* Returns the arcsine of z *)

@findex arccos
PROCEDURE arccos (z: LONGCOMPLEX): LONGCOMPLEX;
  (* Returns the arccosine of z *)

@findex arctan
PROCEDURE arctan (z: LONGCOMPLEX): LONGCOMPLEX;
  (* Returns the arctangent of z *)

@findex polarToComplex
PROCEDURE polarToComplex (abs, arg: LONGREAL): LONGCOMPLEX;
  (* Returns the complex number with the specified polar coordinates *)

@findex scalarMult
PROCEDURE scalarMult (scalar: LONGREAL; z: LONGCOMPLEX): LONGCOMPLEX;
  (* Returns the scalar product of scalar with z *)

@findex IsCMathException
PROCEDURE IsCMathException (): BOOLEAN;
  (* Returns TRUE if the current coroutine is in the exceptional execution state
     because of the raising of an exception in a routine from this module; otherwise
     returns FALSE.
  *)

END LongComplexMath.

@end example
@page


@node gm2-iso/LongConv, gm2-iso/LongIO, gm2-iso/LongComplex, M2 ISO Libraries
@subsection gm2-iso/LongConv

@example
DEFINITION MODULE LongConv;

  (* Low-level LONGREAL/string conversions *)

IMPORT
  ConvTypes;

TYPE
  ConvResults = ConvTypes.ConvResults; (* strAllRight, strOutOfRange, strWrongFormat, strEmpty *)

@findex ScanReal
PROCEDURE ScanReal (inputCh: CHAR; VAR chClass: ConvTypes.ScanClass;
                    VAR nextState: ConvTypes.ScanState);
  (* Represents the start state of a finite state scanner for real numbers - assigns
     class of inputCh to chClass and a procedure representing the next state to
     nextState.
  *)

@findex FormatReal
PROCEDURE FormatReal (str: ARRAY OF CHAR): ConvResults;
  (* Returns the format of the string value for conversion to LONGREAL. *)

@findex ValueReal
PROCEDURE ValueReal (str: ARRAY OF CHAR): LONGREAL;
  (* Returns the value corresponding to the real number string value str if str is
     well-formed; otherwise raises the LongConv exception.
  *)

@findex LengthFloatReal
PROCEDURE LengthFloatReal (real: LONGREAL; sigFigs: CARDINAL): CARDINAL;
  (* Returns the number of characters in the floating-point string representation of
     real with sigFigs significant figures.
  *)

@findex LengthEngReal
PROCEDURE LengthEngReal (real: LONGREAL; sigFigs: CARDINAL): CARDINAL;
  (* Returns the number of characters in the floating-point engineering string
     representation of real with sigFigs significant figures.
  *)

@findex LengthFixedReal
PROCEDURE LengthFixedReal (real: LONGREAL; place: INTEGER): CARDINAL;
  (* Returns the number of characters in the fixed-point string representation of real
     rounded to the given place relative to the decimal point.
  *)

@findex IsRConvException
PROCEDURE IsRConvException (): BOOLEAN;
  (* Returns TRUE if the current coroutine is in the exceptional execution state because
     of the raising of an exception in a routine from this module; otherwise returns
     FALSE.
  *)

END LongConv.

@end example
@page


@node gm2-iso/LongIO, gm2-iso/LongMath, gm2-iso/LongConv, M2 ISO Libraries
@subsection gm2-iso/LongIO

@example
DEFINITION MODULE LongIO;

  (* Input and output of long real numbers in decimal text form over specified channels.
     The read result is of the type IOConsts.ReadResults.
  *)

IMPORT IOChan;

  (* The text form of a signed fixed-point real number is
       ["+" | "-"], decimal digit, @{decimal digit@}, [".", @{decimal digit@}]

     The text form of a signed floating-point real number is
       signed fixed-point real number,
       "E", ["+" | "-"], decimal digit, @{decimal digit@}
  *)

@findex ReadReal
PROCEDURE ReadReal (cid: IOChan.ChanId; VAR real: LONGREAL);
  (* Skips leading spaces, and removes any remaining characters from cid that form part of a
     signed fixed or floating point number.  The value of this number is assigned to real.
     The read result is set to the value allRight, outOfRange, wrongFormat, endOfLine, or
     endOfInput.
  *)

@findex WriteFloat
PROCEDURE WriteFloat (cid: IOChan.ChanId; real: LONGREAL; sigFigs: CARDINAL; width: CARDINAL);
  (* Writes the value of real to cid in floating-point text form, with sigFigs significant
     figures, in a field of the given minimum width.
  *)

@findex WriteEng
PROCEDURE WriteEng (cid: IOChan.ChanId; real: LONGREAL; sigFigs: CARDINAL; width: CARDINAL);
  (* As for WriteFloat, except that the number is scaled with one to three digits in the
     whole number part, and with an exponent that is a multiple of three.
  *)

@findex WriteFixed
PROCEDURE WriteFixed (cid: IOChan.ChanId; real: LONGREAL; place: INTEGER; width: CARDINAL);
  (* Writes the value of real to cid in fixed-point text form, rounded to the given place
     relative to the decimal point, in a field of the given minimum width.
  *)

@findex WriteReal
PROCEDURE WriteReal (cid: IOChan.ChanId; real: LONGREAL; width: CARDINAL);
  (* Writes the value of real to cid, as WriteFixed if the sign and magnitude can be shown
     in the given width, or otherwise as WriteFloat.  The number of places or significant
     digits depends on the given width.
  *)

END LongIO.

@end example
@page


@node gm2-iso/LongMath, gm2-iso/LongStr, gm2-iso/LongIO, M2 ISO Libraries
@subsection gm2-iso/LongMath

@example
DEFINITION MODULE LongMath;

  (* Mathematical functions for the type LONGREAL *)

CONST
  pi   = 3.1415926535897932384626433832795028841972;
  exp1 = 2.7182818284590452353602874713526624977572;

@findex sqrt
PROCEDURE __BUILTIN__ sqrt (x: LONGREAL): LONGREAL;
  (* Returns the positive square root of x *)

@findex exp
PROCEDURE exp (x: LONGREAL): LONGREAL;
  (* Returns the exponential of x *)

@findex ln
PROCEDURE ln (x: LONGREAL): LONGREAL;
  (* Returns the natural logarithm of x *)

  (* The angle in all trigonometric functions is measured in radians *)

@findex sin
PROCEDURE __BUILTIN__ sin (x: LONGREAL): LONGREAL;
  (* Returns the sine of x *)

@findex cos
PROCEDURE __BUILTIN__ cos (x: LONGREAL): LONGREAL;
  (* Returns the cosine of x *)

@findex tan
PROCEDURE tan (x: LONGREAL): LONGREAL;
  (* Returns the tangent of x *)

@findex arcsin
PROCEDURE arcsin (x: LONGREAL): LONGREAL;
  (* Returns the arcsine of x *)

@findex arccos
PROCEDURE arccos (x: LONGREAL): LONGREAL;
  (* Returns the arccosine of x *)

@findex arctan
PROCEDURE arctan (x: LONGREAL): LONGREAL;
  (* Returns the arctangent of x *)

@findex power
PROCEDURE power (base, exponent: LONGREAL): LONGREAL;
  (* Returns the value of the number base raised to the power exponent *)

@findex round
PROCEDURE round (x: LONGREAL): INTEGER;
  (* Returns the value of x rounded to the nearest integer *)

@findex IsRMathException
PROCEDURE IsRMathException (): BOOLEAN;
  (* Returns TRUE if the current coroutine is in the exceptional execution state
     because of the raising of an exception in a routine from this module; otherwise
     returns FALSE.
  *)

END LongMath.

@end example
@page


@node gm2-iso/LongStr, gm2-iso/LowLong, gm2-iso/LongMath, M2 ISO Libraries
@subsection gm2-iso/LongStr

@example
DEFINITION MODULE LongStr;

  (* LONGREAL/string conversions *)

IMPORT
  ConvTypes;

TYPE
  ConvResults = ConvTypes.ConvResults; (* strAllRight, strOutOfRange, strWrongFormat, strEmpty *)

(* the string form of a signed fixed-point real number is
     ["+" | "-"], decimal digit, @{decimal digit@}, [".", @{decimal digit@}]
*)

(* the string form of a signed floating-point real number is
     signed fixed-point real number, "E", ["+" | "-"], decimal digit, @{decimal digit@}
*)

@findex StrToReal
PROCEDURE StrToReal (str: ARRAY OF CHAR; VAR real: LONGREAL; VAR res: ConvResults);
  (* Ignores any leading spaces in str. If the subsequent characters in str are in the
     format of a signed real number, assigns a corresponding value to real.
     Assigns a value indicating the format of str to res.
  *)

@findex RealToFloat
PROCEDURE RealToFloat (real: LONGREAL; sigFigs: CARDINAL; VAR str: ARRAY OF CHAR);
  (* Converts the value of real to floating-point string form, with sigFigs significant
     figures, and copies the possibly truncated result to str.
  *)

@findex RealToEng
PROCEDURE RealToEng (real: LONGREAL; sigFigs: CARDINAL; VAR str: ARRAY OF CHAR);
  (* Converts the value of real to floating-point string form, with sigFigs significant
     figures, and copies the possibly truncated result to str. The number is scaled with
     one to three digits in the whole number part and with an exponent that is a
     multiple of three.
  *)

@findex RealToFixed
PROCEDURE RealToFixed (real: LONGREAL; place: INTEGER; VAR str: ARRAY OF CHAR);
  (* Converts the value of real to fixed-point string form, rounded to the given place
     relative to the decimal point, and copies the possibly truncated result to str.
  *)

@findex RealToStr
PROCEDURE RealToStr (real: LONGREAL; VAR str: ARRAY OF CHAR);
  (* Converts the value of real as RealToFixed if the sign and magnitude can be shown
     within the capacity of str, or otherwise as RealToFloat, and copies the possibly
     truncated result to str. The number of places or significant digits depend on the
     capacity of str.
  *)

END LongStr.

@end example
@page


@node gm2-iso/LowLong, gm2-iso/LowReal, gm2-iso/LongStr, M2 ISO Libraries
@subsection gm2-iso/LowLong

@example
DEFINITION MODULE LowLong;

  (* Access to underlying properties of the type LONGREAL *)

CONST
  radix =      <implementation-defined whole number value>;
  places =     <implementation-defined whole number value>;
  expoMin =    <implementation-defined whole number value>;
  expoMax =    <implementation-defined whole number value>;
  large =      <implementation-defined real number value>;
  small =      <implementation-defined real number value>;
  IEEE =       <implementation-defined BOOLEAN value>;
  ISO =        <implementation-defined BOOLEAN value>;
  rounds =     <implementation-defined BOOLEAN value>;
  gUnderflow = <implementation-defined BOOLEAN value>;
  exception =  <implementation-defined BOOLEAN value>;
  extend =     <implementation-defined BOOLEAN value>;
  nModes =     <implementation-defined whole number value>;

TYPE
  Modes = PACKEDSET OF [0 .. nModes-1];

@findex exponent
PROCEDURE exponent (x: LONGREAL): INTEGER;
  (* Returns the exponent value of x *)

@findex fraction
PROCEDURE fraction (x: LONGREAL): LONGREAL;
  (* Returns the significand (or significant part) of x *)

@findex sign
PROCEDURE sign (x: LONGREAL): LONGREAL;
  (* Returns the signum of x *)

@findex succ
PROCEDURE succ (x: LONGREAL): LONGREAL;
  (* Returns the next value of the type LONGREAL greater than x *)

@findex ulp
PROCEDURE ulp (x: LONGREAL): LONGREAL;
  (* Returns the value of a unit in the last place of x *)

@findex pred
PROCEDURE pred (x: LONGREAL): LONGREAL;
  (* Returns the previous value of the type LONGREAL less than x *)

@findex intpart
PROCEDURE intpart (x: LONGREAL): LONGREAL;
  (* Returns the integer part of x *)

@findex fractpart
PROCEDURE fractpart (x: LONGREAL): LONGREAL;
  (* Returns the fractional part of x *)

@findex scale
PROCEDURE scale (x: LONGREAL; n: INTEGER): LONGREAL;
  (* Returns the value of x * radix ** n *)

@findex trunc
PROCEDURE trunc (x: LONGREAL; n: INTEGER): LONGREAL;
  (* Returns the value of the first n places of x *)

@findex round
PROCEDURE round (x: LONGREAL; n: INTEGER): LONGREAL;
  (* Returns the value of x rounded to the first n places *)

@findex synthesize
PROCEDURE synthesize (expart: INTEGER; frapart: LONGREAL): LONGREAL;
  (* Returns a value of the type LONGREAL constructed from the given expart and frapart *)

@findex setMode
PROCEDURE setMode (m: Modes);
  (* Sets status flags appropriate to the underlying implementation of the type LONGREAL *)

@findex currentMode
PROCEDURE currentMode (): Modes;
  (* Returns the current status flags in the form set by setMode *)

@findex IsLowException
PROCEDURE IsLowException (): BOOLEAN;
  (* Returns TRUE if the current coroutine is in the exceptional execution state
     because of the raising of an exception in a routine from this module; otherwise
     returns FALSE.
  *)

END LowLong.

@end example
@page


@node gm2-iso/LowReal, gm2-iso/M2EXCEPTION, gm2-iso/LowLong, M2 ISO Libraries
@subsection gm2-iso/LowReal

@example
DEFINITION MODULE LowReal;

  (* Access to underlying properties of the type REAL *)

CONST
  radix =      <implementation-defined whole number value>;
  places =     <implementation-defined whole number value>;
  expoMin =    <implementation-defined whole number value>;
  expoMax =    <implementation-defined whole number value>;
  large =      <implementation-defined real number value>;
  small =      <implementation-defined real number value>;
  IEEE =       <implementation-defined BOOLEAN value>;
  ISO =        <implementation-defined BOOLEAN value>;
  rounds =     <implementation-defined BOOLEAN value>;
  gUnderflow = <implementation-defined BOOLEAN value>;
  exception =  <implementation-defined BOOLEAN value>;
  extend =     <implementation-defined BOOLEAN value>;
  nModes =     <implementation-defined whole number value>;

TYPE
  Modes = SET OF [0 .. nModes-1];

@findex exponent
PROCEDURE exponent (x: REAL): INTEGER;
  (* Returns the exponent value of x *)

@findex fraction
PROCEDURE fraction (x: REAL): REAL;
  (* Returns the significand (or significant part) of x *)

@findex sign
PROCEDURE sign (x: REAL): REAL;
  (* Returns the signum of x *)

@findex succ
PROCEDURE succ (x: REAL): REAL;
  (* Returns the next value of the type REAL greater than x *)

@findex ulp
PROCEDURE ulp (x: REAL): REAL;
  (* Returns the value of a unit in the last place of x *)

@findex pred
PROCEDURE pred (x: REAL): REAL;
  (* Returns the previous value of the type REAL less than x *)

@findex intpart
PROCEDURE intpart (x: REAL): REAL;
  (* Returns the integer part of x *)

@findex fractpart
PROCEDURE fractpart (x: REAL): REAL;
  (* Returns the fractional part of x *)

@findex scale
PROCEDURE scale (x: REAL; n: INTEGER): REAL;
  (* Returns the value of x * radix ** n *)

@findex trunc
PROCEDURE trunc (x: REAL; n: INTEGER): REAL;
  (* Returns the value of the first n places of x *)

@findex round
PROCEDURE round (x: REAL; n: INTEGER): REAL;
  (* Returns the value of x rounded to the first n places *)

@findex synthesize
PROCEDURE synthesize (expart: INTEGER; frapart: REAL): REAL;
  (* Returns a value of the type REAL constructed from the given expart and frapart *)

@findex setMode
PROCEDURE setMode (m: Modes);
  (* Sets status flags appropriate to the underlying implementation of the type REAL *)

@findex currentMode
PROCEDURE currentMode (): Modes;
  (* Returns the current status flags in the form set by setMode *)

@findex IsLowException
PROCEDURE IsLowException (): BOOLEAN;
  (* Returns TRUE if the current coroutine is in the exceptional execution state
     because of the raising of an exception in a routine from this module; otherwise
     returns FALSE.
  *)

END LowReal.

@end example
@page


@node gm2-iso/M2EXCEPTION, gm2-iso/Processes, gm2-iso/LowReal, M2 ISO Libraries
@subsection gm2-iso/M2EXCEPTION

@example
DEFINITION MODULE M2EXCEPTION;

(* Provides facilities for identifying language exceptions *)

TYPE
  M2Exceptions =
    (indexException,     rangeException,         caseSelectException,  invalidLocation,
     functionException,  wholeValueException,    wholeDivException,    realValueException,
     realDivException,   complexValueException,  complexDivException,  protException,
     sysException,       coException,            exException
    );

@findex M2Exception
PROCEDURE M2Exception (): M2Exceptions;
  (* If the current coroutine is in the exceptional execution state because of the raising
     of a language exception, returns the corresponding enumeration value, and otherwise
     raises an exception.
  *)

@findex IsM2Exception
PROCEDURE IsM2Exception (): BOOLEAN;
  (* If the current coroutine is in the exceptional execution state because of the raising
     of a language exception, returns TRUE, and otherwise returns FALSE.
  *)

END M2EXCEPTION.
@end example
@page


@node gm2-iso/Processes, gm2-iso/ProgramArgs, gm2-iso/M2EXCEPTION, M2 ISO Libraries
@subsection gm2-iso/Processes

@example
DEFINITION MODULE Processes;

  (* This module allows concurrent algorithms to be expressed using processes. A process is
     a unit of a program that has the potential to run in parallel with other processes.
  *)

IMPORT SYSTEM;

TYPE
  ProcessId;                      (* Used to identify processes *)
  Parameter     = SYSTEM.ADDRESS; (* Used to pass data between processes *)
  Body          = PROC;           (* Used as the type of a process body *)
  Urgency       = INTEGER;        (* Used by the internal scheduler *)
  Sources       = CARDINAL;       (* Used to identify event sources *)
  ProcessesExceptions =           (* Exceptions raised by this module *)
    (passiveProgram, processError);

(* The following procedures create processes and switch control between them. *)

@findex Create
PROCEDURE Create (procBody: Body; extraSpace: CARDINAL; procUrg: Urgency;
                  procParams: Parameter; VAR procId: ProcessId);
  (* Creates a new process with procBody as its body, and with urgency and parameters
     given by procUrg and procParams.  At least as much workspace (in units of
     SYSTEM.LOC) as is specified by extraSpace is allocated to the process.
     An identity for the new process is returned in procId.
     The process is created in the passive state; it will not run until activated.
  *)

@findex Start
PROCEDURE Start (procBody: Body; extraSpace: CARDINAL; procUrg: Urgency;
                 procParams: Parameter; VAR procId: ProcessId);
  (* Creates a new process, with parameters as for Create.
     The process is created in the ready state; it is eligible to run immediately.
  *)

@findex StopMe
PROCEDURE StopMe ();
  (* Terminates the calling process.
     The process must not be associated with a source of events.
  *)

@findex SuspendMe
PROCEDURE SuspendMe ();
  (* Causes the calling process to enter the passive state.  The procedure only returns
     when the calling process is again activated by another process.
  *)

@findex Activate
PROCEDURE Activate (procId: ProcessId);
  (* Causes the process identified by procId to enter the ready state, and thus to become
     eligible to run again.
  *)

@findex SuspendMeAndActivate
PROCEDURE SuspendMeAndActivate (procId: ProcessId);
  (* Executes an atomic sequence of SuspendMe() and Activate(procId). *)

@findex Switch
PROCEDURE Switch (procId: ProcessId; VAR info: Parameter);
  (* Causes the calling process to enter the passive state; the process identified by procId
     becomes the currently executing process.
     info is used to pass parameter information from the calling to the activated process.
     On return, info will contain information from the process that chooses to switch back to
     this one (or will be NIL if Activate or SuspendMeAndActivate are used instead of
     Switch).
  *)

@findex Wait
PROCEDURE Wait ();
  (* Causes the calling process to enter the waiting state.  The procedure will return when
     the calling process is activated by another process, or when one of its associated
     eventSources has generated an event.
  *)

(* The following procedures allow the association of processes with sources of external
   events.
*)

@findex Attach
PROCEDURE Attach (eventSource: Sources);
  (* Associates the specified eventSource with the calling process. *)

@findex Detach
PROCEDURE Detach (eventSource: Sources);
  (* Dissociates the specified eventSource from the program. *)

@findex IsAttached
PROCEDURE IsAttached (eventSource: Sources): BOOLEAN;
  (* Returns TRUE if and only if the specified eventSource is currently associated with
     one of the processes of the program.
  *)

@findex Handler
PROCEDURE Handler (eventSource: Sources): ProcessId;
  (* Returns the identity of the process, if any, that is associated with the specified
     eventSource.
  *)

(* The following procedures allow processes to obtain their identity, parameters, and
   urgency.
*)

@findex Me
PROCEDURE Me (): ProcessId;
  (* Returns the identity of the calling process (as assigned when the process was first
     created).
  *)

@findex MyParam
PROCEDURE MyParam (): Parameter;
  (* Returns the value specified as procParams when the calling process was created. *)

@findex UrgencyOf
PROCEDURE UrgencyOf (procId: ProcessId): Urgency;
  (* Returns the urgency established when the process identified by procId was first
     created.
  *)

(* The following procedure provides facilities for exception handlers. *)

@findex ProcessesException
PROCEDURE ProcessesException (): ProcessesExceptions;
  (* If the current coroutine is in the exceptional execution state because of the raising
     of a language exception, returns the corresponding enumeration value, and
     otherwise raises an exception.
  *)

@findex IsProcessesException
PROCEDURE IsProcessesException (): BOOLEAN;
  (* Returns TRUE if the current coroutine is in the exceptional execution state
     because of the raising of an exception in a routine from this module; otherwise
     returns FALSE.
  *)

END Processes.

@end example
@page


@node gm2-iso/ProgramArgs, gm2-iso/RawIO, gm2-iso/Processes, M2 ISO Libraries
@subsection gm2-iso/ProgramArgs

@example
DEFINITION MODULE ProgramArgs;

  (* Access to program arguments *)

IMPORT IOChan;

TYPE
  ChanId = IOChan.ChanId;

@findex ArgChan
PROCEDURE ArgChan (): ChanId;
  (* Returns a value that identifies a channel for reading program arguments *)

@findex IsArgPresent
PROCEDURE IsArgPresent (): BOOLEAN;
  (* Tests if there is a current argument to read from. If not, read <=
     IOChan.CurrentFlags() will be FALSE, and attempting to read from the argument channel
     will raise the exception notAvailable.
  *)

@findex NextArg
PROCEDURE NextArg ();
  (* If there is another argument, causes subsequent input from the argument device to come
     from the start of the next argument.  Otherwise there is no argument to read from, and
     a call of IsArgPresent will return FALSE.
  *)

END ProgramArgs.
@end example
@page


@node gm2-iso/RawIO, gm2-iso/RealConv, gm2-iso/ProgramArgs, M2 ISO Libraries
@subsection gm2-iso/RawIO

@example
DEFINITION MODULE RawIO;

  (* Reading and writing data over specified channels using raw operations, that is, with no
     conversion or interpretation. The read result is of the type IOConsts.ReadResults.
  *)

IMPORT IOChan, SYSTEM;

@findex Read
PROCEDURE Read (cid: IOChan.ChanId; VAR to: ARRAY OF SYSTEM.LOC);
  (* Reads storage units from cid, and assigns them to successive components of to. The read
     result is set to the value allRight, wrongFormat, or endOfInput.
  *)

@findex Write
PROCEDURE Write (cid: IOChan.ChanId; from: ARRAY OF SYSTEM.LOC);
  (* Writes storage units to cid from successive components of from. *)

END RawIO.

@end example
@page


@node gm2-iso/RealConv, gm2-iso/RealIO, gm2-iso/RawIO, M2 ISO Libraries
@subsection gm2-iso/RealConv

@example
DEFINITION MODULE RealConv;

  (* Low-level REAL/string conversions *)

IMPORT
  ConvTypes;

TYPE
  ConvResults = ConvTypes.ConvResults; (* strAllRight, strOutOfRange, strWrongFormat, strEmpty *)

@findex ScanReal
PROCEDURE ScanReal (inputCh: CHAR; VAR chClass: ConvTypes.ScanClass;
                    VAR nextState: ConvTypes.ScanState);
  (* Represents the start state of a finite state scanner for real numbers - assigns
     class of inputCh to chClass and a procedure representing the next state to
     nextState.
   *)

@findex FormatReal
PROCEDURE FormatReal (str: ARRAY OF CHAR): ConvResults;
  (* Returns the format of the string value for conversion to REAL. *)

@findex ValueReal
PROCEDURE ValueReal (str: ARRAY OF CHAR): REAL;
  (* Returns the value corresponding to the real number string value str if str is
     well-formed; otherwise raises the RealConv exception.
  *)

@findex LengthFloatReal
PROCEDURE LengthFloatReal (real: REAL; sigFigs: CARDINAL): CARDINAL;
  (* Returns the number of characters in the floating-point string representation of
     real with sigFigs significant figures.
  *)

@findex LengthEngReal
PROCEDURE LengthEngReal (real: REAL; sigFigs: CARDINAL): CARDINAL;
  (* Returns the number of characters in the floating-point engineering string
     representation of real with sigFigs significant figures.
  *)

@findex LengthFixedReal
PROCEDURE LengthFixedReal (real: REAL; place: INTEGER): CARDINAL;
  (* Returns the number of characters in the fixed-point string representation of real
     rounded to the given place relative to the decimal point.
  *)

@findex IsRConvException
PROCEDURE IsRConvException (): BOOLEAN;
  (* Returns TRUE if the current coroutine is in the exceptional execution state because
     of the raising of an exception in a routine from this module; otherwise returns
     FALSE.
  *)

END RealConv.

@end example
@page


@node gm2-iso/RealIO, gm2-iso/RealMath, gm2-iso/RealConv, M2 ISO Libraries
@subsection gm2-iso/RealIO

@example
DEFINITION MODULE RealIO;

  (* Input and output of real numbers in decimal text form over specified channels.
     The read result is of the type IOConsts.ReadResults.
  *)

IMPORT IOChan;

  (* The text form of a signed fixed-point real number is
       ["+" | "-"], decimal digit, @{decimal digit@},
       [".", @{decimal digit@}]

     The text form of a signed floating-point real number is
       signed fixed-point real number,
       "E", ["+" | "-"], decimal digit, @{decimal digit@}
  *)

@findex ReadReal
PROCEDURE ReadReal (cid: IOChan.ChanId; VAR real: REAL);
  (* Skips leading spaces, and removes any remaining characters from cid that form part of a
     signed fixed or floating point number.  The value of this number is assigned to real.
     The read result is set to the value allRight, outOfRange, wrongFormat, endOfLine, or
     endOfInput.
  *)

@findex WriteFloat
PROCEDURE WriteFloat (cid: IOChan.ChanId; real: REAL; sigFigs: CARDINAL; width:
CARDINAL);
  (* Writes the value of real to cid in floating-point text form, with sigFigs significant
     figures, in a field of the given minimum width.
  *)

@findex WriteEng
PROCEDURE WriteEng (cid: IOChan.ChanId; real: REAL; sigFigs: CARDINAL; width: CARDINAL);
  (* As for WriteFloat, except that the number is scaled with one to three digits in the
     whole number part, and with an exponent that is a multiple of three.
  *)

@findex WriteFixed
PROCEDURE WriteFixed (cid: IOChan.ChanId; real: REAL; place: INTEGER; width: CARDINAL);
  (* Writes the value of real to cid in fixed-point text form, rounded to the given place
     relative to the decimal point, in a field of the given minimum width.
  *)

@findex WriteReal
PROCEDURE WriteReal (cid: IOChan.ChanId; real: REAL; width: CARDINAL);
  (* Writes the value of real to cid, as WriteFixed if the sign and magnitude can be shown
     in the given width, or otherwise as WriteFloat.  The number of places or significant
     digits depends on the given width.
  *)

END RealIO.
@end example
@page


@node gm2-iso/RealMath, gm2-iso/RealStr, gm2-iso/RealIO, M2 ISO Libraries
@subsection gm2-iso/RealMath

@example
DEFINITION MODULE RealMath;

  (* Mathematical functions for the type REAL *)

CONST
  pi   = 3.1415926535897932384626433832795028841972;
  exp1 = 2.7182818284590452353602874713526624977572;

@findex sqrt
PROCEDURE __BUILTIN__ sqrt (x: REAL): REAL;
  (* Returns the positive square root of x *)

@findex exp
PROCEDURE exp (x: REAL): REAL;
  (* Returns the exponential of x *)

@findex ln
PROCEDURE ln (x: REAL): REAL;
  (* Returns the natural logarithm of x *)

  (* The angle in all trigonometric functions is measured in radians *)

@findex sin
PROCEDURE __BUILTIN__ sin (x: REAL): REAL;
  (* Returns the sine of x *)

@findex cos
PROCEDURE __BUILTIN__ cos (x: REAL): REAL;
  (* Returns the cosine of x *)

@findex tan
PROCEDURE tan (x: REAL): REAL;
  (* Returns the tangent of x *)

@findex arcsin
PROCEDURE arcsin (x: REAL): REAL;
  (* Returns the arcsine of x *)

@findex arccos
PROCEDURE arccos (x: REAL): REAL;
  (* Returns the arccosine of x *)

@findex arctan
PROCEDURE arctan (x: REAL): REAL;
  (* Returns the arctangent of x *)

@findex power
PROCEDURE power (base, exponent: REAL): REAL;
  (* Returns the value of the number base raised to the power exponent *)

@findex round
PROCEDURE round (x: REAL): INTEGER;
  (* Returns the value of x rounded to the nearest integer *)

@findex IsRMathException
PROCEDURE IsRMathException (): BOOLEAN;
  (* Returns TRUE if the current coroutine is in the exceptional execution state
     because of the raising of an exception in a routine from this module; otherwise
     returns FALSE.
  *)

END RealMath.

@end example
@page


@node gm2-iso/RealStr, gm2-iso/RndFile, gm2-iso/RealMath, M2 ISO Libraries
@subsection gm2-iso/RealStr

@example
DEFINITION MODULE RealStr;

  (* REAL/string conversions *)

IMPORT
  ConvTypes;

TYPE
  ConvResults = ConvTypes.ConvResults; (* strAllRight, strOutOfRange, strWrongFormat, strEmpty *)

(* the string form of a signed fixed-point real number is
     ["+" | "-"], decimal digit, @{decimal digit@}, [".", @{decimal digit@}]
*)

(* the string form of a signed floating-point real number is
     signed fixed-point real number, "E", ["+" | "-"], decimal digit, @{decimal digit@}
*)

@findex StrToReal
PROCEDURE StrToReal (str: ARRAY OF CHAR; VAR real: REAL; VAR res: ConvResults);
  (* Ignores any leading spaces in str. If the subsequent characters in str are in the
     format of a signed real number, assigns a corresponding value to real.
     Assigns a value indicating the format of str to res.
  *)

@findex RealToFloat
PROCEDURE RealToFloat (real: REAL; sigFigs: CARDINAL; VAR str: ARRAY OF CHAR);
  (* Converts the value of real to floating-point string form, with sigFigs significant
     figures, and copies the possibly truncated result to str.
  *)

@findex RealToEng
PROCEDURE RealToEng (real: REAL; sigFigs: CARDINAL; VAR str: ARRAY OF CHAR);
  (* Converts the value of real to floating-point string form, with sigFigs significant
     figures, and copies the possibly truncated result to str. The number is scaled with
     one to three digits in the whole number part and with an exponent that is a
     multiple of three.
  *)

@findex RealToFixed
PROCEDURE RealToFixed (real: REAL; place: INTEGER; VAR str: ARRAY OF CHAR);
  (* Converts the value of real to fixed-point string form, rounded to the given place
     relative to the decimal point, and copies the possibly truncated result to str.
  *)

@findex RealToStr
PROCEDURE RealToStr (real: REAL; VAR str: ARRAY OF CHAR);
  (* Converts the value of real as RealToFixed if the sign and magnitude can be shown
     within the capacity of str, or otherwise as RealToFloat, and copies the possibly
     truncated result to str. The number of places or significant digits are
     implementation-defined.
  *)

END RealStr.

@end example
@page


@node gm2-iso/RndFile, gm2-iso/SIOResult, gm2-iso/RealStr, M2 ISO Libraries
@subsection gm2-iso/RndFile

@example
DEFINITION MODULE RndFile;

  (* Random access files *)

IMPORT IOChan, ChanConsts, SYSTEM;

TYPE
  ChanId = IOChan.ChanId;
  FlagSet = ChanConsts.FlagSet;
  OpenResults = ChanConsts.OpenResults;

  (* Accepted singleton values of FlagSet *)

CONST
  read = FlagSet@{ChanConsts.readFlag@};   (* input operations are requested/available *)
  write = FlagSet@{ChanConsts.writeFlag@}; (* output operations are requested/available *)
  old = FlagSet@{ChanConsts.oldFlag@};     (* a file may/must/did exist before the channel is
                                            opened *)
  text = FlagSet@{ChanConsts.textFlag@};   (* text operations are requested/available *)
  raw = FlagSet@{ChanConsts.rawFlag@};     (* raw operations are requested/available *)

@findex OpenOld
PROCEDURE OpenOld (VAR cid: ChanId; name: ARRAY OF CHAR; flags: FlagSet;
                   VAR res: OpenResults);
  (* Attempts to obtain and open a channel connected to a stored random access file of the
     given name.
     The old flag is implied; without the write flag, read is implied; without the text
     flag, raw is implied.
     If successful, assigns to cid the identity of the opened channel, assigns the value
     opened to res, and sets the read/write position to the start of the file.
     If a channel cannot be opened as required, the value of res indicates the reason, and
     cid identifies the invalid channel.
  *)

@findex OpenClean
PROCEDURE OpenClean (VAR cid: ChanId; name: ARRAY OF CHAR; flags: FlagSet;
                     VAR res: OpenResults);
  (* Attempts to obtain and open a channel connected to a stored random access file of the
     given name.
     The write flag is implied; without the text flag, raw is implied.
     If successful, assigns to cid the identity of the opened channel, assigns the value
     opened to res, and truncates the file to zero length.
     If a channel cannot be opened as required, the value of res indicates the reason, and
     cid identifies the invalid channel.
  *)

@findex IsRndFile
PROCEDURE IsRndFile (cid: ChanId): BOOLEAN;
  (* Tests if the channel identified by cid is open to a random access file. *)

@findex IsRndFileException
PROCEDURE IsRndFileException (): BOOLEAN;
  (* Returns TRUE if the current coroutine is in the exceptional execution state because
     of the raising of a RndFile exception; otherwise returns FALSE.
  *)

CONST
  FilePosSize = <implementation-defined whole number greater than zero>;

TYPE
  FilePos = ARRAY [1 .. FilePosSize] OF SYSTEM.LOC;

@findex StartPos
PROCEDURE StartPos (cid: ChanId): FilePos;
  (* If the channel identified by cid is not open to a random access file, the exception
     wrongDevice is raised; otherwise returns the position of the start of the file.
  *)

@findex CurrentPos
PROCEDURE CurrentPos (cid: ChanId): FilePos;
  (* If the channel identified by cid is not open to a random access file, the exception
     wrongDevice is raised; otherwise returns the position of the current read/write
     position.
  *)

@findex EndPos
PROCEDURE EndPos (cid: ChanId): FilePos;
  (* If the channel identified by cid is not open to a random access file, the exception
     wrongDevice is raised; otherwise returns the first position after which there have been
     no writes.
  *)

@findex NewPos
PROCEDURE NewPos (cid: ChanId; chunks: INTEGER; chunkSize: CARDINAL; from: FilePos): FilePos;
  (* If the channel identified by cid is not open to a random access file, the exception
     wrongDevice is raised; otherwise returns the position (chunks * chunkSize) relative to
     the position given by from, or raises the exception posRange if the required position
     cannot be represented as a value of type FilePos.
  *)

@findex SetPos
PROCEDURE SetPos (cid: ChanId; pos: FilePos);
  (* If the channel identified by cid is not open to a random access file, the exception
     wrongDevice is raised; otherwise sets the read/write position to the value given by
     pos.
  *)

@findex Close
PROCEDURE Close (VAR cid: ChanId);
  (* If the channel identified by cid is not open to a random access file, the exception
     wrongDevice is raised; otherwise closes the channel, and assigns the value identifying
     the invalid channel to cid.
  *)

END RndFile.

@end example
@page


@node gm2-iso/SIOResult, gm2-iso/SLongIO, gm2-iso/RndFile, M2 ISO Libraries
@subsection gm2-iso/SIOResult

@example
DEFINITION MODULE SIOResult;

  (* Read results for the default input channel *)

IMPORT IOConsts;

TYPE
  ReadResults = IOConsts.ReadResults;

  (*
    ReadResults =   (* This type is used to classify the result of an input operation *)
    (
      notKnown,     (* no read result is set *)
      allRight,     (* data is as expected or as required *)
      outOfRange,   (* data cannot be represented *)
      wrongFormat,  (* data not in expected format *)
      endOfLine,    (* end of line seen before expected data *)
      endOfInput    (* end of input seen before expected data *)
    );
  *)

@findex ReadResult
PROCEDURE ReadResult (): ReadResults;
  (* Returns the result for the last read operation on the default input channel. *)

END SIOResult.

@end example
@page


@node gm2-iso/SLongIO, gm2-iso/SRawIO, gm2-iso/SIOResult, M2 ISO Libraries
@subsection gm2-iso/SLongIO

@example
DEFINITION MODULE SLongIO;

  (* Input and output of long real numbers in decimal text form using default channels.  The
     read result is of the type IOConsts.ReadResults.
  *)

  (* The text form of a signed fixed-point real number is
       ["+" | "-"], decimal digit, @{decimal digit@},
       [".", @{decimal digit@}]

     The text form of a signed floating-point real number is
       signed fixed-point real number,
       "E", ["+" | "-"], decimal digit, @{decimal digit@}
  *)

@findex ReadReal
PROCEDURE ReadReal (VAR real: LONGREAL);
  (* Skips leading spaces, and removes any remaining characters from the default input
     channel that form part of a signed fixed or floating point number. The value of this
     number is assigned to real.  The read result is set to the value allRight, outOfRange,
     wrongFormat, endOfLine, or endOfInput.
  *)

@findex WriteFloat
PROCEDURE WriteFloat (real: LONGREAL; sigFigs: CARDINAL; width: CARDINAL);
  (* Writes the value of real to the default output channel in floating-point text form,
     with sigFigs significant figures, in a field of the given minimum width.
  *)

@findex WriteEng
PROCEDURE WriteEng (real: LONGREAL; sigFigs: CARDINAL; width: CARDINAL);
  (* As for WriteFloat, except that the number is scaled with one to three digits in the
     whole number part, and with an exponent that is a multiple of three.
  *)

@findex WriteFixed
PROCEDURE WriteFixed (real: LONGREAL; place: INTEGER; width: CARDINAL);
  (* Writes the value of real to the default output channel in fixed-point text form,
     rounded to the given place relative to the decimal point, in a field of the given
     minimum width.
  *)

@findex WriteReal
PROCEDURE WriteReal (real: LONGREAL; width: CARDINAL);
  (* Writes the value of real to the default output channel, as WriteFixed if the sign and
     magnitude can be shown in the given width, or otherwise as WriteFloat. The number of
     places or significant digits depends on the given width.
  *)

END SLongIO.

@end example
@page


@node gm2-iso/SRawIO, gm2-iso/SRealIO, gm2-iso/SLongIO, M2 ISO Libraries
@subsection gm2-iso/SRawIO

@example
DEFINITION MODULE SRawIO;

  (* Reading and writing data over default channels using raw operations, that is, with no
     conversion or interpretation. The read result is of the type IOConsts.ReadResults.
  *)

IMPORT SYSTEM;

@findex Read
PROCEDURE Read (VAR to: ARRAY OF SYSTEM.LOC);
  (* Reads storage units from the default input channel, and assigns them to successive
     components of to.  The read result is set to the value allRight, wrongFormat, or
     endOfInput.
  *)

@findex Write
PROCEDURE Write (from: ARRAY OF SYSTEM.LOC);
  (* Writes storage units to the default output channel from successive components of from.
  *)

END SRawIO.

@end example
@page


@node gm2-iso/SRealIO, gm2-iso/STextIO, gm2-iso/SRawIO, M2 ISO Libraries
@subsection gm2-iso/SRealIO

@example
DEFINITION MODULE SRealIO;

  (* Input and output of real numbers in decimal text form over default
     channels.  The read result is of the type IOConsts.ReadResults.
  *)

  (* The text form of a signed fixed-point real number is
       ["+" | "-"], decimal digit, @{decimal digit@},
       [".", @{decimal digit@}]

     The text form of a signed floating-point real number is
       signed fixed-point real number,
       "E", ["+" | "-"], decimal digit, @{decimal digit@}
  *)

@findex ReadReal
PROCEDURE ReadReal (VAR real: REAL);
  (* Skips leading spaces, and removes any remaining characters from the default input
     channel that form part of a signed fixed or floating point number. The value of this
     number is assigned to real.  The read result is set to the value allRight, outOfRange,
     wrongFormat, endOfLine, or endOfInput.
  *)

@findex WriteFloat
PROCEDURE WriteFloat (real: REAL; sigFigs: CARDINAL; width: CARDINAL);
  (* Writes the value of real to the default output channel in floating-point text form,
     with sigFigs significant figures, in a field of the given minimum width.
  *)

@findex WriteEng
PROCEDURE WriteEng (real: REAL; sigFigs: CARDINAL; width: CARDINAL);
  (* As for WriteFloat, except that the number is scaled with one to three digits in the
     whole number part, and with an exponent that is a multiple of three.
  *)

@findex WriteFixed
PROCEDURE WriteFixed (real: REAL; place: INTEGER; width: CARDINAL);
  (* Writes the value of real to the default output channel in fixed-point text form,
     rounded to the given place relative to the decimal point, in a field of the given
     minimum width.
  *)

@findex WriteReal
PROCEDURE WriteReal (real: REAL; width: CARDINAL);
  (* Writes the value of real to the default output channel, as WriteFixed if the sign and
     magnitude can be shown in the given width, or otherwise as WriteFloat. The number of
     places or significant digits depends on the given width.
  *)

END SRealIO.

@end example
@page


@node gm2-iso/STextIO, gm2-iso/SWholeIO, gm2-iso/SRealIO, M2 ISO Libraries
@subsection gm2-iso/STextIO

@example
DEFINITION MODULE STextIO;

  (* Input and output of character and string types over default channels. The read result
     is of the type IOConsts.ReadResults.
  *)

  (* The following procedures do not read past line marks *)

@findex ReadChar
PROCEDURE ReadChar (VAR ch: CHAR);
  (* If possible, removes a character from the default input stream, and assigns the
     corresponding value to ch.  The read result is set to allRight, endOfLine or
     endOfInput.
  *)

@findex ReadRestLine
PROCEDURE ReadRestLine (VAR s: ARRAY OF CHAR);
  (* Removes any remaining characters from the default input stream before the next line
     mark, copying to s as many as can be accommodated as a string value.  The read result
     is set to the value allRight, outOfRange, endOfLine, or endOfInput.
  *)

@findex ReadString
PROCEDURE ReadString (VAR s: ARRAY OF CHAR);
  (* Removes only those characters from the default input stream before the next line mark
     that can be accommodated in s as a string value, and copies them to s. The read result
     is set to the value allRight, endOfLine, or endOfInput.
  *)

@findex ReadToken
PROCEDURE ReadToken (VAR s: ARRAY OF CHAR);
  (* Skips leading spaces, and then removes characters from the default input stream before
     the next space or line mark, copying to s as many as can be accommodated as a string
     value.  The read result is set to the value allRight, outOfRange, endOfLine, or
     endOfInput.
  *)

  (* The following procedure reads past the next line mark *)

@findex SkipLine;
PROCEDURE SkipLine;
  (* Removes successive items from the default input stream up to and including the next
     line mark or until the end of input is reached. The read result is set to the value
     allRight, or endOfInput.
  *)


  (* Output procedures *)

@findex WriteChar
PROCEDURE WriteChar (ch: CHAR);
  (* Writes the value of ch to the default output stream. *)

@findex WriteLn;
PROCEDURE WriteLn;
  (* Writes a line mark to the default output stream. *)

@findex WriteString
PROCEDURE WriteString (s: ARRAY OF CHAR);
  (* Writes the string value of s to the default output stream. *)

END STextIO.

@end example
@page


@node gm2-iso/SWholeIO, gm2-iso/SYSTEM, gm2-iso/STextIO, M2 ISO Libraries
@subsection gm2-iso/SWholeIO

@example
DEFINITION MODULE SWholeIO;

  (* Input and output of whole numbers in decimal text form over default
     channels.  The read result is of the type IOConsts.ReadResults.
  *)

  (* The text form of a signed whole number is
       ["+" | "-"], decimal digit, @{decimal digit@}

     The text form of an unsigned whole number is
       decimal digit, @{decimal digit@}
  *)

@findex ReadInt
PROCEDURE ReadInt (VAR int: INTEGER);
  (* Skips leading spaces, and removes any remaining characters from the default input
     channel that form part of a signed whole number.  The value of this number is assigned
     to int.  The read result is set to the value allRight, outOfRange, wrongFormat,
     endOfLine, or endOfInput.
  *)

@findex WriteInt
PROCEDURE WriteInt (int: INTEGER; width: CARDINAL);
  (* Writes the value of int to the default output channel in text form, in a field of the
     given minimum width.
  *)

@findex ReadCard
PROCEDURE ReadCard (VAR card: CARDINAL);
  (* Skips leading spaces, and removes any remaining characters from the default input
     channel that form part of an unsigned whole number.  The value of this number is
     assigned to card.  The read result is set to the value allRight, outOfRange,
     wrongFormat, endOfLine, or endOfInput.
  *)

@findex WriteCard
PROCEDURE WriteCard (card: CARDINAL; width: CARDINAL);
  (* Writes the value of card to the default output channel in text form, in a field of the
     given minimum width.
  *)

END SWholeIO.
@end example
@page


@node gm2-iso/SYSTEM, gm2-iso/Semaphores, gm2-iso/SWholeIO, M2 ISO Libraries
@subsection gm2-iso/SYSTEM

@example
DEFINITION MODULE SYSTEM;

  (* Gives access to system programming facilities that are probably non portable. *)

  (* The constants and types define underlying properties of storage *)

EXPORT QUALIFIED BITSPERLOC, LOCSPERWORD,
                 LOC, BYTE, WORD, BITSET, ADDRESS,
                 ADDADR, SUBADR, DIFADR, MAKEADR, ADR, ROTATE, SHIFT, CAST, TSIZE ;

CONST
                  (* <implementation-defined constant> ; *)
  BITSPERLOC    = __ATTRIBUTE__ __BUILTIN__ ((BITS_PER_UNIT)) ;
                  (* <implementation-defined constant> ; *)
  LOCSPERWORD   = __ATTRIBUTE__ __BUILTIN__ ((UNITS_PER_WORD)) ;
                  (* <implementation-defined constant> ; *)
  LOCSPERBYTE = 8 DIV BITSPERLOC ;

(*
   all the objects below are declared internally to gm2
   ====================================================

TYPE
  LOC; (* A system basic type. Values are the uninterpreted contents of the smallest
          addressable unit of storage *)
  ADDRESS = POINTER TO LOC;
  WORD = ARRAY [0 .. LOCSPERWORD-1] OF LOC;

  (* BYTE and LOCSPERBYTE are provided if appropriate for machine *)

TYPE
  BYTE = ARRAY [0 .. LOCSPERBYTE-1] OF LOC;

@findex ADDADR
PROCEDURE ADDADR (addr: ADDRESS; offset: CARDINAL): ADDRESS;
  (* Returns address given by (addr + offset), or may raise an exception if this
     address is not valid.
  *)

@findex SUBADR
PROCEDURE SUBADR (addr: ADDRESS; offset: CARDINAL): ADDRESS;
  (* Returns address given by (addr - offset), or may raise an exception if this address
     is not valid.
  *)

@findex DIFADR
PROCEDURE DIFADR (addr1, addr2: ADDRESS): INTEGER;
  (* Returns the difference between addresses (addr1 - addr2), or may raise an exception
     if the arguments are invalid or address space is non-contiguous.
  *)

@findex MAKEADR
PROCEDURE MAKEADR (val: <some type>): ADDRESS;
  (* Returns an address constructed from a list of values whose types are
     implementation-defined, or may raise an exception if this address is not valid.

     In GNU Modula-2 val is promoted to a WORD and then CAST into an ADDRESS.
  *)

@findex ADR
PROCEDURE ADR (VAR v: <anytype>): ADDRESS;
  (* Returns the address of variable v. *)

@findex ROTATE
PROCEDURE ROTATE (val: <a packedset type>; num: INTEGER): <type of first parameter>;
  (* Returns a bit sequence obtained from val by rotating up or down (left or right) by
     the absolute value of num.  The direction is down if the sign of num is negative,
     otherwise the direction is up.
  *)

@findex SHIFT
PROCEDURE SHIFT (val: <a packedset type>; num: INTEGER): <type of first parameter>;
  (* Returns a bit sequence obtained from val by shifting up or down (left or right) by
     the absolute value of num, introducing zeros as necessary.  The direction is down
     if the sign of num is negative, otherwise the direction is up.
  *)

@findex CAST
PROCEDURE CAST (<targettype>; val: <anytype>): <targettype>;
  (* CAST is a type transfer function.  Given the expression denoted by val, it returns
     a value of the type <targettype>.  An invalid value for the target value or a
     physical address alignment problem may raise an exception.
  *)

@findex TSIZE
PROCEDURE TSIZE (<type>; ... ): CARDINAL;
  (* Returns the number of LOCS used to store a value of the specified <type>.   The
     extra parameters, if present, are used to distinguish variants in a variant record.
  *)
*)

END SYSTEM.
@end example
@page


@node gm2-iso/Semaphores, gm2-iso/SeqFile, gm2-iso/SYSTEM, M2 ISO Libraries
@subsection gm2-iso/Semaphores

@example
DEFINITION MODULE Semaphores;

  (* Provides mutual exclusion facilities for use by processes. *)

TYPE
  SEMAPHORE;

@findex Create
PROCEDURE Create (VAR s: SEMAPHORE; initialCount: CARDINAL );
  (* Creates and returns s as the identity of a new semaphore that has its associated count
     initialized to initialCount, and has no processes yet waiting on it.
  *)

@findex Destroy
PROCEDURE Destroy (VAR s: SEMAPHORE);
  (* Recovers the resources used to implement the semaphore s, provided that no process is
     waiting for s to become free.
  *)

@findex Claim
PROCEDURE Claim (s: SEMAPHORE);
  (* If the count associated with the semaphore s is non-zero, decrements this count and
     allows the calling process to continue; otherwise suspends the calling process until
     s is released.
  *)

@findex Release
PROCEDURE Release (s: SEMAPHORE);
  (* If there are any processes waiting on the semaphore s, allows one of them
     to enter the ready state; otherwise increments the count associated with s.
  *)

@findex CondClaim
PROCEDURE CondClaim (s: SEMAPHORE): BOOLEAN;
  (* Returns TRUE if the call Claim(s) would cause the calling process to be suspended;
     in this case the count associated with s is not changed. Otherwise returns TRUE and
     the associated count is decremented.
  *)

END Semaphores.

@end example
@page


@node gm2-iso/SeqFile, gm2-iso/StdChans, gm2-iso/Semaphores, M2 ISO Libraries
@subsection gm2-iso/SeqFile

@example
DEFINITION MODULE SeqFile;

  (* Rewindable sequential files *)

IMPORT IOChan, ChanConsts;

TYPE
  ChanId = IOChan.ChanId;
  FlagSet = ChanConsts.FlagSet;
  OpenResults = ChanConsts.OpenResults;

  (* Accepted singleton values of FlagSet *)

CONST
  read = FlagSet@{ChanConsts.readFlag@};   (* input operations are requested/available *)
  write = FlagSet@{ChanConsts.writeFlag@}; (* output operations are requested/available *)
  old = FlagSet@{ChanConsts.oldFlag@};     (* a file may/must/did exist before the channel is
                                            opened *)
  text = FlagSet@{ChanConsts.textFlag@};   (* text operations are requested/available *)
  raw = FlagSet@{ChanConsts.rawFlag@};     (* raw operations are requested/available *)

@findex OpenWrite
PROCEDURE OpenWrite (VAR cid: ChanId; name: ARRAY OF CHAR; flags: FlagSet;
                     VAR res: OpenResults);
  (* Attempts to obtain and open a channel connected to a stored rewindable file of the
     given name.
     The write flag is implied; without the raw flag, text is implied.
     If successful, assigns to cid the identity of the opened channel, assigns the value
     opened to res, and selects output mode, with the write position at the start of the
     file (i.e. the file is of zero length).
     If a channel cannot be opened as required, the value of res indicates the reason, and
     cid identifies the invalid channel.
  *)

@findex OpenAppend
PROCEDURE OpenAppend (VAR cid: ChanId; name: ARRAY OF CHAR; flags: FlagSet;
                      VAR res: OpenResults);
  (* Attempts to obtain and open a channel connected to a stored rewindable file of the
     given name.
     The write and old flags are implied; without the raw flag, text is implied.
     If successful, assigns to cid the identity of the opened channel, assigns the value
     opened to res, and selects output mode, with the write position corresponding to the
     length of the file.
     If a channel cannot be opened as required, the value of res indicates the reason, and
     cid identifies the invalid channel.
  *)

@findex OpenRead
PROCEDURE OpenRead (VAR cid: ChanId; name: ARRAY OF CHAR; flags: FlagSet;
                    VAR res: OpenResults);
  (* Attempts to obtain and open a channel connected to a stored rewindable file of the
     given name.
     The read and old flags are implied; without the raw flag, text is implied.
     If successful, assigns to cid the identity of the opened channel, assigns the value
     opened to res, and selects input mode, with the read position corresponding to the
     start of the file.
     If a channel cannot be opened as required, the value of res indicates the reason, and
     cid identifies the invalid channel.
  *)

@findex IsSeqFile
PROCEDURE IsSeqFile (cid: ChanId): BOOLEAN;
  (* Tests if the channel identified by cid is open to a rewindable sequential file. *)

@findex Reread
PROCEDURE Reread (cid: ChanId);
  (* If the channel identified by cid is not open to a rewindable sequential file, the
     exception wrongDevice is raised; otherwise attempts to set the read position to the
     start of the file, and to select input mode.
     If the operation cannot be performed (perhaps because of insufficient permissions)
     neither input mode nor output mode is selected.
  *)

@findex Rewrite
PROCEDURE Rewrite (cid: ChanId);
  (* If the channel identified by cid is not open to a rewindable sequential file, the
     exception wrongDevice is raised; otherwise, attempts to truncate the file to zero
     length, and to select output mode.
     If the operation cannot be performed (perhaps because of insufficient permissions)
     neither input mode nor output mode is selected.
  *)

@findex Close
PROCEDURE Close (VAR cid: ChanId);
  (* If the channel identified by cid is not open to a rewindable sequential file, the
     exception wrongDevice is raised; otherwise closes the channel, and assigns the value
     identifying the invalid channel to cid.
  *)

END SeqFile.

@end example
@page


@node gm2-iso/StdChans, gm2-iso/Storage, gm2-iso/SeqFile, M2 ISO Libraries
@subsection gm2-iso/StdChans

@example
DEFINITION MODULE StdChans;

  (* Access to standard and default channels *)

IMPORT IOChan;

TYPE
  ChanId = IOChan.ChanId;
    (* Values of this type are used to identify channels *)

  (* The following functions return the standard channel values.
     These channels cannot be closed.
  *)

@findex StdInChan
PROCEDURE StdInChan (): ChanId;
  (* Returns the identity of the implementation-defined standard source for
program
     input.
  *)

@findex StdOutChan
PROCEDURE StdOutChan (): ChanId;
  (* Returns the identity of the implementation-defined standard source for program
     output.
  *)

@findex StdErrChan
PROCEDURE StdErrChan (): ChanId;
  (* Returns the identity of the implementation-defined standard destination for program
     error messages.
  *)

@findex NullChan
PROCEDURE NullChan (): ChanId;
  (* Returns the identity of a channel open to the null device. *)

  (* The following functions return the default channel values *)

@findex InChan
PROCEDURE InChan (): ChanId;
  (* Returns the identity of the current default input channel. *)

@findex OutChan
PROCEDURE OutChan (): ChanId;
  (* Returns the identity of the current default output channel. *)

@findex ErrChan
PROCEDURE ErrChan (): ChanId;
  (* Returns the identity of the current default error message channel. *)

  (* The following procedures allow for redirection of the default channels *)

@findex SetInChan
PROCEDURE SetInChan (cid: ChanId);
  (* Sets the current default input channel to that identified by cid. *)

@findex SetOutChan
PROCEDURE SetOutChan (cid: ChanId);
  (* Sets the current default output channel to that identified by cid. *)

@findex SetErrChan
PROCEDURE SetErrChan (cid: ChanId);
  (* Sets the current default error channel to that identified by cid. *)

END StdChans.

@end example
@page


@node gm2-iso/Storage, gm2-iso/StreamFile, gm2-iso/StdChans, M2 ISO Libraries
@subsection gm2-iso/Storage

@example
DEFINITION MODULE Storage;

  (* Facilities for dynamically allocating and deallocating storage *)

IMPORT SYSTEM;

@findex ALLOCATE
PROCEDURE ALLOCATE (VAR addr: SYSTEM.ADDRESS; amount: CARDINAL);
  (* Allocates storage for a variable of size amount and assigns the address of this
     variable to addr. If there is insufficient unallocated storage to do this, the
     value NIL is assigned to addr.
  *)

@findex DEALLOCATE
PROCEDURE DEALLOCATE (VAR addr: SYSTEM.ADDRESS; amount: CARDINAL);
  (* Deallocates amount locations allocated by ALLOCATE for the storage of the variable
     addressed by addr and assigns the value NIL to addr.
  *)

TYPE
  StorageExceptions = (
    nilDeallocation,             (* first argument to DEALLOCATE is NIL *)
    pointerToUnallocatedStorage, (* storage to deallocate not allocated by ALLOCATE *)
    wrongStorageToUnallocate     (* amount to deallocate is not amount allocated *)
  );

@findex IsStorageException
PROCEDURE IsStorageException (): BOOLEAN;
  (* Returns TRUE if the current coroutine is in the exceptional execution state
     because of the raising of an exception from StorageExceptions;
     otherwise returns FALSE.
  *)

@findex StorageException
PROCEDURE StorageException (): StorageExceptions;
  (* If the current coroutine is in the exceptional execution state because of the
     raising of an exception from StorageExceptions, returns the corresponding
     enumeration value, and otherwise raises an exception.
  *)

END Storage.
@end example
@page


@node gm2-iso/StreamFile, gm2-iso/Strings, gm2-iso/Storage, M2 ISO Libraries
@subsection gm2-iso/StreamFile

@example
DEFINITION MODULE StreamFile;

  (* Independent sequential data streams *)

IMPORT IOChan, ChanConsts;

TYPE
  ChanId = IOChan.ChanId;
  FlagSet = ChanConsts.FlagSet;
  OpenResults = ChanConsts.OpenResults;

  (* Accepted singleton values of FlagSet *)

CONST
  read = FlagSet@{ChanConsts.readFlag@};   (* input operations are requested/available *)
  write = FlagSet@{ChanConsts.writeFlag@}; (* output operations are requested/available *)
  old = FlagSet@{ChanConsts.oldFlag@};     (* a file may/must/did exist before the channel is
                                            opened *)
  text = FlagSet@{ChanConsts.textFlag@};   (* text operations are requested/available *)
  raw = FlagSet@{ChanConsts.rawFlag@};     (* raw operations are requested/available *)


@findex Open
PROCEDURE Open (VAR cid: ChanId; name: ARRAY OF CHAR; flags: FlagSet; VAR res: OpenResults);
  (* Attempts to obtain and open a channel connected to a sequential stream of the given
     name.
     The read flag implies old; without the raw flag, text is implied.
     If successful, assigns to cid the identity of the opened channel, and assigns the value
     opened to res.
     If a channel cannot be opened as required, the value of res indicates the reason, and
     cid identifies the invalid channel.
  *)

@findex IsStreamFile
PROCEDURE IsStreamFile (cid: ChanId): BOOLEAN;
  (* Tests if the channel identified by cid is open to a sequential stream. *)

@findex Close
PROCEDURE Close (VAR cid: ChanId);
  (* If the channel identified by cid is not open to a sequential stream, the exception
     wrongDevice is raised; otherwise closes the channel, and assigns the value identifying
     the invalid channel to cid.
  *)

END StreamFile.

@end example
@page


@node gm2-iso/Strings, gm2-iso/SysClock, gm2-iso/StreamFile, M2 ISO Libraries
@subsection gm2-iso/Strings

@example
DEFINITION MODULE Strings;

  (* Facilities for manipulating strings *)

TYPE
  String1 = ARRAY [0..0] OF CHAR;
    (* String1 is provided for constructing a value of a single-character string type from a
       single character value in order to pass CHAR values to ARRAY OF CHAR parameters.
    *)

@findex Length
PROCEDURE Length (stringVal: ARRAY OF CHAR): CARDINAL;
  (* Returns the length of stringVal (the same value as would be returned by the
     pervasive function LENGTH).
  *)


(* The following seven procedures construct a string value, and attempt to assign it to a
   variable parameter.  They all have the property that if the length of the constructed string
   value exceeds the capacity of the variable parameter, a truncated value is assigned, while
   if the length of the constructed string value is less than the capacity of the variable
   parameter, a string terminator is appended before assignment is performed.
*)

@findex Assign
PROCEDURE Assign (source: ARRAY OF CHAR; VAR destination: ARRAY OF CHAR);
  (* Copies source to destination *)

@findex Extract
PROCEDURE Extract (source: ARRAY OF CHAR; startIndex, numberToExtract: CARDINAL;
                   VAR destination: ARRAY OF CHAR);
  (* Copies at most numberToExtract characters from source to destination, starting at position
     startIndex in source.
  *)

@findex Delete
PROCEDURE Delete (VAR stringVar: ARRAY OF CHAR; startIndex, numberToDelete:
CARDINAL);
  (* Deletes at most numberToDelete characters from stringVar, starting at position
     startIndex.
  *)

@findex Insert
PROCEDURE Insert (source: ARRAY OF CHAR; startIndex: CARDINAL;
                  VAR destination: ARRAY OF CHAR);
  (* Inserts source into destination at position startIndex *)

@findex Replace
PROCEDURE Replace (source: ARRAY OF CHAR; startIndex: CARDINAL;
                   VAR destination: ARRAY OF CHAR);
  (* Copies source into destination, starting at position startIndex. Copying stops when
     all of source has been copied, or when the last character of the string value in
     destination has been replaced.
  *)

@findex Append
PROCEDURE Append (source: ARRAY OF CHAR; VAR destination: ARRAY OF CHAR);
  (* Appends source to destination. *)

@findex Concat
PROCEDURE Concat (source1, source2: ARRAY OF CHAR; VAR destination: ARRAY OF CHAR);
  (* Concatenates source2 onto source1 and copies the result into destination. *)

(* The following predicates provide for pre-testing of the operation-completion
   conditions for the procedures above.
*)

@findex CanAssignAll
PROCEDURE CanAssignAll (sourceLength: CARDINAL; VAR destination: ARRAY OF CHAR): BOOLEAN;
  (* Returns TRUE if a number of characters, indicated by sourceLength, will fit into
     destination; otherwise returns FALSE.
  *)

@findex CanExtractAll
PROCEDURE CanExtractAll (sourceLength, startIndex, numberToExtract: CARDINAL;
                         VAR destination: ARRAY OF CHAR): BOOLEAN;
  (* Returns TRUE if there are numberToExtract characters starting at startIndex and
     within the sourceLength of some string, and if the capacity of destination is
     sufficient to hold numberToExtract characters; otherwise returns FALSE.
  *)

@findex CanDeleteAll
PROCEDURE CanDeleteAll (stringLength, startIndex, numberToDelete: CARDINAL): BOOLEAN;
  (* Returns TRUE if there are numberToDelete characters starting at startIndex and
     within the stringLength of some string; otherwise returns FALSE.
  *)

@findex CanInsertAll
PROCEDURE CanInsertAll (sourceLength, startIndex: CARDINAL;
                        VAR destination: ARRAY OF CHAR): BOOLEAN;
  (* Returns TRUE if there is room for the insertion of sourceLength characters from
     some string into destination starting at startIndex; otherwise returns FALSE.
  *)

@findex CanReplaceAll
PROCEDURE CanReplaceAll (sourceLength, startIndex: CARDINAL;
                         VAR destination: ARRAY OF CHAR): BOOLEAN;
  (* Returns TRUE if there is room for the replacement of sourceLength characters in
     destination starting at startIndex; otherwise returns FALSE.
  *)

@findex CanAppendAll
PROCEDURE CanAppendAll (sourceLength: CARDINAL; VAR destination: ARRAY OF CHAR): BOOLEAN;
  (* Returns TRUE if there is sufficient room in destination to append a string of
     length sourceLength to the string in destination; otherwise returns FALSE.
  *)

@findex CanConcatAll
PROCEDURE CanConcatAll (source1Length, source2Length: CARDINAL;
                        VAR destination: ARRAY OF CHAR): BOOLEAN;
  (* Returns TRUE if there is sufficient room in destination for a two strings of
     lengths source1Length and source2Length; otherwise returns FALSE.
  *)

(* The following type and procedures provide for the comparison of string values, and for the
   location of substrings within strings.
*)

TYPE
  CompareResults = (less, equal, greater);

@findex Compare
PROCEDURE Compare (stringVal1, stringVal2: ARRAY OF CHAR): CompareResults;
  (* Returns less, equal, or greater, according as stringVal1 is lexically less than,
     equal to, or greater than stringVal2.
  *)

@findex Equal
PROCEDURE Equal (stringVal1, stringVal2: ARRAY OF CHAR): BOOLEAN;
  (* Returns Strings.Compare(stringVal1, stringVal2) = Strings.equal *)

@findex FindNext
PROCEDURE FindNext (pattern, stringToSearch: ARRAY OF CHAR; startIndex: CARDINAL;
                    VAR patternFound: BOOLEAN; VAR posOfPattern: CARDINAL);
  (* Looks forward for next occurrence of pattern in stringToSearch, starting the search at
     position startIndex. If startIndex < LENGTH(stringToSearch) and pattern is found,
     patternFound is returned as TRUE, and posOfPattern contains the start position in
     stringToSearch of pattern. Otherwise patternFound is returned as FALSE, and posOfPattern
     is unchanged.
  *)

@findex FindPrev
PROCEDURE FindPrev (pattern, stringToSearch: ARRAY OF CHAR; startIndex: CARDINAL;
                    VAR patternFound: BOOLEAN; VAR posOfPattern: CARDINAL);
  (* Looks backward for the previous occurrence of pattern in stringToSearch and returns the
     position of the first character of the pattern if found. The search for the pattern
     begins at startIndex. If pattern is found, patternFound is returned as TRUE, and
     posOfPattern contains the start position in stringToSearch of pattern in the range
     [0..startIndex]. Otherwise patternFound is returned as FALSE, and posOfPattern is unchanged.
  *)

@findex FindDiff
PROCEDURE FindDiff (stringVal1, stringVal2: ARRAY OF CHAR;
                    VAR differenceFound: BOOLEAN; VAR posOfDifference: CARDINAL);
  (* Compares the string values in stringVal1 and stringVal2 for differences. If they
     are equal, differenceFound is returned as FALSE, and TRUE otherwise. If
     differenceFound is TRUE, posOfDifference is set to the position of the first
     difference; otherwise posOfDifference is unchanged.
  *)

@findex Capitalize
PROCEDURE Capitalize (VAR stringVar: ARRAY OF CHAR);
  (* Applies the function CAP to each character of the string value in stringVar. *)

END Strings.

@end example
@page


@node gm2-iso/SysClock, gm2-iso/TERMINATION, gm2-iso/Strings, M2 ISO Libraries
@subsection gm2-iso/SysClock

@example
DEFINITION MODULE SysClock;

(* Facilities for accessing a system clock that records the date and time of day *)

CONST
  maxSecondParts = <implementation-defined integral value>;

TYPE
  Month    = [1 .. 12];
  Day      = [1 .. 31];
  Hour     = [0 .. 23];
  Min      = [0 .. 59];
  Sec      = [0 .. 59];
  Fraction = [0 .. maxSecondParts];
  UTCDiff  = [-780 .. 720];
  DateTime =
    RECORD
      year:      CARDINAL;
      month:     Month;
      day:       Day;
      hour:      Hour;
      minute:    Min;
      second:    Sec;
      fractions: Fraction;      (* parts of a second *)
      zone:      UTCDiff;       (* Time zone differential factor which is the number
                                   of minutes to add to local time to obtain UTC. *)
      summerTimeFlag: BOOLEAN;  (* Interpretation of flag depends on local usage. *)
    END;

@findex CanGetClock
PROCEDURE CanGetClock(): BOOLEAN;
(* Tests if the clock can be read *)

@findex CanSetClock
PROCEDURE CanSetClock(): BOOLEAN;
(* Tests if the clock can be set *)

@findex IsValidDateTime
PROCEDURE IsValidDateTime(userData: DateTime): BOOLEAN;
(* Tests if the value of userData is a valid *)

@findex GetClock
PROCEDURE GetClock(VAR userData: DateTime);
(* Assigns local date and time of the day to userData *)

@findex SetClock
PROCEDURE SetClock(userData: DateTime): BOOLEAN;
(* Sets the system time clock to the given local date and time *)

END SysClock.
@end example
@page


@node gm2-iso/TERMINATION, gm2-iso/TermFile, gm2-iso/SysClock, M2 ISO Libraries
@subsection gm2-iso/TERMINATION

@example
DEFINITION MODULE TERMINATION;

(* Provides facilities for enquiries concerning the occurrence of termination events. *)

@findex IsTerminating
PROCEDURE IsTerminating (): BOOLEAN ;
  (* Returns true if any coroutine has started  program termination and false otherwise. *)

@findex HasHalted
PROCEDURE HasHalted (): BOOLEAN ;
  (* Returns true if a call to HALT has been made and false otherwise. *)

END TERMINATION.
@end example
@page


@node gm2-iso/TermFile, gm2-iso/TextIO, gm2-iso/TERMINATION, M2 ISO Libraries
@subsection gm2-iso/TermFile

@example
DEFINITION MODULE TermFile;

  (* Access to the terminal device *)

  (* Channels opened by this module are connected to a single terminal device; typed
     characters are distributed between channels according to the sequence of read requests.
  *)

IMPORT IOChan, ChanConsts;

TYPE
  ChanId = IOChan.ChanId;
  FlagSet = ChanConsts.FlagSet;
  OpenResults = ChanConsts.OpenResults;

  (* Accepted singleton values of FlagSet *)

CONST
  read = FlagSet@{ChanConsts.readFlag@};   (* input operations are requested/available *)
  write = FlagSet@{ChanConsts.writeFlag@}; (* output operations are requested/available *)
  text = FlagSet@{ChanConsts.textFlag@};   (* text operations are requested/available *)
  raw = FlagSet@{ChanConsts.rawFlag@};     (* raw operations are requested/available *)
  echo = FlagSet@{ChanConsts.echoFlag@};   (* echoing by interactive device on reading of
                                            characters from input stream requested/applies
                                         *)

@findex Open
PROCEDURE Open (VAR cid: ChanId; flags: FlagSet; VAR res: OpenResults);
  (* Attempts to obtain and open a channel connected to the terminal.
     Without the raw flag, text is implied.
     Without the echo flag, line mode is requested, otherwise single character mode is
     requested.
     If successful, assigns to cid the identity of the opened channel, and assigns the value
     opened to res.
     If a channel cannot be opened as required, the value of res indicates the reason, and
     cid identifies the invalid channel.
  *)

@findex IsTermFile
PROCEDURE IsTermFile (cid: ChanId): BOOLEAN;
  (* Tests if the channel identified by cid is open to the terminal. *)

@findex Close
PROCEDURE Close (VAR cid: ChanId);
  (* If the channel identified by cid is not open to the terminal, the exception wrongDevice
     is raised; otherwise closes the channel and assigns the value identifying the invalid
     channel to cid.
  *)

END TermFile.

@end example
@page


@node gm2-iso/TextIO, gm2-iso/WholeConv, gm2-iso/TermFile, M2 ISO Libraries
@subsection gm2-iso/TextIO

@example
DEFINITION MODULE TextIO;

  (* Input and output of character and string types over specified channels.
     The read result is of the type IOConsts.ReadResults.
  *)

IMPORT IOChan;

  (* The following procedures do not read past line marks *)

@findex ReadChar
PROCEDURE ReadChar (cid: IOChan.ChanId; VAR ch: CHAR);
  (* If possible, removes a character from the input stream cid and assigns the
     corresponding value to ch.  The read result is set to the value allRight, endOfLine, or
     endOfInput.
  *)

@findex ReadRestLine
PROCEDURE ReadRestLine (cid: IOChan.ChanId; VAR s: ARRAY OF CHAR);
  (* Removes any remaining characters from the input stream cid before the next line mark,
     copying to s as many as can be accommodated as a string value. The read result is set
     to the value allRight, outOfRange, endOfLine, or endOfInput.
  *)

@findex ReadString
PROCEDURE ReadString (cid: IOChan.ChanId; VAR s: ARRAY OF CHAR);
  (* Removes only those characters from the input stream cid before the next line mark that
     can be accommodated in s as a string value, and copies them to s.  The read result is
     set to the value allRight, endOfLine, or endOfInput.
  *)

@findex ReadToken
PROCEDURE ReadToken (cid: IOChan.ChanId; VAR s: ARRAY OF CHAR);
  (* Skips leading spaces, and then removes characters from the input stream cid before the
     next space or line mark, copying to s as many as can be accommodated as a string value.
     The read result is set to the value allRight, outOfRange, endOfLine, or endOfInput.
  *)

  (* The following procedure reads past the next line mark *)

@findex SkipLine
PROCEDURE SkipLine (cid: IOChan.ChanId);
  (* Removes successive items from the input stream cid up to and including the next line
     mark, or until the end of input is reached.  The read result is set to the value
     allRight, or endOfInput.
  *)

  (* Output procedures *)

@findex WriteChar
PROCEDURE WriteChar (cid: IOChan.ChanId; ch: CHAR);
  (* Writes the value of ch to the output stream cid. *)

@findex WriteLn
PROCEDURE WriteLn (cid: IOChan.ChanId);
  (* Writes a line mark to the output stream cid. *)

@findex WriteString
PROCEDURE WriteString (cid: IOChan.ChanId; s: ARRAY OF CHAR);
  (* Writes the string value in s to the output stream cid. *)

END TextIO.

@end example
@page


@node gm2-iso/WholeConv, gm2-iso/WholeIO, gm2-iso/TextIO, M2 ISO Libraries
@subsection gm2-iso/WholeConv

@example
DEFINITION MODULE WholeConv;

  (* Low-level whole-number/string conversions *)

IMPORT
  ConvTypes;

TYPE
  ConvResults = ConvTypes.ConvResults; (* strAllRight, strOutOfRange, strWrongFormat, strEmpty *)

@findex ScanInt
PROCEDURE ScanInt (inputCh: CHAR; VAR chClass: ConvTypes.ScanClass;
                   VAR nextState: ConvTypes.ScanState);
  (* Represents the start state of a finite state scanner for signed whole numbers -
     assigns class of inputCh to chClass and a procedure representing the next state to
     nextState.
  *)

@findex FormatInt
PROCEDURE FormatInt (str: ARRAY OF CHAR): ConvResults;
  (* Returns the format of the string value for conversion to INTEGER. *)

@findex ValueInt
PROCEDURE ValueInt (str: ARRAY OF CHAR): INTEGER;
  (* Returns the value corresponding to the signed whole number string value str if str
     is well-formed; otherwise raises the WholeConv exception.
  *)

@findex LengthInt
PROCEDURE LengthInt (int: INTEGER): CARDINAL;
  (* Returns the number of characters in the string representation of int. *)

@findex ScanCard
PROCEDURE ScanCard (inputCh: CHAR; VAR chClass: ConvTypes.ScanClass;
                    VAR nextState: ConvTypes.ScanState);
  (* Represents the start state of a finite state scanner for unsigned whole numbers -
     assigns class of inputCh to chClass and a procedure representing the next state to
     nextState.
  *)

@findex FormatCard
PROCEDURE FormatCard (str: ARRAY OF CHAR): ConvResults;
  (* Returns the format of the string value for conversion to CARDINAL. *)

@findex ValueCard
PROCEDURE ValueCard (str: ARRAY OF CHAR): CARDINAL;
  (* Returns the value corresponding to the unsigned whole number string value str if
     str is well-formed; otherwise raises the WholeConv exception.
   *)

@findex LengthCard
PROCEDURE LengthCard (card: CARDINAL): CARDINAL;
  (* Returns the number of characters in the string representation of card. *)

@findex IsWholeConvException
PROCEDURE IsWholeConvException (): BOOLEAN;
  (* Returns TRUE if the current coroutine is in the exceptional execution state because
     of the raising of an exception in a routine from this module; otherwise returns
     FALSE.
  *)

END WholeConv.

@end example
@page


@node gm2-iso/WholeIO, gm2-iso/WholeStr, gm2-iso/WholeConv, M2 ISO Libraries
@subsection gm2-iso/WholeIO

@example
DEFINITION MODULE WholeIO;

  (* Input and output of whole numbers in decimal text form over specified channels.
     The read result is of the type IOConsts.ReadResults.
  *)

IMPORT IOChan;

  (* The text form of a signed whole number is
       ["+" | "-"], decimal digit, @{decimal digit@}

     The text form of an unsigned whole number is
       decimal digit, @{decimal digit@}
  *)

@findex ReadInt
PROCEDURE ReadInt (cid: IOChan.ChanId; VAR int: INTEGER);
  (* Skips leading spaces, and removes any remaining characters from cid that form part of a
     signed whole number.  The value of this number is assigned to int.  The read result is
     set to the value allRight, outOfRange, wrongFormat, endOfLine, or endOfInput.
  *)

@findex WriteInt
PROCEDURE WriteInt (cid: IOChan.ChanId; int: INTEGER; width: CARDINAL);
  (* Writes the value of int to cid in text form, in a field of the given minimum width. *)

@findex ReadCard
PROCEDURE ReadCard (cid: IOChan.ChanId; VAR card: CARDINAL);
  (* Skips leading spaces, and removes any remaining characters from cid that form part of
     an unsigned whole number.  The value of this number is assigned to card. The read
     result is set to the value allRight, outOfRange, wrongFormat, endOfLine, or endOfInput.
  *)

@findex WriteCard
PROCEDURE WriteCard (cid: IOChan.ChanId; card: CARDINAL; width: CARDINAL);
  (* Writes the value of card to cid in text form, in a field of the given minimum width. *)

END WholeIO.

@end example
@page


@node gm2-iso/WholeStr, , gm2-iso/WholeIO, M2 ISO Libraries
@subsection gm2-iso/WholeStr

@example
DEFINITION MODULE WholeStr;

  (* Whole-number/string conversions *)

IMPORT
  ConvTypes;

TYPE
  ConvResults = ConvTypes.ConvResults; (* strAllRight, strOutOfRange, strWrongFormat, strEmpty *)

(* the string form of a signed whole number is
     ["+" | "-"], decimal digit, @{decimal digit@}
*)

@findex StrToInt
PROCEDURE StrToInt (str: ARRAY OF CHAR; VAR int: INTEGER; VAR res: ConvResults);
  (* Ignores any leading spaces in str. If the subsequent characters in str are in the
     format of a signed whole number, assigns a corresponding value to int. Assigns a
     value indicating the format of str to res.
  *)

@findex IntToStr
PROCEDURE IntToStr (int: INTEGER; VAR str: ARRAY OF CHAR);
  (* Converts the value of int to string form and copies the possibly truncated result to str. *)

(* the string form of an unsigned whole number is
     decimal digit, @{decimal digit@}
*)

@findex StrToCard
PROCEDURE StrToCard (str: ARRAY OF CHAR; VAR card: CARDINAL; VAR res: ConvResults);
  (* Ignores any leading spaces in str. If the subsequent characters in str are in the
     format of an unsigned whole number, assigns a corresponding value to card.
     Assigns a value indicating the format of str to res.
  *)

@findex CardToStr
PROCEDURE CardToStr (card: CARDINAL; VAR str: ARRAY OF CHAR);
  (* Converts the value of card to string form and copies the possibly truncated result to str. *)

END WholeStr.

@end example
@page



@c ---------------------------------------------------------------------
