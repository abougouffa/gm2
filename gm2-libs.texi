@c Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.

@c Permission is granted to copy, distribute and/or modify this document
@c under the terms of the GNU Free Documentation License, Version 1.2 or
@c any later version published by the Free Software Foundation.

@menu
* Base libraries::Basic M2F compatible libraries
* PIM and Logitech 3.0 Compatible::PIM and Logitech 3.0 compatible libraries
* PIM coroutine support::PIM compatible process support
* M2 ISO Libraries::ISO defined libraries
* ULM System Libraries::ULM System libraries
* ULM Standard Libraries::ULM Standard libraries
@end menu


@c =====================================================================


@node Base libraries, PIM and Logitech 3.0 Compatible, , Libraries
@section Base libraries

@c Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
@c Permission is granted to copy, distribute and/or modify this document
@c under the terms of the GNU Free Documentation License, Version 1.2 or
@c any later version published by the Free Software Foundation.

These are the base libraries for the GNU Modula-2 compiler.  These
modules originally came from the M2F compiler and have been cleaned up
and extended.  They provide a basic interface to the underlying
operating system via libc.  They also include a number of libraries to
allow access to compiler built-ins. Perhaps the largest difference to
PIM and ISO libraries is the @code{DynamicString} module which
declares the type @code{String}.  The heavy use of this opaque data
type results in a number of equivalent modules that can either handle
@code{ARRAY OF CHAR} or @code{String}.

These modules have been extensively tested and are used throughout
building the GNU Modula-2 compiler.
@menu
* gm2-libs/ASCII::ASCII.def
* gm2-libs/Args::Args.def
* gm2-libs/Assertion::Assertion.def
* gm2-libs/Break::Break.def
* gm2-libs/Builtins::Builtins.def
* gm2-libs/CmdArgs::CmdArgs.def
* gm2-libs/Debug::Debug.def
* gm2-libs/DynamicStrings::DynamicStrings.def
* gm2-libs/Environment::Environment.def
* gm2-libs/FIO::FIO.def
* gm2-libs/FormatStrings::FormatStrings.def
* gm2-libs/FpuIO::FpuIO.def
* gm2-libs/IO::IO.def
* gm2-libs/M2RTS::M2RTS.def
* gm2-libs/MathLib0::MathLib0.def
* gm2-libs/MemUtils::MemUtils.def
* gm2-libs/NumberIO::NumberIO.def
* gm2-libs/PushBackInput::PushBackInput.def
* gm2-libs/SArgs::SArgs.def
* gm2-libs/SEnvironment::SEnvironment.def
* gm2-libs/SFIO::SFIO.def
* gm2-libs/SYSTEM::SYSTEM.def
* gm2-libs/Scan::Scan.def
* gm2-libs/Selective::Selective.def
* gm2-libs/StdIO::StdIO.def
* gm2-libs/Storage::Storage.def
* gm2-libs/StrCase::StrCase.def
* gm2-libs/StrIO::StrIO.def
* gm2-libs/StrLib::StrLib.def
* gm2-libs/StringConvert::StringConvert.def
* gm2-libs/SysStorage::SysStorage.def
* gm2-libs/TimeString::TimeString.def
* gm2-libs/UnixArgs::UnixArgs.def
* gm2-libs/cbuiltin::cbuiltin.def
* gm2-libs/libc::libc.def
* gm2-libs/libm::libm.def
* gm2-libs/wrapc::wrapc.def
@end menu


@node gm2-libs/ASCII, gm2-libs/Args, , Base libraries
@subsection gm2-libs/ASCII

@example
DEFINITION MODULE ASCII ;

(*
   Desciption: Defines all ascii constants (as in man ASCII)
               Note that lf, eof and EOL are added
*)

EXPORT QUALIFIED
     nul, soh, stx, etx, eot, enq, ack, bel,
     bs , ht , nl , vt , np , cr , so , si ,
     dle, dc1, dc2, dc3, dc4, nak, syn, etb,
     can, em , sub, esc, fs , gs , rs , us ,
     sp ,  (* All the above are in order *)
     lf, ff, eof, del, tab, EOL ;

CONST
     nul=000C; soh=001C; stx=002C; etx=003C;
     eot=004C; enq=005C; ack=006C; bel=007C;
     bs =010C; ht =011C; nl =012C; vt =013C;
     np =014C; cr =015C; so =016C; si =017C;
     dle=020C; dc1=021C; dc2=022C; dc3=023C;
     dc4=024C; nak=025C; syn=026C; etb=027C;
     can=030C; em =031C; sub=032C; esc=033C;
     fs =034C; gs =035C; rs =036C; us =037C;
     sp =040C; (* All the above are in order *)
     lf =nl  ; ff =np  ; eof=eot ; tab=ht  ;
     del=177C; EOL=cr  ;

END ASCII.
@end example
@page


@node gm2-libs/Args, gm2-libs/Assertion, gm2-libs/ASCII, Base libraries
@subsection gm2-libs/Args

@example
DEFINITION MODULE Args ;

(*
    Description: provides a simple interface to the command
                 line arguments.
*)

EXPORT QUALIFIED GetArg, Narg ;


(*
   GetArg - returns the nth argument from the command line.
            The success of the operation is returned.
*)

@findex GetArg
PROCEDURE GetArg (VAR a: ARRAY OF CHAR ; i: CARDINAL) : BOOLEAN ;


(*
   Narg - returns the number of arguments available from
          command line.
*)

@findex Narg
PROCEDURE Narg() : CARDINAL ;


END Args.
@end example
@page


@node gm2-libs/Assertion, gm2-libs/Break, gm2-libs/Args, Base libraries
@subsection gm2-libs/Assertion

@example
DEFINITION MODULE Assertion ;

(*
   Description: Provides an assert procedure.
*)

EXPORT QUALIFIED Assert ;


(*
   Assert - tests the boolean Condition, if it fails then HALT is called.
*)

@findex Assert
PROCEDURE Assert (Condition: BOOLEAN) ;


END Assertion.
@end example
@page


@node gm2-libs/Break, gm2-libs/Builtins, gm2-libs/Assertion, Base libraries
@subsection gm2-libs/Break

@example
DEFINITION MODULE Break ;

END Break.
@end example
@page


@node gm2-libs/Builtins, gm2-libs/CmdArgs, gm2-libs/Break, Base libraries
@subsection gm2-libs/Builtins

@example
DEFINITION MODULE Builtins ;

(*
    Description: provides a convenient place to list all the GNU Modula-2
                 built-in functions. These functions should be copied into
                 more generic modules.

                 For example the mathematical functions can be applied to
                 gm2-iso/LongMath. But each built-in function is here for
                 reference.
*)

FROM SYSTEM IMPORT ADDRESS ;

@findex sinf
PROCEDURE __BUILTIN__ sinf (x: SHORTREAL) : SHORTREAL ;
@findex sin
PROCEDURE __BUILTIN__ sin (x: REAL) : REAL ;
@findex sinl
PROCEDURE __BUILTIN__ sinl (x: LONGREAL) : LONGREAL ;

@findex cosf
PROCEDURE __BUILTIN__ cosf (x: SHORTREAL) : SHORTREAL ;
@findex cos
PROCEDURE __BUILTIN__ cos (x: REAL) : REAL ;
@findex cosl
PROCEDURE __BUILTIN__ cosl (x: LONGREAL) : LONGREAL ;

@findex sqrtf
PROCEDURE __BUILTIN__ sqrtf (x: SHORTREAL) : SHORTREAL ;
@findex sqrt
PROCEDURE __BUILTIN__ sqrt (x: REAL) : REAL ;
@findex sqrtl
PROCEDURE __BUILTIN__ sqrtl (x: LONGREAL) : LONGREAL ;

@findex fabsf
PROCEDURE __BUILTIN__ fabsf (x: SHORTREAL) : SHORTREAL ;
@findex fabs
PROCEDURE __BUILTIN__ fabs (x: REAL) : REAL ;
@findex fabsl
PROCEDURE __BUILTIN__ fabsl (x: LONGREAL) : LONGREAL ;

@findex logf
PROCEDURE __BUILTIN__ logf (x: SHORTREAL) : SHORTREAL ;
@findex log
PROCEDURE __BUILTIN__ log (x: REAL) : REAL ;
@findex logl
PROCEDURE __BUILTIN__ logl (x: LONGREAL) : LONGREAL ;

@findex expf
PROCEDURE __BUILTIN__ expf (x: SHORTREAL) : SHORTREAL ;
@findex exp
PROCEDURE __BUILTIN__ exp (x: REAL) : REAL ;
@findex expl
PROCEDURE __BUILTIN__ expl (x: LONGREAL) : LONGREAL ;

@findex alloca
PROCEDURE __BUILTIN__ alloca (i: CARDINAL) : ADDRESS ;
@findex memcpy
PROCEDURE __BUILTIN__ memcpy (dest, src: ADDRESS; n: CARDINAL) : ADDRESS ;
@findex index
PROCEDURE __BUILTIN__ index (s: ADDRESS; c: INTEGER) : ADDRESS ;
@findex rindex
PROCEDURE __BUILTIN__ rindex (s: ADDRESS; c: INTEGER) : ADDRESS ;
@findex memcmp
PROCEDURE __BUILTIN__ memcmp (s1, s2: ADDRESS; n: CARDINAL) : INTEGER ;
@findex memset
PROCEDURE __BUILTIN__ memset (s: ADDRESS; c: INTEGER; n: CARDINAL) : ADDRESS ;
@findex strcat
PROCEDURE __BUILTIN__ strcat (dest, src: ADDRESS) : ADDRESS ;
@findex strncat
PROCEDURE __BUILTIN__ strncat (dest, src: ADDRESS; n: CARDINAL) : ADDRESS ;
@findex strcpy
PROCEDURE __BUILTIN__ strcpy (dest, src: ADDRESS) : ADDRESS ;
@findex strncpy
PROCEDURE __BUILTIN__ strncpy (dest, src: ADDRESS; n: CARDINAL) : ADDRESS ;
@findex strcmp
PROCEDURE __BUILTIN__ strcmp (s1, s2: ADDRESS) : INTEGER ;
@findex strncmp
PROCEDURE __BUILTIN__ strncmp (s1, s2: ADDRESS; n: CARDINAL) : INTEGER ;
@findex strlen
PROCEDURE __BUILTIN__ strlen (s: ADDRESS) : INTEGER ;
@findex strstr
PROCEDURE __BUILTIN__ strstr (haystack, needle: ADDRESS) : ADDRESS ;
@findex strpbrk
PROCEDURE __BUILTIN__ strpbrk (s, accept: ADDRESS) : ADDRESS ;
@findex strspn
PROCEDURE __BUILTIN__ strspn (s, accept: ADDRESS) : CARDINAL ;
@findex strcspn
PROCEDURE __BUILTIN__ strcspn (s, accept: ADDRESS) : CARDINAL ;
@findex strchr
PROCEDURE __BUILTIN__ strchr (s: ADDRESS; c: INTEGER) : ADDRESS ;
@findex strrchr
PROCEDURE __BUILTIN__ strrchr (s: ADDRESS; c: INTEGER) : ADDRESS ;

@findex huge_val
PROCEDURE __BUILTIN__ huge_val (r: REAL) : REAL ;
@findex huge_valf
PROCEDURE __BUILTIN__ huge_valf (s: SHORTREAL) : SHORTREAL ;
@findex huge_vall
PROCEDURE __BUILTIN__ huge_vall (l: LONGREAL) : LONGREAL ;

END Builtins.
@end example
@page


@node gm2-libs/CmdArgs, gm2-libs/Debug, gm2-libs/Builtins, Base libraries
@subsection gm2-libs/CmdArgs

@example
DEFINITION MODULE CmdArgs ;

(*
   Description: CmdArgs - implements procedures to retrieve arguments from
                a string.
*)

EXPORT QUALIFIED GetArg, Narg ;


(*
   GetArg - returns the nth argument from the command line, CmdLine
            the success of the operation is returned.
*)

@findex GetArg
PROCEDURE GetArg (CmdLine: ARRAY OF CHAR;
                  n: CARDINAL; VAR Argi: ARRAY OF CHAR) : BOOLEAN ;


(*
   Narg - returns the number of arguments available from
          command line, CmdLine.
*)

@findex Narg
PROCEDURE Narg (CmdLine: ARRAY OF CHAR) : CARDINAL ;


END CmdArgs.
@end example
@page


@node gm2-libs/Debug, gm2-libs/DynamicStrings, gm2-libs/CmdArgs, Base libraries
@subsection gm2-libs/Debug

@example
DEFINITION MODULE Debug ;

(*
    Description: provides some simple debugging routines.
*)

EXPORT QUALIFIED Halt, DebugString ;


(*
   Halt - writes a message in the format:
          Module:Line:Message

          It then terminates by calling HALT.
*)

@findex Halt
PROCEDURE Halt (Message: ARRAY OF CHAR;
                LineNo: CARDINAL;
                Module: ARRAY OF CHAR) ;


(*
   DebugString - writes a string to the debugging device (Scn.Write).
                 It interprets \n as carriage return, linefeed.
*)

@findex DebugString
PROCEDURE DebugString (a: ARRAY OF CHAR) ;


END Debug.
@end example
@page


@node gm2-libs/DynamicStrings, gm2-libs/Environment, gm2-libs/Debug, Base libraries
@subsection gm2-libs/DynamicStrings

@example
DEFINITION MODULE DynamicStrings ;

(*
    Description: provides a dynamic string type and common methods.
*)

FROM SYSTEM IMPORT ADDRESS ;
EXPORT QUALIFIED String,
                 InitString, KillString, Fin, InitStringCharStar, InitStringChar,
                 Index, RIndex,
                 Mark, Length, ConCat, ConCatChar, Assign, Dup, Add,
                 Equal, EqualCharStar, EqualArray, ToUpper, ToLower,
                 CopyOut, Mult, Slice, RemoveWhitePrefix, char, string ;

TYPE
   String ;


(*
   InitString - creates and returns a String type object.
                Initial contents are, a.
*)

@findex InitString
PROCEDURE InitString (a: ARRAY OF CHAR) : String ;


(*
   KillString - frees String, s, and its contents.
                NIL is returned.
*)

@findex KillString
PROCEDURE KillString (s: String) : String ;


(*
   Fin - finishes with a string, it calls KillString with, s.
         The purpose of the procedure is to provide a short cut
         to calling KillString and then testing the return result.
*)

@findex Fin
PROCEDURE Fin (s: String) ;


(*
   InitStringCharStar - initializes and returns a String to contain the C string.
*)

@findex InitStringCharStar
PROCEDURE InitStringCharStar (a: ADDRESS) : String ;


(*
   InitStringChar - initializes and returns a String to contain the single character, ch.
*)

@findex InitStringChar
PROCEDURE InitStringChar (ch: CHAR) : String ;


(*
   Mark - marks String, s, ready for garbage collection.
*)

@findex Mark
PROCEDURE Mark (s: String) : String ;


(*
   Length - returns the length of the String, s.
*)

@findex Length
PROCEDURE Length (s: String) : CARDINAL ;


(*
   ConCat - returns String, a, after the contents of, b, have been appended.
*)

@findex ConCat
PROCEDURE ConCat (a, b: String) : String ;


(*
   ConCatChar - returns String, a, after character, ch, has been appended.
*)

@findex ConCatChar
PROCEDURE ConCatChar (a: String; ch: CHAR) : String ;


(*
   Assign - assigns the contents of, b, into, a.
            String, a, is returned.
*)

@findex Assign
PROCEDURE Assign (a, b: String) : String ;


(*
   Dup - duplicate a String, s, returning the copy of s.
*)

@findex Dup
PROCEDURE Dup (s: String) : String ;


(*
   Add - returns a new String which contains the contents of a and b.
*)

@findex Add
PROCEDURE Add (a, b: String) : String ;


(*
   Equal - returns TRUE if String, a, and, b, are equal.
*)

@findex Equal
PROCEDURE Equal (a, b: String) : BOOLEAN ;


(*
   EqualCharStar - returns TRUE if contents of String, s, is the same as the
                   string, a.
*)

@findex EqualCharStar
PROCEDURE EqualCharStar (s: String; a: ADDRESS) : BOOLEAN ;


(*
   EqualArray - returns TRUE if contents of String, s, is the same as the
                string, a.
*)

@findex EqualArray
PROCEDURE EqualArray (s: String; a: ARRAY OF CHAR) : BOOLEAN ;


(*
   Mult - returns a new string which is n concatenations of String, s.
          If n<=0 then an empty string is returned.
*)

@findex Mult
PROCEDURE Mult (s: String; n: CARDINAL) : String ;


(*
   Slice - returns a new string which contains the elements
           low..high-1

           strings start at element 0
           Slice(s, 0, 2)  will return elements 0, 1 but not 2
           Slice(s, 1, 3)  will return elements 1, 2 but not 3
           Slice(s, 2, 0)  will return elements 2..max
           Slice(s, 3, -1) will return elements 3..max-1
           Slice(s, 4, -2) will return elements 4..max-2
*)

@findex Slice
PROCEDURE Slice (s: String; low, high: INTEGER) : String ;


(*
   Index - returns the indice of the first occurance of, ch, in
           String, s. -1 is returned if, ch, does not exist.
           The search starts at position, o.
           -1 is returned if, ch, is not found.
*)

@findex Index
PROCEDURE Index (s: String; ch: CHAR; o: CARDINAL) : INTEGER ;


(*
   RIndex - returns the indice of the last occurance of, ch,
            in String, s. The search starts at position, o.
            -1 is returned if, ch, is not found.
*)

@findex RIndex
PROCEDURE RIndex (s: String; ch: CHAR; o: CARDINAL) : INTEGER ;


(*
   RemoveWhitePrefix - removes any leading white space from String, s.
                       A new string is returned.
*)

@findex RemoveWhitePrefix
PROCEDURE RemoveWhitePrefix (s: String) : String ;


(*
   ToUpper - returns string, s, after it has had its lower case characters
             replaced by upper case characters.
             The string, s, is not duplicated.
*)

@findex ToUpper
PROCEDURE ToUpper (s: String) : String ;


(*
   ToLower - returns string, s, after it has had its upper case characters
             replaced by lower case characters.
             The string, s, is not duplicated.
*)

@findex ToLower
PROCEDURE ToLower (s: String) : String ;


(*
   CopyOut - copies string, s, to a.
*)

@findex CopyOut
PROCEDURE CopyOut (VAR a: ARRAY OF CHAR; s: String) ;


(*
   char - returns the character, ch, at position, i, in String, s.
          As Slice the index can be negative so:

          char(s, 0) will return the first character
          char(s, 1) will return the second character
          char(s, -1) will return the last character
          char(s, -2) will return the penultimate character

          a nul character is returned if the index is out of range.
*)

@findex char
PROCEDURE char (s: String; i: INTEGER) : CHAR ;


(*
   string - returns the C style char * of String, s.
*)

@findex string
PROCEDURE string (s: String) : ADDRESS ;


END DynamicStrings.
@end example
@page


@node gm2-libs/Environment, gm2-libs/FIO, gm2-libs/DynamicStrings, Base libraries
@subsection gm2-libs/Environment

@example
DEFINITION MODULE Environment ;

(*
    Description: provides access to the environment settings of a process.
*)

EXPORT QUALIFIED GetEnvironment ;


(*
   GetEnvironment - gets the environment variable, Env, and places
      	       	    a copy of its value into string, a.
*)

@findex GetEnvironment
PROCEDURE GetEnvironment (Env: ARRAY OF CHAR; VAR a: ARRAY OF CHAR) : BOOLEAN ;


END Environment.
@end example
@page


@node gm2-libs/FIO, gm2-libs/FormatStrings, gm2-libs/Environment, Base libraries
@subsection gm2-libs/FIO

@example
DEFINITION MODULE FIO ;

(*
    Description: provides a simple buffered file input/output library.
*)


FROM SYSTEM IMPORT ADDRESS, BYTE ;

EXPORT QUALIFIED (* types *)
                 File,
                 (* procedures *)
                 OpenToRead, OpenToWrite, OpenForRandom, Close,
                 EOF, EOLN, IsNoError, Exists,
                 exists, openToRead, openToWrite, openForRandom,
                 SetPositionFromBeginning, FindPosition,
                 ReadChar, ReadString,
                 WriteChar, WriteString, WriteLine,
                 WriteCardinal, ReadCardinal,
                 UnReadChar,
                 WriteNBytes, ReadNBytes,
                 GetUnixFileDescriptor,
                 (* variables *)
                 StdIn, StdOut, StdErr ;

TYPE
   File = CARDINAL ;

(* the following variables are initialized to their UNIX equivalents *)
VAR
   StdIn, StdOut, StdErr: File ;



(*
   IsNoError - returns a TRUE if no error has occured on file, f.
*)

@findex IsNoError
PROCEDURE IsNoError (f: File) : BOOLEAN ;


(*
   Exists - returns TRUE if a file named, fname exists for reading.
*)

@findex Exists
PROCEDURE Exists (fname: ARRAY OF CHAR) : BOOLEAN ;


(*
   OpenToRead - attempts to open a file, fname, for reading and
                it returns this file.
                The success of this operation can be checked by
                calling IsNoError.
*)

@findex OpenToRead
PROCEDURE OpenToRead (fname: ARRAY OF CHAR) : File ;


(*
   OpenToWrite - attempts to open a file, fname, for write and
                 it returns this file.
                 The success of this operation can be checked by
                 calling IsNoError.
*)

@findex OpenToWrite
PROCEDURE OpenToWrite (fname: ARRAY OF CHAR) : File ;


(*
   OpenForRandom - attempts to open a file, fname, for random access
                   read or write and it returns this file.
                   The success of this operation can be checked by
                   calling IsNoError.
                   towrite, determines whether the file should be
                   opened for writing or reading.
*)

@findex OpenForRandom
PROCEDURE OpenForRandom (fname: ARRAY OF CHAR; towrite: BOOLEAN) : File ;


(*
   Close - close a file which has been previously opened using:
           OpenToRead, OpenToWrite, OpenForRandom.
           It is correct to close a file which has an error status.
*)

@findex Close
PROCEDURE Close (f: File) ;


(* the following functions are functionally equivalent to the above
   except they allow C style names.
*)

@findex exists
PROCEDURE exists        (fname: ADDRESS; flength: CARDINAL) : BOOLEAN ;
@findex openToRead
PROCEDURE openToRead    (fname: ADDRESS; flength: CARDINAL) : File ;
@findex openToWrite
PROCEDURE openToWrite   (fname: ADDRESS; flength: CARDINAL) : File ;
@findex openForRandom
PROCEDURE openForRandom (fname: ADDRESS; flength: CARDINAL; towrite: BOOLEAN) : File ;


(*
   ReadNBytes - reads nBytes of a file into memory area, a, returning
                the number of bytes actually read.
                This function will consume from the buffer and then
                perform direct libc reads. It is ideal for large reads.
*)

@findex ReadNBytes
PROCEDURE ReadNBytes (f: File; nBytes: CARDINAL; a: ADDRESS) : CARDINAL ;


(*
   ReadAny - reads HIGH(a) bytes into, a. All input
             is fully buffered, unlike ReadNBytes and thus is more
             suited to small reads.
*)

@findex ReadAny
PROCEDURE ReadAny (f: File; VAR a: ARRAY OF BYTE) ;


(*
   WriteNBytes - writes nBytes of a file into memory area, a, returning
                 the number of bytes actually written.
                 This function will flush the buffer and then
                 write the nBytes using a direct write from libc.
                 It is ideal for large writes.
*)

@findex WriteNBytes
PROCEDURE WriteNBytes (f: File; nBytes: CARDINAL; a: ADDRESS) : CARDINAL ;


(*
   WriteAny - writes HIGH(a) bytes onto, file, f. All output
              is fully buffered, unlike WriteNBytes and thus is more
              suited to small writes.
*)

@findex WriteAny
PROCEDURE WriteAny (f: File; VAR a: ARRAY OF BYTE) ;


(*
   WriteChar - writes a single character to file, f.
*)

@findex WriteChar
PROCEDURE WriteChar (f: File; ch: CHAR) ;


(*
   EOF - tests to see whether a file, f, has reached end of file.
*)

@findex EOF
PROCEDURE EOF (f: File) : BOOLEAN ;


(*
   EOLN - tests to see whether a file, f, is upon a newline.
          It does NOT consume the newline.
*)

@findex EOLN
PROCEDURE EOLN (f: File) : BOOLEAN ;


(*
   ReadChar - returns a character read from file, f.
              Sensible to check with IsNoError or EOF after calling
              this function.
*)

@findex ReadChar
PROCEDURE ReadChar (f: File) : CHAR ;


(*
   UnReadChar - replaces a character, ch, back into file, f.
                This character must have been read by ReadChar
                and it does not allow successive calls.
*)

@findex UnReadChar
PROCEDURE UnReadChar (f: File ; ch: CHAR) ;


(*
   WriteLine - writes out a linefeed to file, f.
*)

@findex WriteLine
PROCEDURE WriteLine (f: File) ;


(*
   WriteString - writes a string to file, f.
*)

@findex WriteString
PROCEDURE WriteString (f: File; a: ARRAY OF CHAR) ;


(*
   ReadString - reads a string from file, f, into string, a.
                It terminates the string if HIGH is reached or
                if a newline is seen or an error occurs.
*)

@findex ReadString
PROCEDURE ReadString (f: File; VAR a: ARRAY OF CHAR) ;


(*
   WriteCardinal - writes a CARDINAL to file, f.
                   (Suggest that WriteAny be used instead -
                    here for compatibility)
*)

@findex WriteCardinal
PROCEDURE WriteCardinal (f: File; c: CARDINAL) ;


(*
   ReadCardinal - reads a CARDINAL from file, f.
                  (Suggest that ReadAny be used instead -
                   here for compatibility)
*)

@findex ReadCardinal
PROCEDURE ReadCardinal (f: File) : CARDINAL ;


(*
   GetUnixFileDescriptor - returns the UNIX file descriptor of a file.
                           Useful when combining FIO.mod with select
                           (in Selective.def - but note the comments in
                            Selective about using read/write primatives)
*)

@findex GetUnixFileDescriptor
PROCEDURE GetUnixFileDescriptor (f: File) : INTEGER ;


(*
   SetPositionFromBeginning - sets the position from the beginning of the file.
*)

@findex SetPositionFromBeginning
PROCEDURE SetPositionFromBeginning (f: File; pos: CARDINAL) ;


(*
   FindPosition - returns the current absolute position in file, f.
*)

@findex FindPosition
PROCEDURE FindPosition (f: File) : CARDINAL ;


END FIO.
@end example
@page


@node gm2-libs/FormatStrings, gm2-libs/FpuIO, gm2-libs/FIO, Base libraries
@subsection gm2-libs/FormatStrings

@example
DEFINITION MODULE FormatStrings ;

(*
    Description: provides a pseudo printf capability for GM2.
*)

FROM SYSTEM IMPORT BYTE ;
FROM DynamicStrings IMPORT String ;
EXPORT QUALIFIED Sprintf0, Sprintf1, Sprintf2, Sprintf3, Sprintf4 ;


(*
   Sprintf0 - returns a String containing, s, after it has had its
              escape sequences translated.
*)

@findex Sprintf0
PROCEDURE Sprintf0 (s: String) : String ;


(*
   Sprintf1 - returns a String containing, s, together with encapsulated
              entity, w. It only formats the first %s or %d with n.
*)

@findex Sprintf1
PROCEDURE Sprintf1 (s: String; w: ARRAY OF BYTE) : String ;


(*
   Sprintf2 - returns a string, s, which has been formatted.
*)

@findex Sprintf2
PROCEDURE Sprintf2 (s: String; w1, w2: ARRAY OF BYTE) : String ;


(*
   Sprintf3 - returns a string, s, which has been formatted.
*)

@findex Sprintf3
PROCEDURE Sprintf3 (s: String; w1, w2, w3: ARRAY OF BYTE) : String ;


(*
   Sprintf4 - returns a string, s, which has been formatted.
*)

@findex Sprintf4
PROCEDURE Sprintf4 (s: String; w1, w2, w3, w4: ARRAY OF BYTE) : String ;


END FormatStrings.
@end example
@page


@node gm2-libs/FpuIO, gm2-libs/IO, gm2-libs/FormatStrings, Base libraries
@subsection gm2-libs/FpuIO

@example
DEFINITION MODULE FpuIO ;

(*
   Description: Implements a fixed format input/output for REAL, LONGREAL and LONGINT numbers
*)

EXPORT QUALIFIED ReadReal, WriteReal, StrToReal, RealToStr,
                 ReadLongReal, WriteLongReal, StrToLongReal, LongRealToStr,
                 ReadLongInt, WriteLongInt, StrToLongInt, LongIntToStr ;


@findex ReadReal
PROCEDURE ReadReal (VAR x: REAL) ;
@findex WriteReal
PROCEDURE WriteReal (x: REAL; TotalWidth, FractionWidth: CARDINAL) ;
@findex StrToReal
PROCEDURE StrToReal (a: ARRAY OF CHAR ; VAR x: REAL) ;
@findex RealToStr
PROCEDURE RealToStr (x: REAL; TotalWidth, FractionWidth: CARDINAL; VAR a: ARRAY OF CHAR) ;

@findex ReadLongReal
PROCEDURE ReadLongReal (VAR x: LONGREAL) ;
@findex WriteLongReal
PROCEDURE WriteLongReal (x: LONGREAL; TotalWidth, FractionWidth: CARDINAL) ;
@findex StrToLongReal
PROCEDURE StrToLongReal (a: ARRAY OF CHAR ; VAR x: LONGREAL) ;
@findex LongRealToStr
PROCEDURE LongRealToStr (x: LONGREAL; TotalWidth, FractionWidth: CARDINAL; VAR a: ARRAY OF CHAR) ;

@findex ReadLongInt
PROCEDURE ReadLongInt (VAR x: LONGINT) ;
@findex WriteLongInt
PROCEDURE WriteLongInt (x: LONGINT; n: CARDINAL) ;
@findex StrToLongInt
PROCEDURE StrToLongInt (a: ARRAY OF CHAR ; VAR x: LONGINT) ;
@findex LongIntToStr
PROCEDURE LongIntToStr (x: LONGINT; n: CARDINAL; VAR a: ARRAY OF CHAR) ;


END FpuIO.
@end example
@page


@node gm2-libs/IO, gm2-libs/M2RTS, gm2-libs/FpuIO, Base libraries
@subsection gm2-libs/IO

@example
DEFINITION MODULE IO ;

(*
   Description: provides Read, Write, Errors procedures that map onto UNIX
                file descriptors 0, 1 and 2. This is achieved by using
                FIO if we are in buffered mode and using libc.write
                if not.
*)

EXPORT QUALIFIED Read, Write, Error,
                 IOInRawMode, IOInBufferedMode ;


@findex Read
PROCEDURE Read (VAR ch: CHAR) ;
@findex Write
PROCEDURE Write (ch: CHAR) ;
@findex Error
PROCEDURE Error (ch: CHAR) ;
@findex IOInRawMode
PROCEDURE IOInRawMode ;
@findex IOInBufferedMode
PROCEDURE IOInBufferedMode ;


END IO.
@end example
@page


@node gm2-libs/M2RTS, gm2-libs/MathLib0, gm2-libs/IO, Base libraries
@subsection gm2-libs/M2RTS

@example
DEFINITION MODULE M2RTS ;

(*
   Description: Implements the run time system facilities of Modula-2.
*)

FROM SYSTEM IMPORT BITSET ;
EXPORT QUALIFIED HALT, Halt,
                 SubrangeAssignmentError, ArraySubscriptError,
                 FunctionReturnError, NilPointerError,
                 CaseElseError,
                 InstallTerminationProcedure, Terminate,
                 ExitOnHalt, Length ;


(*
   HALT - terminate the current program.
          The procedure Terminate is called before the program is
          stopped.
*)

@findex HALT
PROCEDURE HALT ;


(*
   Halt - provides a more user friendly version of HALT, which takes
          four parameters to aid debugging.
*)

@findex Halt
PROCEDURE Halt (file: ARRAY OF CHAR; line: CARDINAL;
                function: ARRAY OF CHAR; description: ARRAY OF CHAR) ;


(*
   SubrangeAssignmentError - part of the runtime checking, called if a
                             subrange variable is just about to be assigned an illegal value.
*)

@findex SubrangeAssignmentError
PROCEDURE SubrangeAssignmentError (file: ARRAY OF CHAR;
                                   line: CARDINAL;
                                   function: ARRAY OF CHAR) ;


(*
   ArraySubscriptError -  part of the runtime checking, called if an
                          array indice is out of range.
*)

@findex ArraySubscriptError
PROCEDURE ArraySubscriptError (file: ARRAY OF CHAR;
                               line: CARDINAL;
                               function: ARRAY OF CHAR) ;


(*
   FunctionReturnError -  part of the runtime checking, called if a
                          function exits without a RETURN statement.
*)

@findex FunctionReturnError
PROCEDURE FunctionReturnError (file: ARRAY OF CHAR;
                               line: CARDINAL;
                               function: ARRAY OF CHAR) ;


(*
   NilPointerError -  part of the runtime checking, called if a
                      the code is about to dereference NIL.
*)

@findex NilPointerError
PROCEDURE NilPointerError (file: ARRAY OF CHAR;
                           line: CARDINAL;
                           function: ARRAY OF CHAR) ;

(*
   CaseElseError - part of the runtime checking, called if a
                   CASE statement falls into an ELSE statement
                   (which was not declared by the programmer).
*)

@findex CaseElseError
PROCEDURE CaseElseError (file: ARRAY OF CHAR;
                         line: CARDINAL;
                         function: ARRAY OF CHAR) ;


(*
   ExitOnHalt - if HALT is executed then call exit with the exit code, e.
*)

@findex ExitOnHalt
PROCEDURE ExitOnHalt (e: INTEGER) ;


(*
   InstallTerminationProcedure - installs a procedure, p, which will
                                 be called when the procedure Terminate
                                 is ionvoked.
*)

@findex InstallTerminationProcedure
PROCEDURE InstallTerminationProcedure (p: PROC) ;


(*
   Terminate - calls each installed termination procedure in turn.
*)

@findex Terminate
PROCEDURE Terminate ;


(*
   Length - returns the length of a string, a. This is called whenever
            the user calls LENGTH and the parameter cannot be calculated
            at compile time.
*)

@findex Length
PROCEDURE Length (a: ARRAY OF CHAR) : CARDINAL ;


END M2RTS.
@end example
@page


@node gm2-libs/MathLib0, gm2-libs/MemUtils, gm2-libs/M2RTS, Base libraries
@subsection gm2-libs/MathLib0

@example
DEFINITION MODULE MathLib0 ;

(*
    Description: provides access to math functions.
*)

CONST
   pi   = 3.1415926535897932384626433832795028841972;
   exp1 = 2.7182818284590452353602874713526624977572;


@findex sqrt
PROCEDURE __BUILTIN__ sqrt (x: REAL) : REAL ;
@findex sqrtl
PROCEDURE __BUILTIN__ sqrtl (x: LONGREAL) : LONGREAL ;
@findex sqrts
PROCEDURE __BUILTIN__ sqrts (x: SHORTREAL) : SHORTREAL ;

@findex exp
PROCEDURE exp (x: REAL) : REAL ;
@findex exps
PROCEDURE exps (x: SHORTREAL) : SHORTREAL ;

@findex ln
PROCEDURE ln (x: REAL) : REAL ;
@findex lns
PROCEDURE lns (x: SHORTREAL) : SHORTREAL ;

@findex sin
PROCEDURE __BUILTIN__ sin (x: REAL) : REAL ;
@findex sinl
PROCEDURE __BUILTIN__ sinl (x: LONGREAL) : LONGREAL ;
@findex sins
PROCEDURE __BUILTIN__ sins (x: SHORTREAL) : SHORTREAL ;

@findex cos
PROCEDURE __BUILTIN__ cos (x: REAL) : REAL ;
@findex cosl
PROCEDURE __BUILTIN__ cosl (x: LONGREAL) : LONGREAL ;
@findex coss
PROCEDURE __BUILTIN__ coss (x: SHORTREAL) : SHORTREAL ;

@findex tan
PROCEDURE tan (x: REAL) : REAL ;
@findex tans
PROCEDURE tans (x: SHORTREAL) : SHORTREAL ;

@findex arctan
PROCEDURE arctan (x: REAL) : REAL ;
@findex arctans
PROCEDURE arctans (x: SHORTREAL) : SHORTREAL ;

@findex entier
PROCEDURE entier (x: REAL) : INTEGER ;
@findex entiers
PROCEDURE entiers (x: SHORTREAL) : INTEGER ;

END MathLib0.
@end example
@page


@node gm2-libs/MemUtils, gm2-libs/NumberIO, gm2-libs/MathLib0, Base libraries
@subsection gm2-libs/MemUtils

@example
DEFINITION MODULE MemUtils ;

(*
    Description: provides some basic memory utilities.
*)

FROM SYSTEM IMPORT ADDRESS ;
EXPORT QUALIFIED MemCopy, MemZero ;


(*
   MemCopy - copys a region of memory to the required destination.
*)

@findex MemCopy
PROCEDURE MemCopy (from: ADDRESS; length: CARDINAL; to: ADDRESS) ;


(*
   MemZero - sets a region of memory: a..a+length to zero.
*)

@findex MemZero
PROCEDURE MemZero (a: ADDRESS; length: CARDINAL) ;


END MemUtils.
@end example
@page


@node gm2-libs/NumberIO, gm2-libs/PushBackInput, gm2-libs/MemUtils, Base libraries
@subsection gm2-libs/NumberIO

@example
DEFINITION MODULE NumberIO ;

(*
   Description: Provides all the input/output of numbers, and also the conversion
                of numbers to strings and visa versa.
*)

EXPORT QUALIFIED ReadCard, WriteCard, ReadHex, WriteHex, ReadInt, WriteInt,
                 CardToStr, StrToCard, StrToHex, HexToStr, StrToInt, IntToStr,
                 ReadOct, WriteOct, OctToStr, StrToOct,
                 ReadBin, WriteBin, BinToStr, StrToBin,
                 StrToBinInt, StrToHexInt, StrToOctInt ;


@findex ReadCard
PROCEDURE ReadCard (VAR x: CARDINAL) ;

@findex WriteCard
PROCEDURE WriteCard (x, n: CARDINAL) ;

@findex ReadHex
PROCEDURE ReadHex (VAR x: CARDINAL) ;

@findex WriteHex
PROCEDURE WriteHex (x, n: CARDINAL) ;

@findex ReadInt
PROCEDURE ReadInt (VAR x: INTEGER) ;

@findex WriteInt
PROCEDURE WriteInt (x: INTEGER ; n: CARDINAL) ;

@findex CardToStr
PROCEDURE CardToStr (x, n: CARDINAL ; VAR a: ARRAY OF CHAR) ;

@findex StrToCard
PROCEDURE StrToCard (a: ARRAY OF CHAR ; VAR x: CARDINAL) ;

@findex HexToStr
PROCEDURE HexToStr (x, n: CARDINAL ; VAR a: ARRAY OF CHAR) ;

@findex StrToHex
PROCEDURE StrToHex (a: ARRAY OF CHAR ; VAR x: CARDINAL) ;

@findex IntToStr
PROCEDURE IntToStr (x: INTEGER ; n: CARDINAL ; VAR a: ARRAY OF CHAR) ;

@findex StrToInt
PROCEDURE StrToInt (a: ARRAY OF CHAR ; VAR x: INTEGER) ;

@findex ReadOct
PROCEDURE ReadOct (VAR x: CARDINAL) ;

@findex WriteOct
PROCEDURE WriteOct (x, n: CARDINAL) ;

@findex OctToStr
PROCEDURE OctToStr (x, n: CARDINAL ; VAR a: ARRAY OF CHAR) ;

@findex StrToOct
PROCEDURE StrToOct (a: ARRAY OF CHAR ; VAR x: CARDINAL) ;

@findex ReadBin
PROCEDURE ReadBin (VAR x: CARDINAL) ;

@findex WriteBin
PROCEDURE WriteBin (x, n: CARDINAL) ;

@findex BinToStr
PROCEDURE BinToStr (x, n: CARDINAL ; VAR a: ARRAY OF CHAR) ;

@findex StrToBin
PROCEDURE StrToBin (a: ARRAY OF CHAR ; VAR x: CARDINAL) ;

@findex StrToBinInt
PROCEDURE StrToBinInt (a: ARRAY OF CHAR ; VAR x: INTEGER) ;

@findex StrToHexInt
PROCEDURE StrToHexInt (a: ARRAY OF CHAR ; VAR x: INTEGER) ;

@findex StrToOctInt
PROCEDURE StrToOctInt (a: ARRAY OF CHAR ; VAR x: INTEGER) ;


END NumberIO.
@end example
@page


@node gm2-libs/PushBackInput, gm2-libs/SArgs, gm2-libs/NumberIO, Base libraries
@subsection gm2-libs/PushBackInput

@example
DEFINITION MODULE PushBackInput ;

(*
    Description: provides a method for pushing back and consuming input
                 from a standard file descriptor. Insipred by software
                 tools.
*)

FROM FIO IMPORT File ;
FROM DynamicStrings IMPORT String ;

EXPORT QUALIFIED Open, PutCh, GetCh, Error, WarnError, WarnString, Close, SetDebug, GetExitStatus,
                 PutString, GetColumnPosition, GetCurrentLine ;


(*
   Open - opens a file for reading.
*)

@findex Open
PROCEDURE Open (a: ARRAY OF CHAR) : File ;


(*
   GetCh - gets a character from either the push back stack or
           from file, f.
*)

@findex GetCh
PROCEDURE GetCh (f: File) : CHAR ;


(*
   PutCh - pushes a character onto the push back stack, it also
           returns the character which has been pushed.
*)

@findex PutCh
PROCEDURE PutCh (f: File; ch: CHAR) : CHAR ;


(*
   PutString - pushes a string onto the push back stack.
*)

@findex PutString
PROCEDURE PutString (f: File; a: ARRAY OF CHAR) ;


(*
   Error - emits an error message with the appropriate file, line combination.
*)

@findex Error
PROCEDURE Error (a: ARRAY OF CHAR) ;


(*
   WarnError - emits an error message with the appropriate file, line combination.
               It does not terminate but when the program finishes an exit status of
               1 will be issued.
*)

@findex WarnError
PROCEDURE WarnError (a: ARRAY OF CHAR) ;


(*
   WarnString - emits an error message with the appropriate file, line combination.
                It does not terminate but when the program finishes an exit status of
                1 will be issued.
*)

@findex WarnString
PROCEDURE WarnString (s: String) ;


(*
   Close - closes the opened file.
*)

@findex Close
PROCEDURE Close (f: File) ;


(*
   GetExitStatus - returns the exit status which will be 1 if any warnings were issued.
*)

@findex GetExitStatus
PROCEDURE GetExitStatus () : CARDINAL ;


(*
   SetDebug - sets the debug flag on or off.
*)

@findex SetDebug
PROCEDURE SetDebug (d: BOOLEAN) ;


(*
   GetColumnPosition - returns the column position of the current character.
*)

@findex GetColumnPosition
PROCEDURE GetColumnPosition () : CARDINAL ;


(*
   GetCurrentLine - returns the current line number.
*)

@findex GetCurrentLine
PROCEDURE GetCurrentLine () : CARDINAL ;


END PushBackInput.
@end example
@page


@node gm2-libs/SArgs, gm2-libs/SEnvironment, gm2-libs/PushBackInput, Base libraries
@subsection gm2-libs/SArgs

@example
DEFINITION MODULE SArgs ;

(*
    Description: provides a String interface to the command line arguments.
*)

FROM DynamicStrings IMPORT String ;
EXPORT QUALIFIED GetArg, Narg ;


(*
   GetArg - returns the nth argument from the command line.
            The success of the operation is returned.
            If TRUE is returned then the string, s, contains a
            new string, otherwise s is set to NIL.
*)

@findex GetArg
PROCEDURE GetArg (VAR s: String ; i: CARDINAL) : BOOLEAN ;


(*
   Narg - returns the number of arguments available from
          command line.
*)

@findex Narg
PROCEDURE Narg() : CARDINAL ;


END SArgs.
@end example
@page


@node gm2-libs/SEnvironment, gm2-libs/SFIO, gm2-libs/SArgs, Base libraries
@subsection gm2-libs/SEnvironment

@example
DEFINITION MODULE SEnvironment ;

(*
    Description: provides access to the environment settings of a process.
*)

FROM DynamicStrings IMPORT String ;
EXPORT QUALIFIED GetEnvironment ;


(*
   GetEnvironment - gets the environment variable, env, and places
      	       	    a copy of its value into String, s.
                    TRUE is returned if successful.
*)

@findex GetEnvironment
PROCEDURE GetEnvironment (env: String; VAR s: String) : BOOLEAN ;


END SEnvironment.
@end example
@page


@node gm2-libs/SFIO, gm2-libs/SYSTEM, gm2-libs/SEnvironment, Base libraries
@subsection gm2-libs/SFIO

@example
DEFINITION MODULE SFIO ;

(*
    Description: provides a String interface to the opening routines of FIO
*)

FROM DynamicStrings IMPORT String ;
FROM FIO IMPORT File ;

EXPORT QUALIFIED OpenToRead, OpenToWrite, OpenForRandom, Exists, WriteS, ReadS ;


(*
   Exists - returns TRUE if a file named, fname exists for reading.
*)

@findex Exists
PROCEDURE Exists (fname: String) : BOOLEAN ;


(*
   OpenToRead - attempts to open a file, fname, for reading and
                it returns this file.
                The success of this operation can be checked by
                calling IsNoError.
*)

@findex OpenToRead
PROCEDURE OpenToRead (fname: String) : File ;


(*
   OpenToWrite - attempts to open a file, fname, for write and
                 it returns this file.
                 The success of this operation can be checked by
                 calling IsNoError.
*)

@findex OpenToWrite
PROCEDURE OpenToWrite (fname: String) : File ;


(*
   OpenForRandom - attempts to open a file, fname, for random access
                   read or write and it returns this file.
                   The success of this operation can be checked by
                   calling IsNoError.
                   towrite, determines whether the file should be
                   opened for writing or reading.
*)

@findex OpenForRandom
PROCEDURE OpenForRandom (fname: String; towrite: BOOLEAN) : File ;


(*
   WriteS - writes a string, s, to, file. It returns the String, s.
*)

@findex WriteS
PROCEDURE WriteS (file: File; s: String) : String ;


(*
   ReadS - reads a string, s, from, file. It returns the String, s.
           It stops reading the string at the end of line or end of file.
           It consumes the newline at the end of line but does not place
           this into the returned string.
*)

@findex ReadS
PROCEDURE ReadS (file: File) : String ;


END SFIO.
@end example
@page


@node gm2-libs/SYSTEM, gm2-libs/Scan, gm2-libs/SFIO, Base libraries
@subsection gm2-libs/SYSTEM

@example
DEFINITION MODULE SYSTEM ;

(*
   Description: Implements the SYSTEM dependent module
                in the Modula-2 compiler.
*)

EXPORT QUALIFIED (* the following are built into the compiler: *)
                 ADDRESS, WORD, BYTE, BITSET, ADR, TSIZE, SIZE ;

END SYSTEM.
@end example
@page


@node gm2-libs/Scan, gm2-libs/Selective, gm2-libs/SYSTEM, Base libraries
@subsection gm2-libs/Scan

@example
DEFINITION MODULE Scan ;

(*
   Description: Provides a primitive symbol fetching from input.
                Symbols are delimited by spaces and tabs.
                Limitation - only allows one source file at
                             a time to deliver symbols.
*)


EXPORT QUALIFIED GetNextSymbol, WriteError,
                 OpenSource, CloseSource,
                 TerminateOnError, DefineComments ;


(* OpenSource - opens a source file for reading.                  *)

@findex OpenSource
PROCEDURE OpenSource (a: ARRAY OF CHAR) : BOOLEAN ;


(* CloseSource - closes the current source file from reading.     *)

@findex CloseSource
PROCEDURE CloseSource ;


(* GetNextSymbol gets the next source symbol and returns it in a. *)

@findex GetNextSymbol
PROCEDURE GetNextSymbol (VAR a: ARRAY OF CHAR) ;


(* WriteError writes a message, a, under the source line, which   *)
(* attempts to pinpoint the Symbol at fault.                      *)

@findex WriteError
PROCEDURE WriteError (a: ARRAY OF CHAR) ;


(*
   TerminateOnError - exits with status 1 if we call WriteError.
*)

@findex TerminateOnError
PROCEDURE TerminateOnError ;


(*
   DefineComments - defines the start of comments within the source
                    file.

                    The characters in Start define the comment start
                    and characters in End define the end.
                    The BOOLEAN eoln determine whether the comment
                    is terminated by end of line. If eoln is TRUE
                    then End is ignored.

                    If this procedure is never called then no comments
                    are allowed.
*)

@findex DefineComments
PROCEDURE DefineComments (Start, End: ARRAY OF CHAR; eoln: BOOLEAN) ;


END Scan.
@end example
@page


@node gm2-libs/Selective, gm2-libs/StdIO, gm2-libs/Scan, Base libraries
@subsection gm2-libs/Selective

@example
DEFINITION MODULE Selective ;

(*
    Description: provides Modula-2 with access to the select(2) primitive.
*)

FROM SYSTEM IMPORT ADDRESS ;

EXPORT QUALIFIED SetOfFd, Timeval,
                 InitSet, KillSet, InitTime, KillTime,
                 GetTime, SetTime,
                 FdZero, FdSet, FdClr, FdIsSet, Select,
                 MaxFdsPlusOne, WriteCharRaw, ReadCharRaw,
                 GetTimeOfDay ;

TYPE
   SetOfFd = ADDRESS ;    (* Hidden type in Selective.c *)
   Timeval = ADDRESS ;    (* Hidden type in Selective.c *)


@findex Select
PROCEDURE Select (nooffds: CARDINAL;
                  readfds, writefds, exceptfds: SetOfFd;
                  timeout: Timeval) : INTEGER ;

@findex InitTime
PROCEDURE InitTime (sec, usec: CARDINAL) : Timeval ;
@findex KillTime
PROCEDURE KillTime (t: Timeval) : Timeval ;
@findex GetTime
PROCEDURE GetTime (t: Timeval; VAR sec, usec: CARDINAL) ;
@findex SetTime
PROCEDURE SetTime (t: Timeval; sec, usec: CARDINAL) ;
@findex InitSet
PROCEDURE InitSet () : SetOfFd ;
@findex KillSet
PROCEDURE KillSet (s: SetOfFd) : SetOfFd ;
@findex FdZero
PROCEDURE FdZero (s: SetOfFd) ;
@findex FdSet
PROCEDURE FdSet (fd: INTEGER; s: SetOfFd) ;
@findex FdClr
PROCEDURE FdClr (fd: INTEGER; s: SetOfFd) ;
@findex FdIsSet
PROCEDURE FdIsSet (fd: INTEGER; s: SetOfFd) : BOOLEAN ;
@findex MaxFdsPlusOne
PROCEDURE MaxFdsPlusOne (a, b: INTEGER) : INTEGER ;

(* you must use the raw routines with select - not the FIO buffered routines *)
@findex WriteCharRaw
PROCEDURE WriteCharRaw (fd: INTEGER; ch: CHAR) ;
@findex ReadCharRaw
PROCEDURE ReadCharRaw (fd: INTEGER) : CHAR ;

(*
   GetTimeOfDay - returns a record, Timeval, filled in with the
                  current system time in seconds and microseconds.
*)

@findex GetTimeOfDay
PROCEDURE GetTimeOfDay (tv: Timeval) : INTEGER ;


END Selective.
@end example
@page


@node gm2-libs/StdIO, gm2-libs/Storage, gm2-libs/Selective, Base libraries
@subsection gm2-libs/StdIO

@example
DEFINITION MODULE StdIO ;

(*
   Description: Exports a general Read and Write procedure that ALL character
                processes should use.
*)

EXPORT QUALIFIED ProcRead, ProcWrite,
                 Read, Write, PushOutput, PopOutput, GetCurrentOutput ;


TYPE
   ProcWrite = PROCEDURE (CHAR) ;
   ProcRead  = PROCEDURE (VAR CHAR) ;


(*
   Read - is the generic procedure that all higher application layers
          should use to receive a character.
*)

@findex Read
PROCEDURE Read (VAR ch: CHAR) ;


(*
   Write - is the generic procedure that all higher application layers
           should use to emit a character.
*)

@findex Write
PROCEDURE Write (ch: CHAR) ;


(*
   PushOutput - pushes the current Write procedure onto a stack,
                any future references to Write will actually invoke
                procedure, p.
*)

@findex PushOutput
PROCEDURE PushOutput (p: ProcWrite) ;


(*
   PopOutput - restores Write to use the previous output procedure.
*)

@findex PopOutput
PROCEDURE PopOutput ;


(*
   GetCurrentOutput - returns the current output procedure.
*)

@findex GetCurrentOutput
PROCEDURE GetCurrentOutput () : ProcWrite ;


END StdIO.
@end example
@page


@node gm2-libs/Storage, gm2-libs/StrCase, gm2-libs/StdIO, Base libraries
@subsection gm2-libs/Storage

@example
DEFINITION MODULE Storage ;

(*
   Description: Implements the dynamic Storage handler for the
                Modula-2 compiler.
*)

FROM SYSTEM IMPORT ADDRESS ;

EXPORT QUALIFIED ALLOCATE, DEALLOCATE, REALLOCATE, Available ;



(*
   ALLOCATE - attempt to allocate memory from the heap.
              NIL is returned in, a, if ALLOCATE fails.
*)

@findex ALLOCATE
PROCEDURE ALLOCATE (VAR a: ADDRESS ; Size: CARDINAL) ;


(*
   DEALLOCATE - return, Size, bytes to the heap.
                The variable, a, is set to NIL.
*)

@findex DEALLOCATE
PROCEDURE DEALLOCATE (VAR a: ADDRESS ; Size: CARDINAL) ;


(*
   REALLOCATE - attempts to reallocate storage. The address,
                a, should either be NIL in which case ALLOCATE
                is called, or alternatively it should have already
                been initialized by ALLOCATE. The allocated storage
                is resized accordingly.
*)

@findex REALLOCATE
PROCEDURE REALLOCATE (VAR a: ADDRESS; Size: CARDINAL) ;


(*
   Available - returns TRUE if, Size, bytes can be allocated.
*)

@findex Available
PROCEDURE Available (Size: CARDINAL) : BOOLEAN;


END Storage.

@end example
@page


@node gm2-libs/StrCase, gm2-libs/StrIO, gm2-libs/Storage, Base libraries
@subsection gm2-libs/StrCase

@example
DEFINITION MODULE StrCase ;


EXPORT QUALIFIED StrToUpperCase, StrToLowerCase, Cap, Lower ;


(*
   StrToUpperCase - converts string, a, to uppercase returning the
                    result in, b.
*)

@findex StrToUpperCase
PROCEDURE StrToUpperCase (a: ARRAY OF CHAR ; VAR b: ARRAY OF CHAR) ;


(*
   StrToLowerCase - converts string, a, to lowercase returning the
                    result in, b.
*)

@findex StrToLowerCase
PROCEDURE StrToLowerCase (a: ARRAY OF CHAR ; VAR b: ARRAY OF CHAR) ;


(*
   Cap - converts a lower case character into a capital character.
         If the character is not a lower case character 'a'..'z'
         then the character is simply returned unaltered.
*)

@findex Cap
PROCEDURE Cap (ch: CHAR) : CHAR ;


(*
   Lower - converts an upper case character into a lower case character.
           If the character is not an upper case character 'A'..'Z'
           then the character is simply returned unaltered.
*)

@findex Lower
PROCEDURE Lower (ch: CHAR) : CHAR ;


END StrCase.
@end example
@page


@node gm2-libs/StrIO, gm2-libs/StrLib, gm2-libs/StrCase, Base libraries
@subsection gm2-libs/StrIO

@example
DEFINITION MODULE StrIO ;

(*
   Description: Provides simple string input output routines.
*)

EXPORT QUALIFIED ReadString, WriteString,
                 WriteLn ;


(*
   WriteLn - writes a carriage return and a newline
             character.
*)

@findex WriteLn
PROCEDURE WriteLn ;


(*
   ReadString - reads a sequence of characters into a string.
                Line editing accepts Del, Ctrl H, Ctrl W and
                Ctrl U.
*)

@findex ReadString
PROCEDURE ReadString (VAR a: ARRAY OF CHAR) ;


(*
   WriteString - writes a string to the default output.
*)

@findex WriteString
PROCEDURE WriteString (a: ARRAY OF CHAR) ;



END StrIO.
@end example
@page


@node gm2-libs/StrLib, gm2-libs/StringConvert, gm2-libs/StrIO, Base libraries
@subsection gm2-libs/StrLib

@example
DEFINITION MODULE StrLib ;

(*
   Description: Provides string manipulation
*)

EXPORT QUALIFIED StrLen, StrCopy, StrEqual, StrConCat, StrLess,
      	       	 IsSubString, StrRemoveWhitePrefix ;


(*
   StrLess - returns TRUE if string, a, alphabetically occurs before
             string, b.
*)

@findex StrLess
PROCEDURE StrLess (a, b: ARRAY OF CHAR) : BOOLEAN ;


(*
   StrEqual - performs a = b on two strings.
*)

@findex StrEqual
PROCEDURE StrEqual (a, b: ARRAY OF CHAR) : BOOLEAN ;


(*
   StrLen - returns the length of string, a.
*)

@findex StrLen
PROCEDURE StrLen (a: ARRAY OF CHAR) : CARDINAL ;


(*
   StrCopy - effectively performs b := a with two strings.
*)

@findex StrCopy
PROCEDURE StrCopy (a: ARRAY OF CHAR ; VAR b: ARRAY OF CHAR) ;


(*
   StrConCat - combines a and b into c.
*)

@findex StrConCat
PROCEDURE StrConCat (a, b: ARRAY OF CHAR; VAR c: ARRAY OF CHAR) ;


(*
   IsSubString - returns true if b is a subcomponent of a.
*)

@findex IsSubString
PROCEDURE IsSubString (a, b: ARRAY OF CHAR) : BOOLEAN ;


(*
   StrRemoveWhitePrefix - copies string, into string, b, excluding any white
                          space infront of a.
*)

@findex StrRemoveWhitePrefix
PROCEDURE StrRemoveWhitePrefix (a: ARRAY OF CHAR; VAR b: ARRAY OF CHAR) ;


END StrLib.
@end example
@page


@node gm2-libs/StringConvert, gm2-libs/SysStorage, gm2-libs/StrLib, Base libraries
@subsection gm2-libs/StringConvert

@example
DEFINITION MODULE StringConvert ;

(*
    Description: provides functions to convert numbers to and from strings.
*)

FROM DynamicStrings IMPORT String ;
EXPORT QUALIFIED IntegerToString, StringToInteger,
                 StringToLongInteger, LongIntegerToString,
                 StringToCardinal, CardinalToString,
                 StringToLongCardinal, LongCardinalToString,
                 StringToShortCardinal, ShortCardinalToString,
                 StringToLongreal, LongrealToString,
                 stoi, itos, ctos, stoc, hstoi, ostoi, bstoi,
                 hstoc, ostoc, bstoc,
                 stor, stolr ;


(*
   IntegerToString - converts INTEGER, i, into a String. The field with
                     can be specified if non zero. Leading characters
                     are defined by padding and this function will
                     prepend a + if sign is set to TRUE.
                     The base allows the caller to generate binary,
                     octal, decimal, hexidecimal numbers.
                     The value of lower is only used when hexidecimal
                     numbers are generated and if TRUE then digits
                     abcdef are used, and if FALSE then ABCDEF are used.
*)

@findex IntegerToString
PROCEDURE IntegerToString (i: INTEGER; width: CARDINAL; padding: CHAR; sign: BOOLEAN;
                           base: CARDINAL; lower: BOOLEAN) : String ;


(*
   CardinalToString - converts CARDINAL, c, into a String. The field
                      width can be specified if non zero. Leading
                      characters are defined by padding.
                      The base allows the caller to generate binary,
                      octal, decimal, hexidecimal numbers.
                      The value of lower is only used when hexidecimal
                      numbers are generated and if TRUE then digits
                      abcdef are used, and if FALSE then ABCDEF are used.
*)

@findex CardinalToString
PROCEDURE CardinalToString (c: CARDINAL; width: CARDINAL; padding: CHAR;
                            base: CARDINAL; lower: BOOLEAN) : String ;


(*
   StringToInteger - converts a string, s, of, base, into an INTEGER.
                     Leading white space is ignored. It stops converting
                     when either the string is exhausted or if an illegal
                     numeral is found.
                     The parameter found is set TRUE if a number was found.
*)

@findex StringToInteger
PROCEDURE StringToInteger (s: String; base: CARDINAL; VAR found: BOOLEAN) : INTEGER ;


(*
   StringToCardinal - converts a string, s, of, base, into a CARDINAL.
                      Leading white space is ignored. It stops converting
                      when either the string is exhausted or if an illegal
                      numeral is found.
                      The parameter found is set TRUE if a number was found.
*)

@findex StringToCardinal
PROCEDURE StringToCardinal (s: String; base: CARDINAL; VAR found: BOOLEAN) : CARDINAL ;


(*
   LongIntegerToString - converts LONGINT, i, into a String. The field with
                         can be specified if non zero. Leading characters
                         are defined by padding and this function will
                         prepend a + if sign is set to TRUE.
                         The base allows the caller to generate binary,
                         octal, decimal, hexidecimal numbers.
                         The value of lower is only used when hexidecimal
                         numbers are generated and if TRUE then digits
                         abcdef are used, and if FALSE then ABCDEF are used.
*)

@findex LongIntegerToString
PROCEDURE LongIntegerToString (i: LONGINT; width: CARDINAL; padding: CHAR;
                               sign: BOOLEAN; base: CARDINAL; lower: BOOLEAN) : String ;



(*
   StringToLongInteger - converts a string, s, of, base, into an LONGINT.
                         Leading white space is ignored. It stops converting
                         when either the string is exhausted or if an illegal
                         numeral is found.
                         The parameter found is set TRUE if a number was found.
*)

@findex StringToLongInteger
PROCEDURE StringToLongInteger (s: String; base: CARDINAL; VAR found: BOOLEAN) : LONGINT ;


(*
   LongCardinalToString - converts LONGCARD, c, into a String. The field
                          width can be specified if non zero. Leading
                          characters are defined by padding.
                          The base allows the caller to generate binary,
                          octal, decimal, hexidecimal numbers.
                          The value of lower is only used when hexidecimal
                          numbers are generated and if TRUE then digits
                          abcdef are used, and if FALSE then ABCDEF are used.
*)

@findex LongCardinalToString
PROCEDURE LongCardinalToString (c: LONGCARD; width: CARDINAL; padding: CHAR;
                                base: CARDINAL; lower: BOOLEAN) : String ;


(*
   StringToLongCardinal - converts a string, s, of, base, into a LONGCARD.
                          Leading white space is ignored. It stops converting
                          when either the string is exhausted or if an illegal
                          numeral is found.
                          The parameter found is set TRUE if a number was found.
*)

@findex StringToLongCardinal
PROCEDURE StringToLongCardinal (s: String; base: CARDINAL; VAR found: BOOLEAN) : LONGCARD ;


(*
   ShortCardinalToString - converts SHORTCARD, c, into a String. The field
                           width can be specified if non zero. Leading
                           characters are defined by padding.
                           The base allows the caller to generate binary,
                           octal, decimal, hexidecimal numbers.
                           The value of lower is only used when hexidecimal
                           numbers are generated and if TRUE then digits
                           abcdef are used, and if FALSE then ABCDEF are used.
*)

@findex ShortCardinalToString
PROCEDURE ShortCardinalToString (c: SHORTCARD; width: CARDINAL; padding: CHAR;
                                 base: CARDINAL; lower: BOOLEAN) : String ;


(*
   StringToShortCardinal - converts a string, s, of, base, into a SHORTCARD.
                           Leading white space is ignored. It stops converting
                           when either the string is exhausted or if an illegal
                           numeral is found.
                           The parameter found is set TRUE if a number was found.
*)

@findex StringToShortCardinal
PROCEDURE StringToShortCardinal (s: String; base: CARDINAL;
                                 VAR found: BOOLEAN) : SHORTCARD ;


(*
   stoi - decimal string to INTEGER
*)

@findex stoi
PROCEDURE stoi (s: String) : INTEGER ;


(*
   itos - integer to decimal string.
*)

@findex itos
PROCEDURE itos (i: INTEGER; width: CARDINAL; padding: CHAR; sign: BOOLEAN) : String ;


(*
   ctos - cardinal to decimal string.
*)

@findex ctos
PROCEDURE ctos (c: CARDINAL; width: CARDINAL; padding: CHAR) : String ;


(*
   stoc - decimal string to CARDINAL
*)

@findex stoc
PROCEDURE stoc (s: String) : CARDINAL ;


(*
   hstoi - hexidecimal string to INTEGER
*)

@findex hstoi
PROCEDURE hstoi (s: String) : INTEGER ;


(*
   ostoi - octal string to INTEGER
*)

@findex ostoi
PROCEDURE ostoi (s: String) : INTEGER ;


(*
   bstoi - binary string to INTEGER
*)

@findex bstoi
PROCEDURE bstoi (s: String) : INTEGER ;


(*
   hstoc - hexidecimal string to CARDINAL
*)

@findex hstoc
PROCEDURE hstoc (s: String) : CARDINAL ;


(*
   ostoc - octal string to CARDINAL
*)

@findex ostoc
PROCEDURE ostoc (s: String) : CARDINAL ;


(*
   bstoc - binary string to CARDINAL
*)

@findex bstoc
PROCEDURE bstoc (s: String) : CARDINAL ;


(*
   StringToLongreal - returns a LONGREAL and sets found to TRUE
                      if a legal number is seen.
*)

@findex StringToLongreal
PROCEDURE StringToLongreal (s: String; VAR found: BOOLEAN) : LONGREAL ;


(*
   LongrealToString - converts a LONGREAL number, Real, which has,
                      TotalWidth, and FractionWidth into a string.
*)

@findex LongrealToString
PROCEDURE LongrealToString (x: LONGREAL;
                            TotalWidth, FractionWidth: CARDINAL) : String ;


(*
   stor - returns a REAL given a string.
*)

@findex stor
PROCEDURE stor (s: String) : REAL ;


(*
   stolr - returns a LONGREAL given a string.
*)

@findex stolr
PROCEDURE stolr (s: String) : LONGREAL ;


END StringConvert.
@end example
@page


@node gm2-libs/SysStorage, gm2-libs/TimeString, gm2-libs/StringConvert, Base libraries
@subsection gm2-libs/SysStorage

@example
DEFINITION MODULE SysStorage ;

(*
    Description: provides dynamic allocation for the system components
                 of a realtime system. This allows the application to
                 use the traditional Storage module which can be
                 handled differently.
*)

FROM SYSTEM IMPORT ADDRESS ;
EXPORT QUALIFIED ALLOCATE, DEALLOCATE, REALLOCATE, Available, Init ;


(*
   ALLOCATE - attempt to allocate memory from the heap.
              NIL is returned in, a, if ALLOCATE fails.
*)

@findex ALLOCATE
PROCEDURE ALLOCATE (VAR a: ADDRESS ; Size: CARDINAL) ;


(*
   DEALLOCATE - return, Size, bytes to the heap.
                The variable, a, is set to NIL.
*)

@findex DEALLOCATE
PROCEDURE DEALLOCATE (VAR a: ADDRESS ; Size: CARDINAL) ;


(*
   REALLOCATE - attempts to reallocate storage. The address,
                a, should either be NIL in which case ALLOCATE
                is called, or alternatively it should have already
                been initialized by ALLOCATE. The allocated storage
                is resized accordingly.
*)

@findex REALLOCATE
PROCEDURE REALLOCATE (VAR a: ADDRESS; Size: CARDINAL) ;


(*
   Available - returns TRUE if, Size, bytes can be allocated.
*)

@findex Available
PROCEDURE Available (Size: CARDINAL) : BOOLEAN;


(*
   Init - initializes the heap.
*)

@findex Init
PROCEDURE Init ;


END SysStorage.

@end example
@page


@node gm2-libs/TimeString, gm2-libs/UnixArgs, gm2-libs/SysStorage, Base libraries
@subsection gm2-libs/TimeString

@example
DEFINITION MODULE TimeString ;

(*
    Description: Provides time related string manipulation procedures.
*)


EXPORT QUALIFIED GetTimeString ;


(*
   GetTimeString - places the time in ascii format into array, a.

*)

@findex GetTimeString
PROCEDURE GetTimeString (VAR a: ARRAY OF CHAR) ;


END TimeString.
@end example
@page


@node gm2-libs/UnixArgs, gm2-libs/cbuiltin, gm2-libs/TimeString, Base libraries
@subsection gm2-libs/UnixArgs

@example
DEFINITION MODULE UnixArgs ;

(*
   Description: Implements access to the C arguments argc and argv.
*)

FROM SYSTEM IMPORT ADDRESS ;

EXPORT QUALIFIED ArgC, ArgV ;


VAR
   ArgC: CARDINAL ;
   ArgV: ADDRESS ;


END UnixArgs.
@end example
@page


@node gm2-libs/cbuiltin, gm2-libs/libc, gm2-libs/UnixArgs, Base libraries
@subsection gm2-libs/cbuiltin

@example
DEFINITION MODULE FOR "C" cbuiltin ;

(*
    Description: provides replacement routines in case the builtins are
                 not used by GNU Modula-2. This module is called by
                 implementation modules which implement builtins
                 (see Builtins.mod for an example).
*)

FROM SYSTEM IMPORT ADDRESS ;
EXPORT UNQUALIFIED alloca, memcpy,
                   sinf, sinl, sin,
                   cosf, cosl, cos,
                   sqrtf, sqrtl, sqrt,
                   fabsf, fabsl, fabs,
                   logf, logl, log,
                   expf, expl, exp,
                   index, rindex,
                   memcmp, memset,
                   strcat, strncat, strcpy, strncpy, strcmp, strncmp,
                   strlen, strstr, strpbrk, strspn, strcspn, strchr, strrchr ;

@findex alloca
PROCEDURE alloca (i: CARDINAL) : ADDRESS ;
@findex memcpy
PROCEDURE memcpy (dest, src: ADDRESS; n: CARDINAL) : ADDRESS ;
@findex sinf
PROCEDURE sinf (x: SHORTREAL) : SHORTREAL ;
@findex sin
PROCEDURE sin (x: REAL) : REAL ;
@findex sinl
PROCEDURE sinl (x: LONGREAL) : LONGREAL ;
@findex cosf
PROCEDURE cosf (x: SHORTREAL) : SHORTREAL ;
@findex cos
PROCEDURE cos (x: REAL) : REAL ;
@findex cosl
PROCEDURE cosl (x: LONGREAL) : LONGREAL ;
@findex sqrtf
PROCEDURE sqrtf (x: SHORTREAL) : SHORTREAL ;
@findex sqrt
PROCEDURE sqrt (x: REAL) : REAL ;
@findex sqrtl
PROCEDURE sqrtl (x: LONGREAL) : LONGREAL ;
@findex fabsf
PROCEDURE fabsf (x: SHORTREAL) : SHORTREAL ;
@findex fabs
PROCEDURE fabs (x: REAL) : REAL ;
@findex fabsl
PROCEDURE fabsl (x: LONGREAL) : LONGREAL ;
@findex logf
PROCEDURE logf (x: SHORTREAL) : SHORTREAL ;
@findex log
PROCEDURE log (x: REAL) : REAL ;
@findex logl
PROCEDURE logl (x: LONGREAL) : LONGREAL ;
@findex expf
PROCEDURE expf (x: SHORTREAL) : SHORTREAL ;
@findex exp
PROCEDURE exp (x: REAL) : REAL ;
@findex expl
PROCEDURE expl (x: LONGREAL) : LONGREAL ;
@findex index
PROCEDURE index (s: ADDRESS; c: INTEGER) : ADDRESS ;
@findex rindex
PROCEDURE rindex (s: ADDRESS; c: INTEGER) : ADDRESS ;
@findex memcmp
PROCEDURE memcmp (s1, s2: ADDRESS; n: CARDINAL) : INTEGER ;
@findex memset
PROCEDURE memset (s: ADDRESS; c: INTEGER; n: CARDINAL) : ADDRESS ;
@findex strcat
PROCEDURE strcat (dest, src: ADDRESS) : ADDRESS ;
@findex strncat
PROCEDURE strncat (dest, src: ADDRESS; n: CARDINAL) : ADDRESS ;
@findex strcpy
PROCEDURE strcpy (dest, src: ADDRESS) : ADDRESS ;
@findex strncpy
PROCEDURE strncpy (dest, src: ADDRESS; n: CARDINAL) : ADDRESS ;
@findex strcmp
PROCEDURE strcmp (s1, s2: ADDRESS) : INTEGER ;
@findex strncmp
PROCEDURE strncmp (s1, s2: ADDRESS; n: CARDINAL) : INTEGER ;
@findex strlen
PROCEDURE strlen (s: ADDRESS) : INTEGER ;
@findex strstr
PROCEDURE strstr (haystack, needle: ADDRESS) : ADDRESS ;
@findex strpbrk
PROCEDURE strpbrk (s, accept: ADDRESS) : ADDRESS ;
@findex strspn
PROCEDURE strspn (s, accept: ADDRESS) : CARDINAL ;
@findex strcspn
PROCEDURE strcspn (s, accept: ADDRESS) : CARDINAL ;
@findex strchr
PROCEDURE strchr (s: ADDRESS; c: INTEGER) : ADDRESS ;
@findex strrchr
PROCEDURE strrchr (s: ADDRESS; c: INTEGER) : ADDRESS ;

END cbuiltin.
@end example
@page


@node gm2-libs/libc, gm2-libs/libm, gm2-libs/cbuiltin, Base libraries
@subsection gm2-libs/libc

@example
DEFINITION MODULE FOR "C" libc ;

(*
   Description: Provides an interface to the C library functions.
*)

FROM SYSTEM IMPORT ADDRESS ;

EXPORT UNQUALIFIED write, read,
                   system, abort,
                   malloc, free,
                   exit, isatty,
                   getenv, getpid,
                   dup, close, open, lseek,
                   readv, writev,
                   perror, creat,
                   getcwd, chown, strlen, strcpy, strncpy,
                   unlink,
                   memcpy, memset, printf, realloc ;


(*
     int write(d, buf, nbytes)
     int d;
     char *buf;
     int nbytes;
*)

@findex write
PROCEDURE write (d: INTEGER; buf: ADDRESS; nbytes: INTEGER) : INTEGER ;


(*
     int read(d, buf, nbytes)
     int d;
     char *buf;
     int nbytes;
*)

@findex read
PROCEDURE read (d: INTEGER; buf: ADDRESS; nbytes: INTEGER) : INTEGER ;


(*
     int system(string)
     char *string;
*)

@findex system
PROCEDURE system (a: ADDRESS) : INTEGER ;


(*
     abort - generate a fault

     abort() first closes all open files if possible, then sends
     an IOT signal to the process.  This signal usually results
     in termination with a core dump, which may be used for
     debugging.

     It is possible for abort() to return control if is caught or
     ignored, in which case the value returned is that of the
     kill(2V) system call.
*)

@findex abort
PROCEDURE abort ;


(*
     malloc - memory allocator.

     char *malloc(size)
     unsigned size;

     malloc() returns a pointer to a block of at least size
     bytes, which is appropriately aligned.  If size is zero,
     malloc() returns a non-NULL pointer, but this pointer should
     not be dereferenced.
*)

@findex malloc
PROCEDURE malloc (size: CARDINAL) : ADDRESS ;


(*
     free - memory deallocator.

     free(ptr)
     char *ptr;

     free() releases a previously allocated block.  Its argument
     is a pointer to a block previously allocated by malloc,
     calloc, realloc, malloc, or memalign.
*)

@findex free
PROCEDURE free (ptr: ADDRESS) ;


(*
     void *realloc(void *ptr, size_t size);

     realloc changes the size of the memory block pointed to
     by ptr to size bytes. The contents will be  unchanged  to
     the minimum of the old and new sizes; newly allocated memory
     will be uninitialized. If ptr is NIL, the call is
     equivalent  to malloc(size); if size is equal to zero, the
     call is equivalent to free(ptr). Unless ptr is NIL, it
     must have been returned by an earlier call to malloc(),
     realloc.
*)

@findex realloc
PROCEDURE realloc (ptr: ADDRESS; size: CARDINAL) : ADDRESS ;


(*
   isatty - does this descriptor refer to a terminal.
*)

@findex isatty
PROCEDURE isatty (fd: INTEGER) : INTEGER ;


(*
   exit - returns control to the invoking process. Result, r, is
          returned.
*)

@findex exit
PROCEDURE exit (r: INTEGER) ;


(*
   getenv - returns the C string for the equivalent C environment
            variable.
*)

@findex getenv
PROCEDURE getenv (s: ADDRESS) : ADDRESS ;


(*
   getpid - returns the UNIX process identification number.
*)

@findex getpid
PROCEDURE getpid () : INTEGER ;


(*
   dup - duplicates the file descriptor, d.
*)

@findex dup
PROCEDURE dup (d: INTEGER) : INTEGER ;


(*
   close - closes the file descriptor, d.
*)

@findex close
PROCEDURE close (d: INTEGER) : INTEGER ;


(*
   open - open the file, filename with flag and mode.
*)

@findex open
PROCEDURE open (filename: ADDRESS; flag, mode: CARDINAL) : INTEGER ;


(*
   creat - creates a new file
*)

@findex creat
PROCEDURE creat (filename : ADDRESS; mode : CARDINAL) : INTEGER;


(*
   lseek - calls unix lseek:

           off_t lseek(int fildes, off_t offset, int whence);
*)

@findex lseek
PROCEDURE lseek (fd: INTEGER; offset: INTEGER; whence: INTEGER) : INTEGER ;


(*
   perror - writes errno and string
*)

@findex perror
PROCEDURE perror (string: ADDRESS);


(*
   readv - reads an io vector of bytes.
*)

@findex readv
PROCEDURE readv (fd: INTEGER; v: ADDRESS; n: INTEGER) : INTEGER ;


(*
   writev - writes an io vector of bytes.
*)

@findex writev
PROCEDURE writev (fd: INTEGER; v: ADDRESS; n: INTEGER) : INTEGER ;


(*
   getcwd - copies the absolute pathname of the
            current working directory to the array pointed to by buf,
            which is of length size.

            If the current absolute path name would require a buffer
            longer than size elements, NULL is returned, and errno is
            set to ERANGE; an application should check for this error,
            and allocate a larger buffer if necessary.
*)

@findex getcwd
PROCEDURE getcwd (buf: ADDRESS; size: INTEGER) : ADDRESS ;


(*
   chown - The  owner  of  the  file  specified  by  path or by fd is
           changed.  Only the super-user may change the  owner  of  a
           file.   The  owner  of  a file may change the group of the
           file to any group of which that owner is  a  member.   The
           super-user may change the group arbitrarily.

           If  the owner or group is specified as -1, then that ID is
           not changed.

           On success, zero is returned.  On error, -1  is  returned,
           and errno is set appropriately.
*)

@findex chown
PROCEDURE chown (filename: ADDRESS; uid, gid: INTEGER) : INTEGER ;


(*
   strlen - returns the length of string, a.
*)

@findex strlen
PROCEDURE strlen (a: ADDRESS) : INTEGER ;


(*
   strcpy - copies string, src, into, dest.
            It returns dest.
*)

@findex strcpy
PROCEDURE strcpy (dest, src: ADDRESS) : ADDRESS ;


(*
   strncpy - copies string, src, into, dest, copying at most, n, bytes.
             It returns dest.
*)

@findex strncpy
PROCEDURE strncpy (dest, src: ADDRESS; n: CARDINAL) : ADDRESS ;


(*
   unlink - removes file and returns 0 if successful.
*)

@findex unlink
PROCEDURE unlink (file: ADDRESS) : INTEGER ;


(*
   memcpy - copy memory area

   SYNOPSIS

   #include <string.h>

   void *memcpy(void *dest, const void *src, size_t n);
   It returns dest.
*)

@findex memcpy
PROCEDURE memcpy (dest, src: ADDRESS; size: CARDINAL) : ADDRESS ;


(*
   memset - fill memory with a constant byte

   SYNOPSIS

   #include <string.h>

   void *memset(void *s, int c, size_t n);
*)

@findex memset
PROCEDURE memset (s: ADDRESS; c: INTEGER; size: CARDINAL) : ADDRESS ;


(*
   int printf(const char *format, ...);
*)

@findex printf
PROCEDURE printf (format: ARRAY OF CHAR; ...) : INTEGER ;


END libc.
@end example
@page


@node gm2-libs/libm, gm2-libs/wrapc, gm2-libs/libc, Base libraries
@subsection gm2-libs/libm

@example
DEFINITION MODULE FOR "C" libm ;

(*
    Description: provides access to libm. Users are strongly advised to
                 use MathLib0 or RealMath as call to functions within
                 these modules will generate inline code. This module
                 is used by MathLib0 and RealMath when inline code cannot
                 be generated.
*)

EXPORT UNQUALIFIED sin, sinl, sinf,
                   cos, cosl, cosf,
                   tan, tanl, tanf,
                   sqrt, sqrtl, sqrtf,
                   asin, asinl, asinf,
                   acos, acosl, acosf,
                   atan, atanl, atanf,
                   exp, expl, expf,
                   log, logl, logf,
                   pow, powl, powf ;

@findex sin
PROCEDURE sin (x: REAL) : REAL ;
@findex sinl
PROCEDURE sinl (x: LONGREAL) : LONGREAL ;
@findex sinf
PROCEDURE sinf (x: SHORTREAL) : SHORTREAL ;
@findex cos
PROCEDURE cos (x: REAL) : REAL ;
@findex cosl
PROCEDURE cosl (x: LONGREAL) : LONGREAL ;
@findex cosf
PROCEDURE cosf (x: SHORTREAL) : SHORTREAL ;
@findex tan
PROCEDURE tan (x: REAL) : REAL ;
@findex tanl
PROCEDURE tanl (x: LONGREAL) : LONGREAL ;
@findex tanf
PROCEDURE tanf (x: SHORTREAL) : SHORTREAL ;
@findex sqrt
PROCEDURE sqrt (x: REAL) : REAL ;
@findex sqrtl
PROCEDURE sqrtl (x: LONGREAL) : LONGREAL ;
@findex sqrtf
PROCEDURE sqrtf (x: SHORTREAL) : SHORTREAL ;
@findex asin
PROCEDURE asin (x: REAL) : REAL ;
@findex asinl
PROCEDURE asinl (x: LONGREAL) : LONGREAL ;
@findex asinf
PROCEDURE asinf (x: SHORTREAL) : SHORTREAL ;
@findex acos
PROCEDURE acos (x: REAL) : REAL ;
@findex acosl
PROCEDURE acosl (x: LONGREAL) : LONGREAL ;
@findex acosf
PROCEDURE acosf (x: SHORTREAL) : SHORTREAL ;
@findex atan
PROCEDURE atan (x: REAL) : REAL ;
@findex atanl
PROCEDURE atanl (x: LONGREAL) : LONGREAL ;
@findex atanf
PROCEDURE atanf (x: SHORTREAL) : SHORTREAL ;
@findex exp
PROCEDURE exp (x: REAL) : REAL ;
@findex expl
PROCEDURE expl (x: LONGREAL) : LONGREAL ;
@findex expf
PROCEDURE expf (x: SHORTREAL) : SHORTREAL ;
@findex log
PROCEDURE log (x: REAL) : REAL ;
@findex logl
PROCEDURE logl (x: LONGREAL) : LONGREAL ;
@findex logf
PROCEDURE logf (x: SHORTREAL) : SHORTREAL ;
@findex pow
PROCEDURE pow (x, y: REAL) : REAL ;
@findex powl
PROCEDURE powl (x, y: LONGREAL) : LONGREAL ;
@findex powf
PROCEDURE powf (x, y: SHORTREAL) : SHORTREAL ;
@findex floor
PROCEDURE floor (x: REAL) : REAL ;
@findex floorl
PROCEDURE floorl (x: LONGREAL) : LONGREAL ;
@findex floorf
PROCEDURE floorf (x: SHORTREAL) : SHORTREAL ;
@findex ceil
PROCEDURE ceil (x: REAL) : REAL ;
@findex ceill
PROCEDURE ceill (x: LONGREAL) : LONGREAL ;
@findex ceilf
PROCEDURE ceilf (x: SHORTREAL) : SHORTREAL ;

END libm.
@end example
@page


@node gm2-libs/wrapc, , gm2-libs/libm, Base libraries
@subsection gm2-libs/wrapc

@example
DEFINITION MODULE wrapc ;

(*
   Description: Provides a Modula-2 interface to the C
                library functionality.
*)

FROM SYSTEM IMPORT ADDRESS ;

EXPORT QUALIFIED strtime, filesize, getrand, getusername, filemtime,
                 getnameuidgid ;


(*
   strtime - returns the C string for the equivalent C asctime
             function.
*)

@findex strtime
PROCEDURE strtime () : ADDRESS ;


(*
   filesize - returns the size of a file, f.
*)

@findex filesize
PROCEDURE filesize (f: INTEGER) : CARDINAL ;


(*
   filemtime - returns the mtime of a file, f.
*)

@findex filemtime
PROCEDURE filemtime (f: INTEGER) : INTEGER ;


(*
   getrand - returns a random number between 0..n-1
*)

@findex getrand
PROCEDURE getrand (n: INTEGER) : INTEGER ;


(*
   getusername - returns a C string describing the current user.
*)

@findex getusername
PROCEDURE getusername () : ADDRESS ;


(*
   getnameuidgid - fills in the, uid, and, gid, which represents
                   user, name.
*)

@findex getnameuidgid
PROCEDURE getnameuidgid (name: ADDRESS; VAR uid, gid: INTEGER) ;


END wrapc.
@end example
@page



@c ---------------------------------------------------------------------
@node PIM and Logitech 3.0 Compatible, PIM coroutine support, Base libraries, Libraries
@section PIM and Logitech 3.0 Compatible

@c Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
@c Permission is granted to copy, distribute and/or modify this document
@c under the terms of the GNU Free Documentation License, Version 1.2 or
@c any later version published by the Free Software Foundation.

These modules are provided to enable legacy Modula-2 applications to
build with GNU Modula-2. It is advised that these module should not
be used for new projects, maybe the ISO libraries or the native
compiler PIM libraries (FIO) should be used instead.

Here is an outline of the module layering:

@example

InOut  RealInOut  LongIO CardinalIO
    \     |       |      /
           Terminal
-----------------------------------
              |
           Termbase
           /      \
    Keyboard      Display

@end example

Above the line are user level PIM [234] and Logitech 3.0 compatible
modules.  Below the line Logitech 3.0 advised that these modules
should be considered part of the runtime system. The libraries do
not provide all the features found in the Logitech libraries as
a number of these features were MS-DOS related. Essentially the
basic input/output, file system, string manipulation and conversion
routines are provided. Access to DOSCALL, graphics, time and date
are not as these were constrained by the limitations of MS-DOS.

The following libraries are contained within the base GNU Modula-2
libraries but are also Logitech-3.0 compatible: ASCII and MathLib0.

@menu
* gm2-libs/ASCII::ASCII.def
* gm2-libs/MathLib0::MathLib0.def
@end menu

@menu
* gm2-libs-pim/Break::Break.def
* gm2-libs-pim/CardinalIO::CardinalIO.def
* gm2-libs-pim/Conversions::Conversions.def
* gm2-libs-pim/DebugPMD::DebugPMD.def
* gm2-libs-pim/DebugTrace::DebugTrace.def
* gm2-libs-pim/Delay::Delay.def
* gm2-libs-pim/Display::Display.def
* gm2-libs-pim/ErrorCode::ErrorCode.def
* gm2-libs-pim/FileSystem::FileSystem.def
* gm2-libs-pim/FloatingUtilies::FloatingUtilies.def
* gm2-libs-pim/InOut::InOut.def
* gm2-libs-pim/Keyboard::Keyboard.def
* gm2-libs-pim/LongIO::LongIO.def
* gm2-libs-pim/RealConversions::RealConversions.def
* gm2-libs-pim/RealInOut::RealInOut.def
* gm2-libs-pim/Termbase::Termbase.def
* gm2-libs-pim/Terminal::Terminal.def
@end menu


@node gm2-libs-pim/Break, gm2-libs-pim/CardinalIO, , PIM and Logitech 3.0 Compatible
@subsection gm2-libs-pim/Break

@example
DEFINITION MODULE Break ;

(*
    Description: provides a Logitech compatible Break handler module
                 which catches ctrl-c.
*)

EXPORT QUALIFIED EnableBreak, DisableBreak, InstallBreak, UnInstallBreak ;


(*
   EnableBreak - enable the current break handler.
*)

@findex EnableBreak
PROCEDURE EnableBreak ;


(*
   DisableBreak - disable the current break handler (and all
                  installed handlers).
*)

@findex DisableBreak
PROCEDURE DisableBreak ;


(*
   InstallBreak - installs a procedure, p, to be invoked when
                  a ctrl-c is caught. Any number of these
                  procedures may be stacked. Only the top
                  procedure is run when ctrl-c is caught.
*)

@findex InstallBreak
PROCEDURE InstallBreak (p: PROC) ;


(*
   UnInstallBreak - pops the break handler stack.
*)

@findex UnInstallBreak
PROCEDURE UnInstallBreak ;


END Break.
@end example
@page


@node gm2-libs-pim/CardinalIO, gm2-libs-pim/Conversions, gm2-libs-pim/Break, PIM and Logitech 3.0 Compatible
@subsection gm2-libs-pim/CardinalIO

@example
DEFINITION MODULE CardinalIO ;

(*
    Description: provides a PIM and Logitech compatible module.
*)

EXPORT QUALIFIED Done,
                 ReadCardinal, WriteCardinal, ReadHex, WriteHex,
                 ReadLongCardinal, WriteLongCardinal, ReadLongHex,
                 WriteLongHex,
                 ReadShortCardinal, WriteShortCardinal, ReadShortHex,
                 WriteShortHex ;


VAR
   Done: BOOLEAN ;


(*
   ReadCardinal - read an unsigned decimal number from the terminal.
                  The read continues until a space, newline, esc or
                  end of file is reached.
*)

@findex ReadCardinal
PROCEDURE ReadCardinal (VAR c: CARDINAL) ;


(*
   WriteCardinal - writes the value, c, to the terminal and ensures
                   that at least, n, characters are written. The number
                   will be padded out by preceeding spaces if necessary.
*)

@findex WriteCardinal
PROCEDURE WriteCardinal (c: CARDINAL; n: CARDINAL) ;


(*
   ReadHex - reads in an unsigned hexadecimal number from the terminal.
             The read continues until a space, newline, esc or
             end of file is reached.
*)

@findex ReadHex
PROCEDURE ReadHex (VAR c: CARDINAL) ;


(*
   WriteHex - writes out a CARDINAL, c, in hexadecimal format padding
              with, n, characters (leading with '0')
*)

@findex WriteHex
PROCEDURE WriteHex (c: CARDINAL; n: CARDINAL) ;


(*
   ReadLongCardinal - read an unsigned decimal number from the terminal.
                      The read continues until a space, newline, esc or
                      end of file is reached.
*)

@findex ReadLongCardinal
PROCEDURE ReadLongCardinal (VAR c: LONGCARD) ;


(*
   WriteLongCardinal - writes the value, c, to the terminal and ensures
                       that at least, n, characters are written. The number
                       will be padded out by preceeding spaces if necessary.
*)

@findex WriteLongCardinal
PROCEDURE WriteLongCardinal (c: LONGCARD; n: CARDINAL) ;


(*
   ReadLongHex - reads in an unsigned hexadecimal number from the terminal.
                 The read continues until a space, newline, esc or
                 end of file is reached.
*)

@findex ReadLongHex
PROCEDURE ReadLongHex (VAR c: LONGCARD) ;


(*
   WriteLongHex - writes out a LONGCARD, c, in hexadecimal format padding
                  with, n, characters (leading with '0')
*)

@findex WriteLongHex
PROCEDURE WriteLongHex (c: LONGCARD; n: CARDINAL) ;


(*
   WriteShortCardinal - writes the value, c, to the terminal and ensures
                       that at least, n, characters are written. The number
                       will be padded out by preceeding spaces if necessary.
*)

@findex WriteShortCardinal
PROCEDURE WriteShortCardinal (c: SHORTCARD; n: CARDINAL) ;


(*
   ReadShortCardinal - read an unsigned decimal number from the terminal.
                       The read continues until a space, newline, esc or
                       end of file is reached.
*)

@findex ReadShortCardinal
PROCEDURE ReadShortCardinal (VAR c: SHORTCARD) ;


(*
   ReadShortHex - reads in an unsigned hexadecimal number from the terminal.
                 The read continues until a space, newline, esc or
                 end of file is reached.
*)

@findex ReadShortHex
PROCEDURE ReadShortHex (VAR c: SHORTCARD) ;


(*
   WriteShortHex - writes out a SHORTCARD, c, in hexadecimal format padding
                  with, n, characters (leading with '0')
*)

@findex WriteShortHex
PROCEDURE WriteShortHex (c: SHORTCARD; n: CARDINAL) ;


END CardinalIO.
@end example
@page


@node gm2-libs-pim/Conversions, gm2-libs-pim/DebugPMD, gm2-libs-pim/CardinalIO, PIM and Logitech 3.0 Compatible
@subsection gm2-libs-pim/Conversions

@example
DEFINITION MODULE Conversions ;

(*
    Description: provides a Logitech-3.0 compatible library.
*)

EXPORT QUALIFIED ConvertOctal, ConvertHex, ConvertCardinal,
                 ConvertInteger, ConvertLongInt, ConvertShortInt ;

(*
   ConvertOctal - converts a CARDINAL, num, into an octal/hex/decimal
                  string and right justifies the string. It adds
                  spaces rather than '0' to pad out the string
                  to len characters.

                  If the length of str is < num then the number is
                  truncated on the right.
*)

@findex ConvertOctal
PROCEDURE ConvertOctal    (num, len: CARDINAL; VAR str: ARRAY OF CHAR) ;
@findex ConvertHex
PROCEDURE ConvertHex      (num, len: CARDINAL; VAR str: ARRAY OF CHAR) ;
@findex ConvertCardinal
PROCEDURE ConvertCardinal (num, len: CARDINAL; VAR str: ARRAY OF CHAR) ;

(*
   The INTEGER counterparts will add a '-' if, num, is <0
*)

@findex ConvertInteger
PROCEDURE ConvertInteger  (num: INTEGER; len: CARDINAL; VAR str: ARRAY OF CHAR) ;
@findex ConvertLongInt
PROCEDURE ConvertLongInt  (num: LONGINT; len: CARDINAL; VAR str: ARRAY OF CHAR) ;
@findex ConvertShortInt
PROCEDURE ConvertShortInt (num: SHORTINT; len: CARDINAL; VAR str: ARRAY OF CHAR) ;


END Conversions.
@end example
@page


@node gm2-libs-pim/DebugPMD, gm2-libs-pim/DebugTrace, gm2-libs-pim/Conversions, PIM and Logitech 3.0 Compatible
@subsection gm2-libs-pim/DebugPMD

@example
DEFINITION MODULE DebugPMD ;

END DebugPMD.
@end example
@page


@node gm2-libs-pim/DebugTrace, gm2-libs-pim/Delay, gm2-libs-pim/DebugPMD, PIM and Logitech 3.0 Compatible
@subsection gm2-libs-pim/DebugTrace

@example
DEFINITION MODULE DebugTrace ;

(*
    Description: provides a compatible module for the
                 Logitech-3.0 PIM Modula-2 compiler.
                 It does nothing other satisfy an import for
                 legacy source code.
*)

END DebugTrace.
@end example
@page


@node gm2-libs-pim/Delay, gm2-libs-pim/Display, gm2-libs-pim/DebugTrace, PIM and Logitech 3.0 Compatible
@subsection gm2-libs-pim/Delay

@example
DEFINITION MODULE Delay ;

(*
    Description: provides a Logitech-3.0 compatible module for
                 GNU Modula-2.
*)

EXPORT QUALIFIED Delay ;


(*
   milliSec - delays the program by approximately, milliSec, milliseconds.
*)

@findex Delay
PROCEDURE Delay (milliSec: INTEGER) ;


END Delay.
@end example
@page


@node gm2-libs-pim/Display, gm2-libs-pim/ErrorCode, gm2-libs-pim/Delay, PIM and Logitech 3.0 Compatible
@subsection gm2-libs-pim/Display

@example
DEFINITION MODULE Display ;

(*
    Description: provides a Logitech 3.0 compatible Display module.
*)

EXPORT QUALIFIED Write ;

(*
   Write - display a character to the stdout.
           ASCII.EOL moves to the beginning of the next line.
           ASCII.del erases the character to the left of the cursor.
*)

@findex Write
PROCEDURE Write (ch: CHAR) ;


END Display.
@end example
@page


@node gm2-libs-pim/ErrorCode, gm2-libs-pim/FileSystem, gm2-libs-pim/Display, PIM and Logitech 3.0 Compatible
@subsection gm2-libs-pim/ErrorCode

@example
DEFINITION MODULE ErrorCode ;

(*
    Description: provides a Logitech-3.0 compatible module which
                 handles exiting from an application with an exit
                 value.
*)

EXPORT QUALIFIED SetErrorCode, GetErrorCode, ExitToOS ;


(*
   SetErrorCode - sets the exit value which will be used if
                  the application terminates normally.
*)

@findex SetErrorCode
PROCEDURE SetErrorCode (value: INTEGER) ;


(*
   GetErrorCode - returns the current value to be used upon
                  application termination.
*)

@findex GetErrorCode
PROCEDURE GetErrorCode (VAR value: INTEGER) ;


(*
   ExitToOS - terminate the application and exit returning
              the last value set by SetErrorCode to the OS.
*)

@findex ExitToOS
PROCEDURE ExitToOS ;


END ErrorCode.
@end example
@page


@node gm2-libs-pim/FileSystem, gm2-libs-pim/FloatingUtilies, gm2-libs-pim/ErrorCode, PIM and Logitech 3.0 Compatible
@subsection gm2-libs-pim/FileSystem

@example
DEFINITION MODULE FileSystem ;

(*
    Description: provides GNU Modula-2 with a PIM [234] FileSystem
                 compatible module. Use this module sparingly,
                 FIO or the ISO file modules have a much cleaner
                 interface.
*)

FROM SYSTEM IMPORT WORD, BYTE, ADDRESS ;
IMPORT FIO ;
FROM DynamicStrings IMPORT String ;

EXPORT QUALIFIED File, Response, Flag, FlagSet,

                 Create, Close, Lookup, Rename, Delete,
                 SetRead, SetWrite, SetModify, SetOpen,
                 Doio, SetPos, GetPos, Length,

                 ReadWord, ReadChar, ReadByte, ReadNBytes,
                 WriteWord, WriteChar, WriteByte, WriteNBytes ;

TYPE
   File = RECORD
             res     : Response ;
             flags   : FlagSet ;
             eof     : BOOLEAN ;
             lastRead: WORD ;
             fio     : FIO.File ;
             highpos,
             lowpos  : CARDINAL ;
             name    : String ;
          END ;

   Flag = (
           read,        (* read access mode *)
           write,       (* write access mode *)
           truncate,    (* truncate file when closed *)
           again        (* reread the last character *)
          );

   FlagSet = SET OF Flag;

   Response = (done, notdone, notsupported, callerror,
               unknownfile, paramerror, toomanyfiles,
               userdeverror) ;

   Command = (create, close, lookup, rename, delete,
              setread, setwrite, setmodify, setopen,
              doio, setpos, getpos, length) ;

(*
   Create - creates a temporary file. To make the file perminant
            the file must be renamed.
*)

@findex Create
PROCEDURE Create (VAR f: File) ;


(*
   Close - closes an open file.
*)

@findex Close
PROCEDURE Close (f: File) ;


(*
   Lookup - looks for a file, filename. If the file is found
            then, f, is opened. If it is not found and, newFile,
            is TRUE then a new file is created and attached to, f.
            If, newFile, is FALSE and no file was found then f.res
            is set to notdone.
*)

@findex Lookup
PROCEDURE Lookup (VAR f: File; filename: ARRAY OF CHAR; newFile: BOOLEAN) ;


(*
   Rename - rename a file.
            f.res is set appropriately.
*)

@findex Rename
PROCEDURE Rename (VAR f: File; newname: ARRAY OF CHAR) ;


(*
   Delete - deletes a file, name, and sets the f.res field.
            f.res is set appropriately.
*)

@findex Delete
PROCEDURE Delete (name: ARRAY OF CHAR; VAR f: File) ;


(*
   ReadWord - reads a WORD, w, from file, f.
              f.res is set appropriately.
*)

@findex ReadWord
PROCEDURE ReadWord (VAR f: File; VAR w: WORD) ;


(*
   WriteWord - writes one word to a file, f.
               f.res is set appropriately.
*)

@findex WriteWord
PROCEDURE WriteWord (VAR f: File; w: WORD) ;


(*
   ReadChar - reads one character from a file, f.
*)

@findex ReadChar
PROCEDURE ReadChar (VAR f: File; VAR ch: CHAR) ;


(*
   WriteChar - writes a character, ch, to a file, f.
               f.res is set appropriately.
*)

@findex WriteChar
PROCEDURE WriteChar (VAR f: File; ch: CHAR) ;


(*
   ReadByte - reads a BYTE, b, from file, f.
              f.res is set appropriately.
*)

@findex ReadByte
PROCEDURE ReadByte (VAR f: File; VAR b: BYTE) ;


(*
   WriteByte - writes one BYTE, b, to a file, f.
               f.res is set appropriately.
*)

@findex WriteByte
PROCEDURE WriteByte (VAR f: File; b: BYTE) ;


(*
   ReadNBytes - reads a sequence of bytes from a file, f.
*)

@findex ReadNBytes
PROCEDURE ReadNBytes (VAR f: File; a: ADDRESS; amount: CARDINAL;
                      VAR actuallyRead: CARDINAL) ;


(*
   WriteNBytes - writes a sequence of bytes to file, f.
*)

@findex WriteNBytes
PROCEDURE WriteNBytes (VAR f: File; a: ADDRESS; amount: CARDINAL;
                       VAR actuallyWritten: CARDINAL) ;


(*
   Again - returns the last character read to the internal buffer
           so that it can be read again.
*)

@findex Again
PROCEDURE Again (VAR f: File) ;


(*
   SetRead - puts the file, f, into the read state.
             The file position is unchanged.
*)

@findex SetRead
PROCEDURE SetRead (VAR f: File) ;


(*
   SetWrite - puts the file, f, into the write state.
              The file position is unchanged.
*)

@findex SetWrite
PROCEDURE SetWrite (VAR f: File) ;


(*
   SetModify - puts the file, f, into the modify state.
               The file position is unchanged but the file can be
               read and written.
*)

@findex SetModify
PROCEDURE SetModify (VAR f: File) ;


(*
   SetOpen - places a file, f, into the open state. The file may
             have been in the read/write/modify state before and
             in which case the previous buffer contents are flushed
             and the file state is reset to open. The position is
             unaltered.
*)

@findex SetOpen
PROCEDURE SetOpen (VAR f: File) ;


(*
   Reset - places a file, f, into the open state and reset the
           position to the start of the file.
*)

@findex Reset
PROCEDURE Reset (VAR f: File) ;


(*
   SetPos - lseek to a position within a file.
*)

@findex SetPos
PROCEDURE SetPos (VAR f: File; high, low: CARDINAL) ;


(*
   GetPos - return the position within a file.
*)

@findex GetPos
PROCEDURE GetPos (VAR f: File; VAR high, low: CARDINAL) ;


(*
   Length - returns the length of file, in, high, and, low.
*)

@findex Length
PROCEDURE Length (VAR f: File; VAR high, low: CARDINAL) ;


(*
   Doio - effectively flushes a file in write mode, rereads the
          current buffer from disk if in read mode and writes
          and rereads the buffer if in modify mode.
*)

@findex Doio
PROCEDURE Doio (VAR f: File) ;


(*
   FileNameChar - checks to see whether the character, ch, is
                  legal in a filename. nul is returned if the
                  character was illegal.
*)

@findex FileNameChar
PROCEDURE FileNameChar (ch: CHAR) ;


END FileSystem.
@end example
@page


@node gm2-libs-pim/FloatingUtilies, gm2-libs-pim/InOut, gm2-libs-pim/FileSystem, PIM and Logitech 3.0 Compatible
@subsection gm2-libs-pim/FloatingUtilies

@example
DEFINITION MODULE FloatingUtilies ;

(*
    Description: provides a Logitech-3.0 compatible library
*)

EXPORT QUALIFIED Frac, Round, Float, Trunc,
                 Fracl, Roundl, Floatl, Truncl ;


(*
   Frac - returns the fractional component of, r.
*)

@findex Frac
PROCEDURE Frac (r: REAL) : REAL ;


(*
   Int - returns the integer part of r. It rounds the value towards zero.
*)

@findex Int
PROCEDURE Int (r: REAL) : INTEGER ;


(*
   Round - returns the number rounded to the nearest integer.
*)

@findex Round
PROCEDURE Round (r: REAL) : REAL ;


(*
   Float - returns a REAL value corresponding to, i.
*)

@findex Float
PROCEDURE Float (i: INTEGER) : REAL ;


(*
   Trunc - round to the nearest integer not larger in absolute
           value.
*)

@findex Trunc
PROCEDURE Trunc (r: REAL) : INTEGER ;


(*
   Fracl - returns the fractional component of, r.
*)

@findex Fracl
PROCEDURE Fracl (r: LONGREAL) : LONGREAL ;


(*
   Intl - returns the integer part of r. It rounds the value towards zero.
*)

@findex Intl
PROCEDURE Intl (r: LONGREAL) : LONGINT ;


(*
   Roundl - returns the number rounded to the nearest integer.
*)

@findex Roundl
PROCEDURE Roundl (r: LONGREAL) : LONGREAL ;


(*
   Floatl - returns a REAL value corresponding to, i.
*)

@findex Floatl
PROCEDURE Floatl (i: INTEGER) : LONGREAL ;


(*
   Truncl - round to the nearest integer not larger in absolute
            value.
*)

@findex Truncl
PROCEDURE Truncl (r: LONGREAL) : LONGINT ;


END FloatingUtilies.
@end example
@page


@node gm2-libs-pim/InOut, gm2-libs-pim/Keyboard, gm2-libs-pim/FloatingUtilies, PIM and Logitech 3.0 Compatible
@subsection gm2-libs-pim/InOut

@example
DEFINITION MODULE InOut ;

(*
    Description: provides a compatible PIM [234] InOut module.
*)

IMPORT ASCII ;
FROM DynamicStrings IMPORT String ;
EXPORT QUALIFIED EOL, Done, termCH, OpenInput, CloseInput, CloseOutput,
                 Read, ReadString, ReadInt, ReadCard,
                 Write, WriteLn, WriteString, WriteInt, WriteCard,
                 WriteOct, WriteHex,
                 ReadS, WriteS ;

CONST
   EOL = ASCII.EOL ;

VAR
   Done  : BOOLEAN ;
   termCH: CHAR ;


(*
   OpenInput - reads a string from stdin as the filename for reading.
               If the filename ends with `.' then it appends the defext
               extension. The global variable Done is set if all
               was successful.
*)

@findex OpenInput
PROCEDURE OpenInput (defext: ARRAY OF CHAR) ;


(*
   CloseInput - closes an opened input file and returns input back to
                StdIn.
*)

@findex CloseInput
PROCEDURE CloseInput ;


(*
   OpenOutput - reads a string from stdin as the filename for writing.
                If the filename ends with `.' then it appends the defext
                extension. The global variable Done is set if all
                was successful.
*)

@findex OpenOutput
PROCEDURE OpenOutput (defext: ARRAY OF CHAR) ;


(*
   CloseOutput - closes an opened output file and returns output back to
                 StdOut.
*)

@findex CloseOutput
PROCEDURE CloseOutput ;


(*
   Read - reads a single character from the current input file.
          Done is set to FALSE if end of file is reached or an
          error occurs.
*)

@findex Read
PROCEDURE Read (VAR ch: CHAR) ;


(*
   ReadString - reads a sequence of characters. Leading white space
                is ignored and the string is terminated with a character
                <= ' '
*)

@findex ReadString
PROCEDURE ReadString (VAR s: ARRAY OF CHAR) ;


(*
   WriteString - writes a string to the output file.
*)

@findex WriteString
PROCEDURE WriteString (s: ARRAY OF CHAR) ;


(*
   Write - writes out a single character, ch, to the current output file.
*)

@findex Write
PROCEDURE Write (ch: CHAR) ;


(*
   WriteLn - writes a newline to the output file.
*)

@findex WriteLn
PROCEDURE WriteLn ;


(*
   ReadInt - reads a string and converts it into an INTEGER, x.
             Done is set if an INTEGER is read.
*)

@findex ReadInt
PROCEDURE ReadInt (VAR x: INTEGER) ;


(*
   ReadInt - reads a string and converts it into an INTEGER, x.
             Done is set if an INTEGER is read.
*)

@findex ReadCard
PROCEDURE ReadCard (VAR x: CARDINAL) ;


(*
   WriteCard - writes the CARDINAL, x, to the output file. It ensures
               that the number occupies, n, characters. Leading spaces
               are added if required.
*)

@findex WriteCard
PROCEDURE WriteCard (x, n: CARDINAL) ;


(*
   WriteInt - writes the INTEGER, x, to the output file. It ensures
              that the number occupies, n, characters. Leading spaces
              are added if required.
*)

@findex WriteInt
PROCEDURE WriteInt (x: INTEGER; n: CARDINAL) ;


(*
   WriteOct - writes the CARDINAL, x, to the output file in octal.
              It ensures that the number occupies, n, characters.
              Leading spaces are added if required.
*)

@findex WriteOct
PROCEDURE WriteOct (x, n: CARDINAL) ;


(*
   WriteHex - writes the CARDINAL, x, to the output file in hexadecimal.
              It ensures that the number occupies, n, characters.
              Leading spaces are added if required.
*)

@findex WriteHex
PROCEDURE WriteHex (x, n: CARDINAL) ;


(*
   ReadS - returns a string which has is a sequence of characters.
           The string is terminated with a character <= ' '
*)

@findex ReadS
PROCEDURE ReadS () : String ;


(*
   WriteS - writes a String to the output device.
            It returns the string, s.
*)

@findex WriteS
PROCEDURE WriteS (s: String) : String ;


END InOut.
@end example
@page


@node gm2-libs-pim/Keyboard, gm2-libs-pim/LongIO, gm2-libs-pim/InOut, PIM and Logitech 3.0 Compatible
@subsection gm2-libs-pim/Keyboard

@example
DEFINITION MODULE Keyboard ;

(*
    Description: provides compatibility with Logitech 3.0 Keyboard module.
*)

EXPORT QUALIFIED Read, KeyPressed ;


(*
   Read - reads a character from StdIn. If necessary it will wait
          for a key to become present on StdIn.
*)

@findex Read
PROCEDURE Read (VAR ch: CHAR) ;


(*
   KeyPressed - returns TRUE if a character can be read from StdIn
                without blocking the caller.
*)

@findex KeyPressed
PROCEDURE KeyPressed () : BOOLEAN ;


END Keyboard.
@end example
@page


@node gm2-libs-pim/LongIO, gm2-libs-pim/RealConversions, gm2-libs-pim/Keyboard, PIM and Logitech 3.0 Compatible
@subsection gm2-libs-pim/LongIO

@example
DEFINITION MODULE LongIO ;

(*
    Description: provides a Logitech-3.0 compatible library for GNU Modula-2.
*)

EXPORT QUALIFIED Done, ReadLongInt, WriteLongInt ;

VAR
   Done: BOOLEAN ;

@findex ReadLongInt
PROCEDURE ReadLongInt (VAR i: LONGINT) ;
@findex WriteLongInt
PROCEDURE WriteLongInt (i: LONGINT; n: CARDINAL) ;


END LongIO.
@end example
@page


@node gm2-libs-pim/RealConversions, gm2-libs-pim/RealInOut, gm2-libs-pim/LongIO, PIM and Logitech 3.0 Compatible
@subsection gm2-libs-pim/RealConversions

@example
DEFINITION MODULE RealConversions ;

(*
    Description: provides a Logitech-3.0 compatible module.
*)

EXPORT QUALIFIED RealToString, StringToReal,
                 LongRealToString, StringToLongReal ;


(*
   RealToString - converts a real, r, into a right justified string, str.
                  The number of digits to the right of the decimal point
                  is given in, digits. The value, width, represents the
                  maximum number of characters to be used in the string,
                  str.

                  If digits is negative then exponent notation is used
                  whereas if digits is positive then fixed point notation
                  is used.

                  If, r, is less than 0.0 then a '-' preceeds the value,
                  str. However, if, r, is >= 0.0 a '+' is not added.

                  If the conversion of, r, to a string requires more
                  than, width, characters then the string, str, is set
                  to a nul string and, ok is assigned FALSE.

                  For fixed point notation the minimum width required is
                  ABS(width)+8

                  For exponent notation the minimum width required is
                  ABS(width)+2+ the number of digits to the left of the
                  decimal point.
*)

@findex RealToString
PROCEDURE RealToString (r: REAL; digits: INTEGER; width : CARDINAL;
                        VAR str: ARRAY OF CHAR; VAR ok: BOOLEAN) ;


(*
   LongRealToString - converts a real, r, into a right justified string, str.
                      The number of digits to the right of the decimal point
                      is given in, digits. The value, width, represents the
                      maximum number of characters to be used in the string,
                      str.

                      If digits is negative then exponent notation is used
                      whereas if digits is positive then fixed point notation
                      is used.

                      If, r, is less than 0.0 then a '-' preceeds the value,
                      str. However, if, r, is >= 0.0 a '+' is not added.

                      If the conversion of, r, to a string requires more
                      than, width, characters then the string, str, is set
                      to a nul string and, ok is assigned FALSE.

                      For fixed point notation the minimum width required is
                      ABS(width)+8

                      For exponent notation the minimum width required is
                      ABS(width)+2+ the number of digits to the left of the
                      decimal point.
*)

@findex LongRealToString
PROCEDURE LongRealToString (r: LONGREAL; digits: INTEGER; width : CARDINAL;
                            VAR str: ARRAY OF CHAR; VAR ok: BOOLEAN) ;


(*
   StringToReal - converts, str, into a REAL, r. The parameter, ok, is
                  set to TRUE if the conversion was successful.
*)

@findex StringToReal
PROCEDURE StringToReal (str: ARRAY OF CHAR; VAR r: REAL; VAR ok: BOOLEAN) ;


(*
   StringToLongReal - converts, str, into a LONGREAL, r. The parameter, ok, is
                      set to TRUE if the conversion was successful.
*)

@findex StringToLongReal
PROCEDURE StringToLongReal (str: ARRAY OF CHAR; VAR r: LONGREAL; VAR ok: BOOLEAN) ;


END RealConversions.
@end example
@page


@node gm2-libs-pim/RealInOut, gm2-libs-pim/Termbase, gm2-libs-pim/RealConversions, PIM and Logitech 3.0 Compatible
@subsection gm2-libs-pim/RealInOut

@example
DEFINITION MODULE RealInOut ;

(*
    Description: provides a compatible RealInOut PIM 234 module.
*)

EXPORT QUALIFIED ReadReal, WriteReal, WriteRealOct, Done ;

VAR
   Done: BOOLEAN ;


(*
   ReadReal - reads a real number, legal syntaxes include:
              100, 100.0, 100e0, 100E0, 100E-1, E2, +1E+2, 1e+2
*)

@findex ReadReal
PROCEDURE ReadReal (VAR x: REAL) ;


(*
   WriteReal - writes a real to the terminal. The real number
               is right justified and, n, is the minimum field
               width.
*)

@findex WriteReal
PROCEDURE WriteReal (x: REAL; n: CARDINAL) ;


(*
   WriteRealOct - writes the real to terminal in octal words.
*)

@findex WriteRealOct
PROCEDURE WriteRealOct (x: REAL) ;


(*
   ReadLongReal - reads a LONGREAL number, legal syntaxes include:
                  100, 100.0, 100e0, 100E0, 100E-1, E2, +1E+2, 1e+2
*)

@findex ReadLongReal
PROCEDURE ReadLongReal (VAR x: LONGREAL) ;


(*
   WriteLongReal - writes a LONGREAL to the terminal. The real number
                   is right justified and, n, is the minimum field
                   width.
*)

@findex WriteLongReal
PROCEDURE WriteLongReal (x: LONGREAL; n: CARDINAL) ;


(*
   WriteLongRealOct - writes the LONGREAL to terminal in octal words.
*)

@findex WriteLongRealOct
PROCEDURE WriteLongRealOct (x: LONGREAL) ;


(*
   ReadShortReal - reads a SHORTREAL number, legal syntaxes include:
                  100, 100.0, 100e0, 100E0, 100E-1, E2, +1E+2, 1e+2
*)

@findex ReadShortReal
PROCEDURE ReadShortReal (VAR x: SHORTREAL) ;


(*
   WriteShortReal - writes a SHORTREAL to the terminal. The real number
                   is right justified and, n, is the minimum field
                   width.
*)

@findex WriteShortReal
PROCEDURE WriteShortReal (x: SHORTREAL; n: CARDINAL) ;


(*
   WriteShortRealOct - writes the SHORTREAL to terminal in octal words.
*)

@findex WriteShortRealOct
PROCEDURE WriteShortRealOct (x: SHORTREAL) ;


END RealInOut.
@end example
@page


@node gm2-libs-pim/Termbase, gm2-libs-pim/Terminal, gm2-libs-pim/RealInOut, PIM and Logitech 3.0 Compatible
@subsection gm2-libs-pim/Termbase

@example
DEFINITION MODULE Termbase ;

(*
    Description: provides GNU Modula-2 with a PIM 234 compatible Termbase
                 module. Definition module complies with Logitech 3.0.
                 Initially the read routines from Keyboard and the
                 write routine from Display is assigned to the Read,
                 KeyPressed and Write procedures.
*)

EXPORT QUALIFIED ReadProcedure, StatusProcedure, WriteProcedure,
                 AssignRead, AssignWrite, UnAssignRead, UnAssignWrite,
                 Read, KeyPressed, Write ;

TYPE
   ReadProcedure = PROCEDURE (VAR CHAR) ;
   WriteProcedure = PROCEDURE (CHAR) ;
   StatusProcedure = PROCEDURE () : BOOLEAN ;


(*
   AssignRead - assigns a read procedure and status procedure for terminal
                input. Done is set to TRUE if successful. Subsequent
                Read and KeyPressed calls are mapped onto the user supplied
                procedures. The previous read and status procedures are
                uncovered and reused after UnAssignRead is called.
*)

@findex AssignRead
PROCEDURE AssignRead (rp: ReadProcedure; sp: StatusProcedure;
                      VAR Done: BOOLEAN) ;


(*
   UnAssignRead - undo the last call to AssignRead and set Done to TRUE
                  on success.
*)

@findex UnAssignRead
PROCEDURE UnAssignRead (VAR Done: BOOLEAN) ;


(*
   Read - reads a single character using the currently active read
          procedure.
*)

@findex Read
PROCEDURE Read (VAR ch: CHAR) ;


(*
   KeyPressed - returns TRUE if a character is available to be read.
*)

@findex KeyPressed
PROCEDURE KeyPressed () : BOOLEAN ;


(*
   AssignWrite - assigns a write procedure for terminal output.
                 Done is set to TRUE if successful. Subsequent
                 Write calls are mapped onto the user supplied
                 procedure. The previous write procedure is
                 uncovered and reused after UnAssignWrite is called.
*)

@findex AssignWrite
PROCEDURE AssignWrite (wp: WriteProcedure; VAR Done: BOOLEAN) ;


(*
   UnAssignWrite - undo the last call to AssignWrite and set Done to TRUE
                   on success.
*)

@findex UnAssignWrite
PROCEDURE UnAssignWrite (VAR Done: BOOLEAN) ;


(*
   Write - writes a single character using the currently active write
           procedure.
*)

@findex Write
PROCEDURE Write (VAR ch: CHAR) ;


END Termbase.
@end example
@page


@node gm2-libs-pim/Terminal, , gm2-libs-pim/Termbase, PIM and Logitech 3.0 Compatible
@subsection gm2-libs-pim/Terminal

@example
DEFINITION MODULE Terminal ;

(*
    Description: provides a Logitech 3.0 compatible and PIM [234] compatible
                 Terminal module. It provides simple terminal input output
                 routines which all utilize the TermBase module.
*)

EXPORT QUALIFIED Read, KeyPressed, ReadAgain, ReadString, Write,
                 WriteString, WriteLn ;


(*
   Read - reads a single character.
*)

@findex Read
PROCEDURE Read (VAR ch: CHAR) ;


(*
   KeyPressed - returns TRUE if a character can be read without blocking
                the caller.
*)

@findex KeyPressed
PROCEDURE KeyPressed () : BOOLEAN ;


(*
   ReadString - reads a sequence of characters.
                Tabs are expanded into 8 spaces and <cr> or <lf> terminates
                the string.
*)

@findex ReadString
PROCEDURE ReadString (VAR s: ARRAY OF CHAR) ;


(*
   ReadAgain - makes the last character readable again.
*)

@findex ReadAgain
PROCEDURE ReadAgain ;


(*
   Write - writes a single character to the Termbase module.
*)

@findex Write
PROCEDURE Write (ch: CHAR) ;


(*
   WriteString - writes out a string which is terminated by a <nul>
                 character or the end of string HIGH(s).
*)

@findex WriteString
PROCEDURE WriteString (s: ARRAY OF CHAR) ;


(*
   WriteLn - writes a lf character.
*)

@findex WriteLn
PROCEDURE WriteLn ;


END Terminal.
@end example
@page



@c ---------------------------------------------------------------------
@node PIM coroutine support, M2 ISO Libraries, PIM and Logitech 3.0 Compatible, Libraries
@section PIM coroutine support

@c Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
@c Permission is granted to copy, distribute and/or modify this document
@c under the terms of the GNU Free Documentation License, Version 1.2 or
@c any later version published by the Free Software Foundation.

This directory contains a PIM @code{SYSTEM} containing the
@code{PROCESS} primitives built on top of GNU Pthreads.

The justification for this approach is that it provides a
@code{SYSTEM} compatible with Programming in Modula-2 [234] and the
Logitech 3.0 compiler. It also allows higher level executives to be
ported onto GM2 with little effort. The disadvantage with this
approach is that @code{IOTRANSFER} is not
preemptive. @code{IOTRANSFER} will only context switch when a call to
@code{LISTEN} is made or a call to @code{SYSTEM.TurnInterrupts} is
made.

In practice this limitation can be tolerated as long as processes
perform IO at some point (or wait for a timer interrupt) or call
@code{SYSTEM.TurnInterrupts}. But nevertheless a @code{LOOP}
@code{END} will starve all other processes. However the great
advantage is that GNU Modula-2 can offer users the ability to use
@code{IOTRANSFER}, @code{TRANSFER}, @code{NEWPROCESS} in user space,
on a multi-user operating system and across a range of platforms.

The GNU Modula-2 @code{SYSTEM} works by utilizing the user context
switching mechanism provided by GNU Pthreads. @code{NEWPROCESS}
creates a new context, @code{TRANSFER} switches
contexts. @code{IOTRANSFER} is more complex. There is a support module
@code{SysVec} which provides pseudo interrupt vectors. These can be
created from input/output file descriptors or timer events
@code{timeval}. This vector is then passed to @code{IOTRANSFER} which
keeps track of which file descriptors and timevals are active. When a
call to @code{TurnInterrupts} or @code{LISTEN} is made the sub system
calls @code{pth_select} and tests for any ready file descriptor or
timeout. A ready file descriptor or timeout will ultimately cause the
backwards @code{TRANSFER} inside @code{IOTRANSFER} to take effect.

See the @file{gm2/examples/executive} directory for an executive and
timerhandler module which provide higher level process creation,
synchronisation and interrupt handling routines. These libraries have
been tested with the examples shown in @file{gm2/examples/executive}
and @file{gm2/gm2-libs-coroutines}.

Users of these libraries and the libraries in
@file{gm2/examples/executive} must link their application against the
GNU Pthread library (typically by using @code{-lpth}).
@menu
* gm2-libs-coroutines/Debug::Debug.def
* gm2-libs-coroutines/Executive::Executive.def
* gm2-libs-coroutines/KeyBoardLEDs::KeyBoardLEDs.def
* gm2-libs-coroutines/SYSTEM::SYSTEM.def
* gm2-libs-coroutines/SysVec::SysVec.def
* gm2-libs-coroutines/TimerHandler::TimerHandler.def
* gm2-libs-coroutines/pth::pth.def
@end menu


@node gm2-libs-coroutines/Debug, gm2-libs-coroutines/Executive, , PIM coroutine support
@subsection gm2-libs-coroutines/Debug

@example
DEFINITION MODULE Debug ;

(*
    Description: provides some simple debugging routines.
*)

EXPORT QUALIFIED Halt, DebugString, PushOutput ;

TYPE
   WriteP = PROCEDURE (CHAR) ;


(*
   Halt - writes a message in the format:
          Module:Line:Message

          It then terminates by calling HALT.
*)

@findex Halt
PROCEDURE Halt (File    : ARRAY OF CHAR;
                LineNo  : CARDINAL;
                Function,
                Message : ARRAY OF CHAR) ;


(*
   DebugString - writes a string to the debugging device (Scn.Write).
                 It interprets \n as carriage return, linefeed.
*)

@findex DebugString
PROCEDURE DebugString (a: ARRAY OF CHAR) ;


(*
   PushOutput - pushes the output procedure, p, which is used Debug.
*)

@findex PushOutput
PROCEDURE PushOutput (p: WriteP) ;


(*
   PopOutput - pops the current output procedure from the stack.
*)

@findex PopOutput
PROCEDURE PopOutput ;


END Debug.
@end example
@page


@node gm2-libs-coroutines/Executive, gm2-libs-coroutines/KeyBoardLEDs, gm2-libs-coroutines/Debug, PIM coroutine support
@subsection gm2-libs-coroutines/Executive

@example
DEFINITION MODULE Executive ;

(*
    Description: provides a simple multitasking executive.
*)

EXPORT QUALIFIED SEMAPHORE, DESCRIPTOR,
                 InitProcess, KillProcess, Resume, Suspend, InitSemaphore,
                 Wait, Signal, WaitForIO, Ps, GetCurrentProcess,
                 RotateRunQueue, ProcessName, DebugProcess ;

TYPE
   SEMAPHORE ;         (* defines dijkstra's semaphores *)
   DESCRIPTOR ;        (* handle onto a process         *)


(*
   InitProcess - initializes a process which is held in the suspended
                 state. When the process is resumed it will start executing
                 procedure, p. The process has a maximum stack size of,
                 StackSize, bytes and its textual name is, Name.
                 The StackSize should be at least 5000 bytes.
*)

@findex InitProcess
PROCEDURE InitProcess (p: PROC; StackSize: CARDINAL;
                       Name: ARRAY OF CHAR) : DESCRIPTOR ;


(*
   KillProcess - kills the current process. Notice that if InitProcess
                 is called again, it might reuse the DESCRIPTOR of the
                 killed process. It is the responsibility of the caller
                 to ensure all other processes understand this process
                 is different.
*)

@findex KillProcess
PROCEDURE KillProcess ;


(*
   Resume - resumes a suspended process. If all is successful then the process, p,
            is returned. If it fails then NIL is returned.
*)

@findex Resume
PROCEDURE Resume (d: DESCRIPTOR) : DESCRIPTOR ;


(*
   Suspend - suspend the calling process.
             The process can only continue running if another process
             Resumes it.
*)

@findex Suspend
PROCEDURE Suspend ;


(*
   InitSemaphore - creates a semaphore whose initial value is, v, and
                   whose name is, Name.
*)

@findex InitSemaphore
PROCEDURE InitSemaphore (v: CARDINAL; Name: ARRAY OF CHAR) : SEMAPHORE ;


(*
   Wait - performs dijkstra's P operation on a semaphore.
          A process which calls this procedure will
          wait until the value of the semaphore is > 0
          and then it will decrement this value.
*)

@findex Wait
PROCEDURE Wait (s: SEMAPHORE) ;


(*
   Signal - performs dijkstra's V operation on a semaphore.
            A process which calls the procedure will increment
            the semaphores value.
*)

@findex Signal
PROCEDURE Signal (s: SEMAPHORE) ;


(*
   WaitForIO - waits for an interrupt to occur on vector, VectorNo.
*)

@findex WaitForIO
PROCEDURE WaitForIO (VectorNo: CARDINAL) ;


(*
   Ps - displays a process list together with process status.
*)

@findex Ps
PROCEDURE Ps ;


(*
   GetCurrentProcess - returns the descriptor of the current running
                       process.
*)

@findex GetCurrentProcess
PROCEDURE GetCurrentProcess () : DESCRIPTOR ;


(*
   RotateRunQueue - rotates the process run queue.
                    It does not call the scheduler.
*)

@findex RotateRunQueue
PROCEDURE RotateRunQueue ;


(*
   ProcessName - displays the name of process, d, through
                 DebugString.
*)

@findex ProcessName
PROCEDURE ProcessName (d: DESCRIPTOR) ;


(*
   DebugProcess - gdb debug handle to enable users to debug deadlocked
                  semaphore processes.
*)

@findex DebugProcess
PROCEDURE DebugProcess (d: DESCRIPTOR) ;


END Executive.
@end example
@page


@node gm2-libs-coroutines/KeyBoardLEDs, gm2-libs-coroutines/SYSTEM, gm2-libs-coroutines/Executive, PIM coroutine support
@subsection gm2-libs-coroutines/KeyBoardLEDs

@example
DEFINITION MODULE KeyBoardLEDs ;

(*
    Description: provides a simple module to manipulate the keyboard
                 LEDs in Linux.
*)

EXPORT QUALIFIED SwitchLeds,
                 SwitchScroll, SwitchNum, SwitchCaps ;


(*
   SwitchLeds - switch the keyboard LEDs to the state defined
                by the BOOLEAN variables. TRUE = ON.
*)

@findex SwitchLeds
PROCEDURE SwitchLeds (NumLock, CapsLock, ScrollLock: BOOLEAN) ;


(*
   SwitchScroll - switchs the scroll LED on or off.
*)

@findex SwitchScroll
PROCEDURE SwitchScroll (Scroll: BOOLEAN) ;


(*
   SwitchNum - switches the Num LED on or off.
*)

@findex SwitchNum
PROCEDURE SwitchNum (Num: BOOLEAN) ;


(*
   SwitchCaps - switches the Caps LED on or off.
*)

@findex SwitchCaps
PROCEDURE SwitchCaps (Caps: BOOLEAN) ;


END KeyBoardLEDs.
@end example
@page


@node gm2-libs-coroutines/SYSTEM, gm2-libs-coroutines/SysVec, gm2-libs-coroutines/KeyBoardLEDs, PIM coroutine support
@subsection gm2-libs-coroutines/SYSTEM

@example
DEFINITION MODULE SYSTEM ;

(*
   Description: Implements the SYSTEM dependent module
                in the Modula-2 compiler. This module is designed
                to be used on a native operating system rather than
                an embedded system as it implements the coroutine
                primitives TRANSFER, IOTRANSFER and
                NEWPROCESS through the GNU Pthread library.
*)


EXPORT QUALIFIED (* the following are built into the compiler: *)
                 ADDRESS, WORD, BYTE, BITSET, ADR, TSIZE, SIZE,

                 (* and the rest are implemented in SYSTEM.mod *)
                 PROCESS, TRANSFER, NEWPROCESS, IOTRANSFER,
                 LISTEN,

                 ListenLoop, TurnInterrupts, PRIORITY ;


TYPE
   PROCESS  = RECORD
                 context: ADDRESS ;
                 ints   : PRIORITY ;
              END ;

   PRIORITY = [0..7] ;


(*
   TRANSFER - save the current volatile environment into, p1.
              Restore the volatile environment from, p2.
*)

@findex TRANSFER
PROCEDURE TRANSFER (VAR p1: PROCESS; p2: PROCESS) ;


(*
   NEWPROCESS - p is a parameterless procedure, a, is the origin of
                the workspace used for the process stack and containing
                the volatile environment of the process. n, is the amount
                in bytes of this workspace. new, is the new process.
*)

@findex NEWPROCESS
PROCEDURE NEWPROCESS (p: PROC; a: ADDRESS; n: CARDINAL; VAR new: PROCESS) ;


(*
   IOTRANSFER - saves the current volatile environment into, First,
                and restores volatile environment, Second.
                When an interrupt, InterruptNo, is encountered then
                the reverse takes place. (The then current volatile
                environment is shelved onto Second and First is resumed).

                NOTE: that upon interrupt the Second might not be the
                      same process as that before the original call to
                      IOTRANSFER.
*)

@findex IOTRANSFER
PROCEDURE IOTRANSFER (VAR First, Second: PROCESS; InterruptNo: CARDINAL) ;


(*
   LISTEN - briefly listen for any interrupts.
*)

@findex LISTEN
PROCEDURE LISTEN ;


(*
   ListenLoop - should be called instead of users writing:

                LOOP
                   LISTEN
                END

                It performs the same function but yields
                control back to the underlying operating system
                via a call to pth_select.
                It also checks for deadlock.
                This function returns when an interrupt occurs ie
                a file descriptor becomes ready or a time event expires.
                See the module SysVec.
*)

@findex ListenLoop
PROCEDURE ListenLoop ;


(*
   TurnInterrupts - switches processor interrupts to the priority, to.
                    It returns the old value.

                    This function is available in this implementation
                    to allow microkernel Modula-2 code to be
                    compiled and run both under a Pthread implementation
                    and a stand alone system.
*)

@findex TurnInterrupts
PROCEDURE TurnInterrupts (to: PRIORITY) : PRIORITY ;


END SYSTEM.
@end example
@page


@node gm2-libs-coroutines/SysVec, gm2-libs-coroutines/TimerHandler, gm2-libs-coroutines/SYSTEM, PIM coroutine support
@subsection gm2-libs-coroutines/SysVec

@example
DEFINITION MODULE SysVec ;

(*
    Description: provides SYSTEM with the pseudo interrupt vector
                 manipulation routines. This module interface was
                 designed to allow SYSTEM to have the same interface
                 as PIM [234] and Logitech 3.0. It would have been
                 easier to include this functionality into SYSTEM
                 at the expense of stricter compatibility.
*)

FROM SYSTEM IMPORT ADDRESS ;
EXPORT QUALIFIED InitInputVector, InitOutputVector, InitTimeVector,
                 AttachVector,
                 ReArmTimeVector, GetTimeVector,
                 Listen, IncludeVector, ExcludeVector, DespatchVector ;

TYPE
   DespatchVector = PROCEDURE (CARDINAL, CARDINAL, ADDRESS) ;


(*
   InitInputVector - returns an interrupt vector which is associated
                     with the file descriptor, fd.
*)

@findex InitInputVector
PROCEDURE InitInputVector (fd: INTEGER; pri: CARDINAL) : CARDINAL ;


(*
   InitOutputVector - returns an interrupt vector which is associated
                      with the file descriptor, fd.
*)

@findex InitOutputVector
PROCEDURE InitOutputVector (fd: INTEGER; pri: CARDINAL) : CARDINAL ;


(*
   InitTimeVector - returns an interrupt vector associated with
                    the relative time.
*)

@findex InitTimeVector
PROCEDURE InitTimeVector (micro, secs: CARDINAL; pri: CARDINAL) : CARDINAL ;


(*
   ReArmTimeVector - reprimes the vector, vec, to deliver an interrupt
                     at the new relative time.
*)

@findex ReArmTimeVector
PROCEDURE ReArmTimeVector (vec: CARDINAL; micro, secs: CARDINAL) ;


(*
   GetTimeVector - assigns, micro, and, secs, with the remaining
                   time before this interrupt will expire.
                   This value is only updated when a Listen
                   occurs.
*)

@findex GetTimeVector
PROCEDURE GetTimeVector (vec: CARDINAL; VAR micro, secs: CARDINAL) ;


(*
   AttachVector - adds the pointer, p, to be associated with the interrupt
                  vector. It returns the previous value attached to this
                  vector.
*)

@findex AttachVector
PROCEDURE AttachVector (vec: CARDINAL; p: ADDRESS) : ADDRESS ;


(*
   IncludeVector - includes, vec, into the despatcher list of
                   possible interrupt causes.
*)

@findex IncludeVector
PROCEDURE IncludeVector (vec: CARDINAL) ;


(*
   ExcludeVector - excludes, vec, from the despatcher list of
                   possible interrupt causes.
*)

@findex ExcludeVector
PROCEDURE ExcludeVector (vec: CARDINAL) ;


(*
   Listen - will either block indefinitely (until an interrupt)
            or alteratively will test to see whether any interrupts
            are pending.
            If a pending interrupt was found then, call, is called
            and then this procedure returns.
            It only listens for interrupts > pri.
*)

@findex Listen
PROCEDURE Listen (untilInterrupt: BOOLEAN;
                  call: DespatchVector;
                  pri: CARDINAL) ;


END SysVec.
@end example
@page


@node gm2-libs-coroutines/TimerHandler, gm2-libs-coroutines/pth, gm2-libs-coroutines/SysVec, PIM coroutine support
@subsection gm2-libs-coroutines/TimerHandler

@example
DEFINITION MODULE TimerHandler ;

(*
    Description: provides a simple timer handler for the
                 Executive.
                 It also provides the Executive with a basic
                 round robin scheduler.
*)

EXPORT QUALIFIED TicksPerSecond, GetTicks,
                 EVENT,
                 Sleep, ArmEvent, WaitOn, Cancel, ReArmEvent ;


CONST
   TicksPerSecond =   25 ;  (* Number of ticks per second.         *)

TYPE
   EVENT ;


(*
   GetTicks - returns the number of ticks since boottime.
*)

@findex GetTicks
PROCEDURE GetTicks () : CARDINAL ;


(*
   Sleep - suspends the current process for a time, t.
           The time is measured in ticks.
*)

@findex Sleep
PROCEDURE Sleep (t: CARDINAL) ;


(*
   ArmEvent - initializes an event, e, to occur at time, t.
              The time, t, is measured in ticks.
              The event is NOT placed onto the event queue.
*)

@findex ArmEvent
PROCEDURE ArmEvent (t: CARDINAL) : EVENT ;


(*
   WaitOn - places event, e, onto the event queue and then the calling
            process suspends. It is resumed up by either the event
            expiring or the event, e, being cancelled.
            TRUE is returned if the event was cancelled
            FALSE is returned if the event expires.
*)

@findex WaitOn
PROCEDURE WaitOn (e: EVENT) : BOOLEAN ;


(*
   Cancel - cancels the event, e, on the event queue and makes
            the appropriate process runnable again.
            TRUE is returned if the event was cancelled and
            FALSE is returned is the event was not found or
                  no process was waiting on this event.
*)

@findex Cancel
PROCEDURE Cancel (e: EVENT) : BOOLEAN ;


(*
   ReArmEvent - removes an event, e, from the event queue. A new time
                is given to this event and it is then re-inserted onto the
                event queue in the correct place.
                TRUE is returned if this occurred
                FALSE is returned if the event was not found.
*)

@findex ReArmEvent
PROCEDURE ReArmEvent (e: EVENT; t: CARDINAL) : BOOLEAN ;


END TimerHandler.
@end example
@page


@node gm2-libs-coroutines/pth, , gm2-libs-coroutines/TimerHandler, PIM coroutine support
@subsection gm2-libs-coroutines/pth

@example
DEFINITION MODULE FOR "C" pth ;

FROM SYSTEM IMPORT ADDRESS, BITSET ;

CONST
     PTH_VERSION_STR =  "1.4.1 (27-Jan-2002)" ;
     PTH_VERSION_HEX =  1065473 ;
     PTH_VERSION =  PTH_VERSION_HEX ;

TYPE
     fd_set =  ADDRESS ;
     __time_t =   INTEGER ;
     __useconds_t =   CARDINAL ;
     __suseconds_t =   INTEGER ;
     size_t =   CARDINAL ;
    timeval = RECORD
                 tv_sec : __time_t ;
                 tv_usec: __suseconds_t ;
              END ;

    sockaddr = RECORD
               END ;
     sigset_t =  ADDRESS ;
     pth_uctx_t =  POINTER TO   pth_uctx_st ;
    pth_uctx_st = RECORD
                  END ;
     pid_t =   INTEGER ;
     ssize_t =   CARDINAL ;
     socklen_t =   CARDINAL ;
     off_t =   INTEGER ;
     sig_atomic_t =   INTEGER ;
     nfds_t =   LONGCARD ;

CONST
     PTH_KEY_MAX =  256 ;
     PTH_ATFORK_MAX =  128 ;
     PTH_DESTRUCTOR_ITERATIONS =  4 ;
     PTH_SYSCALL_HARD =  0 ;
     PTH_SYSCALL_SOFT =  0 ;

TYPE
     pth_time_t =  ADDRESS ;
     pth_t =  ADDRESS ;
     pth_state_t =   pth_state_en ;
     pth_state_en =  ( PTH_STATE_SCHEDULER, PTH_STATE_NEW, PTH_STATE_READY, PTH_STATE_WAITING, PTH_STATE_DEAD) ;

CONST
     PTH_PRIO_MAX =   5 ;
     PTH_PRIO_STD =  0 ;
     PTH_PRIO_MIN =  -( 5) ;

TYPE
     pth_attr_t =  ADDRESS ;

CONST
     PTH_ATTR_PRIO = 0 ;
     PTH_ATTR_NAME = 1 ;
     PTH_ATTR_JOINABLE = 2 ;
     PTH_ATTR_CANCEL_STATE = 3 ;
     PTH_ATTR_STACK_SIZE = 4 ;
     PTH_ATTR_STACK_ADDR = 5 ;
     PTH_ATTR_TIME_SPAWN = 6 ;
     PTH_ATTR_TIME_LAST = 7 ;
     PTH_ATTR_TIME_RAN = 8 ;
     PTH_ATTR_START_FUNC = 9 ;
     PTH_ATTR_START_ARG = 10 ;
     PTH_ATTR_STATE = 11 ;
     PTH_ATTR_EVENTS = 12 ;
     PTH_ATTR_BOUND = 13 ;
     PTH_ATTR_DEFAULT =  0 ;



    (* event subject classes *)
    PTH_EVENT_FD    =  BITSET @{1@} ;
    PTH_EVENT_SELECT=  BITSET @{2@} ;
    PTH_EVENT_SIGS  =  BITSET @{3@} ;
    PTH_EVENT_TIME  =  BITSET @{4@} ;
    PTH_EVENT_MSG   =  BITSET @{5@} ;
    PTH_EVENT_MUTEX =  BITSET @{6@} ;
    PTH_EVENT_COND  =  BITSET @{7@} ;
    PTH_EVENT_TID   =  BITSET @{8@} ;
    PTH_EVENT_FUNC  =  BITSET @{9@} ;

    (* event occurange restrictions *)
    PTH_UNTIL_OCCURRED     =  BITSET @{11@} ;
    PTH_UNTIL_FD_READABLE  =  BITSET @{12@} ;
    PTH_UNTIL_FD_WRITEABLE =  BITSET @{13@} ;
    PTH_UNTIL_FD_EXCEPTION =  BITSET @{14@} ;
    PTH_UNTIL_TID_NEW      =  BITSET @{15@} ;
    PTH_UNTIL_TID_READY    =  BITSET @{16@} ;
    PTH_UNTIL_TID_WAITING  =  BITSET @{17@} ;
    PTH_UNTIL_TID_DEAD     =  BITSET @{18@} ;

    (* event structure handling modes *)
    PTH_MODE_REUSE  =  BITSET @{20@} ;
    PTH_MODE_CHAIN  =  BITSET @{21@} ;
    PTH_MODE_STATIC =  BITSET @{22@} ;

TYPE
     pth_event_t =  ADDRESS ;

CONST
     PTH_FREE_THIS = 0 ;
     PTH_FREE_ALL = 1 ;

TYPE
     pth_key_t =   INTEGER ;

CONST
     PTH_KEY_INIT =  -( 1) ;

TYPE
     pth_once_t =   INTEGER ;

CONST
     PTH_ONCE_INIT =  FALSE ;

TYPE
     pth_ringnode_t =   pth_ringnode_st ;
    pth_ringnode_st = RECORD
                         rn_next: POINTER TO  pth_ringnode_t ;
                         rn_prev: POINTER TO  pth_ringnode_t ;
                      END ;
     pth_ring_t =   pth_ring_st ;
    pth_ring_st = RECORD
                     r_hook: POINTER TO  pth_ringnode_t ;
                     r_nodes: CARDINAL ;
                  END ;
     pth_msgport_t =  ADDRESS ;
     pth_message_t =   pth_message_st ;
    pth_message_st = RECORD
                        m_node: pth_ringnode_t ;
                        m_replyport: pth_msgport_t ;
                        m_size: CARDINAL ;
                        m_data: ADDRESS ;
                     END ;
     pth_mutex_t =   pth_mutex_st ;
    pth_mutex_st = RECORD
                      mx_node: pth_ringnode_t ;
                      mx_state: INTEGER ;
                      mx_owner: pth_t ;
                      mx_count: CARDINAL ;
                   END ;
     pth_rwlock_t =   pth_rwlock_st ;
    pth_rwlock_st = RECORD
                       rw_state: INTEGER ;
                       rw_mode: CARDINAL ;
                       rw_readers: CARDINAL ;
                       rw_mutex_rd: pth_mutex_t ;
                       rw_mutex_rw: pth_mutex_t ;
                    END ;
     pth_cond_t =   pth_cond_st ;
    pth_cond_st = RECORD
                     cn_state: CARDINAL ;
                     cn_waiters: CARDINAL ;
                  END ;
     pth_barrier_t =   pth_barrier_st ;
    pth_barrier_st = RECORD
                        br_state: CARDINAL ;
                        br_threshold: INTEGER ;
                        br_count: INTEGER ;
                        br_cycle: INTEGER ;
                        br_cond: pth_cond_t ;
                        br_mutex: pth_mutex_t ;
                     END ;

CONST
     POLLIN =  1 ;
     POLLPRI =  2 ;
     POLLOUT =  4 ;
     POLLERR =  8 ;
     POLLHUP =  16 ;
     POLLNVAL =  32 ;
     POLLRDNORM =  POLLIN ;
     POLLRDBAND =  POLLIN ;
     POLLWRNORM =  POLLOUT ;
     POLLWRBAND =  POLLOUT ;
     INFTIM =  -( 1) ;

CONST
     PTH_FAKE_RWV =  0 ;

TYPE
    iovec = RECORD
               iov_base: ADDRESS ;
               iov_len: size_t ;
            END ;

CONST
     UIO_MAXIOV =  1024 ;
     PTH_EXT_SFIO =  0 ;

TYPE
     Sfdisc_t =  ADDRESS ;

@findex pth_init
 PROCEDURE pth_init () : INTEGER ;
@findex pth_kill
 PROCEDURE pth_kill () : INTEGER ;
@findex pth_ctrl
 PROCEDURE pth_ctrl (p1: CARDINAL; ...) : INTEGER ;
@findex pth_version
 PROCEDURE pth_version () : INTEGER ;
@findex pth_attr_of
 PROCEDURE pth_attr_of (p1: pth_t) : pth_attr_t ;
@findex pth_attr_new
 PROCEDURE pth_attr_new () : pth_attr_t ;
@findex pth_attr_init
 PROCEDURE pth_attr_init (p1: pth_attr_t) : INTEGER ;
@findex pth_attr_set
 PROCEDURE pth_attr_set (p1: pth_attr_t; p2: INTEGER; ...) : INTEGER ;
@findex pth_attr_get
 PROCEDURE pth_attr_get (p1: pth_attr_t; p2: INTEGER; ...) : INTEGER ;
@findex pth_attr_destroy
 PROCEDURE pth_attr_destroy (p1: pth_attr_t) : INTEGER ;
@findex pth_spawn
 PROCEDURE pth_spawn (p2: pth_attr_t; p1: t1; p3: ADDRESS) : pth_t;

TYPE
     t1 =    PROCEDURE (ADDRESS) : ADDRESS ;

@findex pth_once
PROCEDURE pth_once (p2: ADDRESS; p1: t2; p3: ADDRESS) : INTEGER;

TYPE
     t2 =    PROCEDURE (ADDRESS) ;

@findex pth_self
 PROCEDURE pth_self () : pth_t ;
@findex pth_suspend
 PROCEDURE pth_suspend (p1: pth_t) : INTEGER ;
@findex pth_resume
 PROCEDURE pth_resume (p1: pth_t) : INTEGER ;
@findex pth_yield
 PROCEDURE pth_yield (p1: pth_t) : INTEGER ;
@findex pth_nap
 PROCEDURE pth_nap (p1: pth_time_t) : INTEGER ;
@findex pth_wait
 PROCEDURE pth_wait (p1: pth_event_t) : INTEGER ;
@findex pth_cancel
 PROCEDURE pth_cancel (p1: pth_t) : INTEGER ;
@findex pth_abort
 PROCEDURE pth_abort (p1: pth_t) : INTEGER ;
@findex pth_raise
 PROCEDURE pth_raise (p1: pth_t; p2: INTEGER) : INTEGER ;
@findex pth_join
 PROCEDURE pth_join (p1: pth_t; p2: ADDRESS) : INTEGER ;
@findex pth_exit
 PROCEDURE pth_exit (p1: ADDRESS) ;
@findex pth_fdmode
 PROCEDURE pth_fdmode (p1: INTEGER; p2: INTEGER) : INTEGER ;
@findex pth_time
 PROCEDURE pth_time (p1: INTEGER; p2: INTEGER) : pth_time_t ;
@findex pth_timeout
 PROCEDURE pth_timeout (p1: INTEGER; p2: INTEGER) : pth_time_t ;
@findex pth_cancel_state
 PROCEDURE pth_cancel_state (p1: INTEGER; p2: ADDRESS) ;
@findex pth_cancel_point
 PROCEDURE pth_cancel_point  ;
@findex pth_event
 PROCEDURE pth_event (p1: CARDINAL; ...) : pth_event_t ;
@findex pth_event_typeof
 PROCEDURE pth_event_typeof (p1: pth_event_t) : CARDINAL ;
@findex pth_event_extract
 PROCEDURE pth_event_extract (ev: pth_event_t; ...) : INTEGER ;
@findex pth_event_concat
 PROCEDURE pth_event_concat (p1: pth_event_t; ...) : pth_event_t ;
@findex pth_event_isolate
 PROCEDURE pth_event_isolate (p1: pth_event_t) : pth_event_t ;
@findex pth_event_walk
 PROCEDURE pth_event_walk (p1: pth_event_t; p2: CARDINAL) : pth_event_t ;
@findex pth_event_occurred
 PROCEDURE pth_event_occurred (p1: pth_event_t) : INTEGER ;
@findex pth_event_free
 PROCEDURE pth_event_free (p1: pth_event_t; p2: INTEGER) : INTEGER ;
@findex pth_key_create
 PROCEDURE pth_key_create (p2: ADDRESS; p1: t3) : INTEGER;

TYPE
     t3 =    PROCEDURE (ADDRESS) ;

@findex pth_key_delete
 PROCEDURE pth_key_delete (p1: pth_key_t) : INTEGER ;
@findex pth_key_setdata
 PROCEDURE pth_key_setdata (p1: pth_key_t; p2: ADDRESS) : INTEGER ;
@findex pth_key_getdata
 PROCEDURE pth_key_getdata (p1: pth_key_t) : ADDRESS ;
@findex pth_msgport_create
 PROCEDURE pth_msgport_create (p1: ADDRESS) : pth_msgport_t ;
@findex pth_msgport_destroy
 PROCEDURE pth_msgport_destroy (p1: pth_msgport_t) ;
@findex pth_msgport_find
 PROCEDURE pth_msgport_find (p1: ADDRESS) : pth_msgport_t ;
@findex pth_msgport_pending
 PROCEDURE pth_msgport_pending (p1: pth_msgport_t) : INTEGER ;
@findex pth_msgport_put
 PROCEDURE pth_msgport_put (p1: pth_msgport_t; p2: ADDRESS) : INTEGER ;
@findex pth_msgport_get
 PROCEDURE pth_msgport_get (p1: pth_msgport_t) : ADDRESS ;
@findex pth_msgport_reply
 PROCEDURE pth_msgport_reply (p1: ADDRESS) : INTEGER ;
@findex pth_cleanup_push
 PROCEDURE pth_cleanup_push (p1: t4; p2: ADDRESS) : INTEGER;

TYPE
     t4 =    PROCEDURE (ADDRESS) ;

@findex pth_cleanup_pop
 PROCEDURE pth_cleanup_pop (p1: INTEGER) : INTEGER ;

TYPE
     t5 =    PROCEDURE (ADDRESS);

@findex pth_atfork_pop
 PROCEDURE pth_atfork_pop () : INTEGER ;
@findex pth_fork
 PROCEDURE pth_fork () : pid_t ;
@findex pth_mutex_init
 PROCEDURE pth_mutex_init (p1: ADDRESS) : INTEGER ;
@findex pth_mutex_acquire
 PROCEDURE pth_mutex_acquire (p1: ADDRESS; p2: INTEGER; p3: pth_event_t) : INTEGER ;
@findex pth_mutex_release
 PROCEDURE pth_mutex_release (p1: ADDRESS) : INTEGER ;
@findex pth_rwlock_init
 PROCEDURE pth_rwlock_init (p1: ADDRESS) : INTEGER ;
@findex pth_rwlock_acquire
 PROCEDURE pth_rwlock_acquire (p1: ADDRESS; p2: INTEGER; p3: INTEGER; p4: pth_event_t) : INTEGER ;
@findex pth_rwlock_release
 PROCEDURE pth_rwlock_release (p1: ADDRESS) : INTEGER ;
@findex pth_cond_init
 PROCEDURE pth_cond_init (p1: ADDRESS) : INTEGER ;
@findex pth_cond_await
 PROCEDURE pth_cond_await (p1: ADDRESS; p2: ADDRESS; p3: pth_event_t) : INTEGER ;
@findex pth_cond_notify
 PROCEDURE pth_cond_notify (p1: ADDRESS; p2: INTEGER) : INTEGER ;
@findex pth_barrier_init
 PROCEDURE pth_barrier_init (p1: ADDRESS; p2: INTEGER) : INTEGER ;
@findex pth_barrier_reach
 PROCEDURE pth_barrier_reach (p1: ADDRESS) : INTEGER ;
@findex pth_uctx_create
 PROCEDURE pth_uctx_create (p1: ADDRESS) : INTEGER ;
@findex pth_uctx_make
 PROCEDURE pth_uctx_make (p2: pth_uctx_t; p3: ADDRESS; p4: size_t; p5: ADDRESS; p1: t8; p6: ADDRESS; p7: pth_uctx_t) : INTEGER;

TYPE
     t8 =    PROCEDURE (ADDRESS) ;

@findex pth_uctx_save
 PROCEDURE pth_uctx_save (p1: pth_uctx_t) : INTEGER ;
@findex pth_uctx_restore
 PROCEDURE pth_uctx_restore (p1: pth_uctx_t) : INTEGER ;
@findex pth_uctx_switch
 PROCEDURE pth_uctx_switch (p1: pth_uctx_t; p2: pth_uctx_t) : INTEGER ;
@findex pth_uctx_destroy
 PROCEDURE pth_uctx_destroy (p1: pth_uctx_t) : INTEGER ;
@findex pth_sfiodisc
 PROCEDURE pth_sfiodisc () : ADDRESS ;
@findex pth_sigwait_ev
 PROCEDURE pth_sigwait_ev (p1: ADDRESS; p2: ADDRESS; p3: pth_event_t) : INTEGER ;
@findex pth_connect_ev
 PROCEDURE pth_connect_ev (p1: INTEGER; p2: ADDRESS; p3: socklen_t; p4: pth_event_t) : INTEGER ;
@findex pth_accept_ev
 PROCEDURE pth_accept_ev (p1: INTEGER; p2: ADDRESS; p3: ADDRESS; p4: pth_event_t) : INTEGER ;
@findex pth_select_ev
 PROCEDURE pth_select_ev (p1: INTEGER; p2: ADDRESS; p3: ADDRESS; p4: ADDRESS; p5: ADDRESS; p6: pth_event_t) : INTEGER ;
@findex pth_poll_ev
 PROCEDURE pth_poll_ev (p1: ADDRESS; p2: nfds_t; p3: INTEGER; p4: pth_event_t) : INTEGER ;
@findex pth_read_ev
 PROCEDURE pth_read_ev (p1: INTEGER; p2: ADDRESS; p3: size_t; p4: pth_event_t) : ssize_t ;
@findex pth_write_ev
 PROCEDURE pth_write_ev (p1: INTEGER; p2: ADDRESS; p3: size_t; p4: pth_event_t) : ssize_t ;
@findex pth_readv_ev
 PROCEDURE pth_readv_ev (p1: INTEGER; p2: ADDRESS; p3: INTEGER; p4: pth_event_t) : ssize_t ;
@findex pth_writev_ev
 PROCEDURE pth_writev_ev (p1: INTEGER; p2: ADDRESS; p3: INTEGER; p4: pth_event_t) : ssize_t ;
@findex pth_recv_ev
 PROCEDURE pth_recv_ev (p1: INTEGER; p2: ADDRESS; p3: size_t; p4: INTEGER; p5: pth_event_t) : ssize_t ;
@findex pth_send_ev
 PROCEDURE pth_send_ev (p1: INTEGER; p2: ADDRESS; p3: size_t; p4: INTEGER; p5: pth_event_t) : ssize_t ;
@findex pth_recvfrom_ev
 PROCEDURE pth_recvfrom_ev (p1: INTEGER; p2: ADDRESS; p3: size_t; p4: INTEGER; p5: ADDRESS; p6: ADDRESS; p7: pth_event_t) : ssize_t ;
@findex pth_sendto_ev
 PROCEDURE pth_sendto_ev (p1: INTEGER; p2: ADDRESS; p3: size_t; p4: INTEGER; p5: ADDRESS; p6: socklen_t; p7: pth_event_t) : ssize_t ;
@findex pth_usleep
 PROCEDURE pth_usleep (p1: CARDINAL) : INTEGER ;
@findex pth_sleep
 PROCEDURE pth_sleep (p1: CARDINAL) : CARDINAL ;
@findex pth_waitpid
 PROCEDURE pth_waitpid (p1: pid_t; p2: ADDRESS; p3: INTEGER) : pid_t ;
@findex pth_system
 PROCEDURE pth_system (p1: ADDRESS) : INTEGER ;
@findex pth_sigmask
 PROCEDURE pth_sigmask (p1: INTEGER; p2: ADDRESS; p3: ADDRESS) : INTEGER ;
@findex pth_sigwait
 PROCEDURE pth_sigwait (p1: ADDRESS; p2: ADDRESS) : INTEGER ;
@findex pth_connect
 PROCEDURE pth_connect (p1: INTEGER; p2: ADDRESS; p3: socklen_t) : INTEGER ;
@findex pth_accept
 PROCEDURE pth_accept (p1: INTEGER; p2: ADDRESS; p3: ADDRESS) : INTEGER ;
@findex pth_select
 PROCEDURE pth_select (p1: INTEGER; p2: ADDRESS; p3: ADDRESS; p4: ADDRESS; p5: ADDRESS) : INTEGER ;
@findex pth_poll
 PROCEDURE pth_poll (p1: ADDRESS; p2: nfds_t; p3: INTEGER) : INTEGER ;
@findex pth_read
 PROCEDURE pth_read (p1: INTEGER; p2: ADDRESS; p3: size_t) : ssize_t ;
@findex pth_write
 PROCEDURE pth_write (p1: INTEGER; p2: ADDRESS; p3: size_t) : ssize_t ;
@findex pth_readv
 PROCEDURE pth_readv (p1: INTEGER; p2: ADDRESS; p3: INTEGER) : ssize_t ;
@findex pth_writev
 PROCEDURE pth_writev (p1: INTEGER; p2: ADDRESS; p3: INTEGER) : ssize_t ;
@findex pth_recv
 PROCEDURE pth_recv (p1: INTEGER; p2: ADDRESS; p3: size_t; p4: INTEGER) : ssize_t ;
@findex pth_send
 PROCEDURE pth_send (p1: INTEGER; p2: ADDRESS; p3: size_t; p4: INTEGER) : ssize_t ;
@findex pth_recvfrom
 PROCEDURE pth_recvfrom (p1: INTEGER; p2: ADDRESS; p3: size_t; p4: INTEGER; p5: ADDRESS; p6: ADDRESS) : ssize_t ;
@findex pth_sendto
 PROCEDURE pth_sendto (p1: INTEGER; p2: ADDRESS; p3: size_t; p4: INTEGER; p5: ADDRESS; p6: socklen_t) : ssize_t ;
@findex pth_pread
 PROCEDURE pth_pread (p1: INTEGER; p2: ADDRESS; p3: size_t; p4: off_t) : ssize_t ;
@findex pth_pwrite
 PROCEDURE pth_pwrite (p1: INTEGER; p2: ADDRESS; p3: size_t; p4: off_t) : ssize_t ;

END pth.
@end example
@page



@c ---------------------------------------------------------------------
@node M2 ISO Libraries, ULM System Libraries, PIM coroutine support, Libraries
@section M2 ISO Libraries

@c Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
@c Permission is granted to copy, distribute and/or modify this document
@c under the terms of the GNU Free Documentation License, Version 1.2 or
@c any later version published by the Free Software Foundation.

This directory contains the ISO definition modules and some corresponding
implementation modules. Currently this is work in progress and the code
is incomplete and probably highly buggy.

The following implementation modules are complete:

ChanConsts
CharClass
ConvTypes
@menu
* gm2-iso/COROUTINES::COROUTINES.def
* gm2-iso/ChanConsts::ChanConsts.def
* gm2-iso/CharClass::CharClass.def
* gm2-iso/ComplexMath::ComplexMath.def
* gm2-iso/ConvTypes::ConvTypes.def
* gm2-iso/EXCEPTIONS::EXCEPTIONS.def
* gm2-iso/GeneralUser::GeneralUser.def
* gm2-iso/IOChan::IOChan.def
* gm2-iso/IOConsts::IOConsts.def
* gm2-iso/IOLink::IOLink.def
* gm2-iso/IOResult::IOResult.def
* gm2-iso/LongComplex::LongComplex.def
* gm2-iso/LongConv::LongConv.def
* gm2-iso/LongIO::LongIO.def
* gm2-iso/LongMath::LongMath.def
* gm2-iso/LongStr::LongStr.def
* gm2-iso/LowLong::LowLong.def
* gm2-iso/LowReal::LowReal.def
* gm2-iso/M2EXCEPTION::M2EXCEPTION.def
* gm2-iso/M2RTS::M2RTS.def
* gm2-iso/Processes::Processes.def
* gm2-iso/ProgramArgs::ProgramArgs.def
* gm2-iso/RawIO::RawIO.def
* gm2-iso/RealConv::RealConv.def
* gm2-iso/RealIO::RealIO.def
* gm2-iso/RealMath::RealMath.def
* gm2-iso/RealStr::RealStr.def
* gm2-iso/RndFile::RndFile.def
* gm2-iso/SIOResult::SIOResult.def
* gm2-iso/SLongIO::SLongIO.def
* gm2-iso/SRawIO::SRawIO.def
* gm2-iso/SRealIO::SRealIO.def
* gm2-iso/STextIO::STextIO.def
* gm2-iso/SWholeIO::SWholeIO.def
* gm2-iso/SYSTEM::SYSTEM.def
* gm2-iso/Semaphores::Semaphores.def
* gm2-iso/SeqFile::SeqFile.def
* gm2-iso/StdChans::StdChans.def
* gm2-iso/Storage::Storage.def
* gm2-iso/StreamFile::StreamFile.def
* gm2-iso/Strings::Strings.def
* gm2-iso/SysClock::SysClock.def
* gm2-iso/TERMINATION::TERMINATION.def
* gm2-iso/TermFile::TermFile.def
* gm2-iso/TextIO::TextIO.def
* gm2-iso/WholeConv::WholeConv.def
* gm2-iso/WholeIO::WholeIO.def
* gm2-iso/WholeStr::WholeStr.def
@end menu


@node gm2-iso/COROUTINES, gm2-iso/ChanConsts, , M2 ISO Libraries
@subsection gm2-iso/COROUTINES

@example
DEFINITION MODULE COROUTINES;

(* Facilities for coroutines and the handling of interrupts *)

IMPORT SYSTEM;

CONST
   UnassignedPriority = PTH_PRIO_MIN - 1 ;

TYPE
  COROUTINE; (* Values of this type are created dynamically by NEWCOROUTINE
                and identify the coroutine in subsequent operations *)
  INTERRUPTSOURCE;
  PROTECTION = [UnassignedPriority..PTH_PRIO_MAX]


@findex NEWCOROUTINE
PROCEDURE NEWCOROUTINE (procBody: PROC;
                        workspace: SYSTEM.ADDRESS;
                        size: CARDINAL;
                        VAR cr: COROUTINE;
                        [initProtection: PROTECTION = UnassignedPriority]);
  (* Creates a new coroutine whose body is given by procBody, and
     returns the identity of the coroutine in cr. workspace is a
     pointer to the work space allocated to the coroutine; size
     specifies the size of this workspace in terms of SYSTEM.LOC.

     The optarg, initProtection, may contain a single parameter which
     specifies the initial protection level of the coroutine.
  *)

@findex TRANSFER
PROCEDURE TRANSFER (VAR from: COROUTINE; to: COROUTINE);
  (* Returns the identity of the calling coroutine in from, and
     transfers control to the coroutine specified by to.
  *)

@findex IOTRANSFER
PROCEDURE IOTRANSFER (VAR from: COROUTINE; to: COROUTINE);
  (* Returns the identity of the calling coroutine in from and
     transfers control to the coroutine specified by to.  On
     occurrence of an interrupt, associated with the caller, control
     is transferred back to the caller, and the identity of the
     interrupted coroutine is returned in from.  The calling coroutine
     must be associated with a source of interrupts.
  *)

@findex ATTACH
PROCEDURE ATTACH (source: INTERRUPTSOURCE);
  (* Associates the specified source of interrupts with the calling
     coroutine. *)

@findex DETACH
PROCEDURE DETACH (source: INTERRUPTSOURCE);
  (* Dissociates the specified source of interrupts from the calling
     coroutine. *)

@findex IsATTACHED
PROCEDURE IsATTACHED (source: INTERRUPTSOURCE): BOOLEAN;
  (* Returns TRUE if and only if the specified source of interrupts is
     currently associated with a coroutine; otherwise returns FALSE.
  *)

@findex HANDLER
PROCEDURE HANDLER (source: INTERRUPTSOURCE): COROUTINE;
  (* Returns the coroutine, if any, that is associated with the source
     of interrupts. The result is undefined if IsATTACHED(source) =
     FALSE.
  *)

@findex CURRENT
PROCEDURE CURRENT (): COROUTINE;
  (* Returns the identity of the calling coroutine. *)

@findex LISTEN
PROCEDURE LISTEN (p: PROTECTION);
  (* Momentarily changes the protection of the calling coroutine to
     p. *)

@findex PROT
PROCEDURE PROT (): PROTECTION;
  (* Returns the protection of the calling coroutine. *)

END COROUTINES.
@end example
@page


@node gm2-iso/ChanConsts, gm2-iso/CharClass, gm2-iso/COROUTINES, M2 ISO Libraries
@subsection gm2-iso/ChanConsts

@example
DEFINITION MODULE ChanConsts;

  (* Common types and values for channel open requests and results *)

TYPE
  ChanFlags =        (* Request flags possibly given when a channel is opened *)
  ( readFlag,        (* input operations are requested/available *)
    writeFlag,       (* output operations are requested/available *)
    oldFlag,         (* a file may/must/did exist before the channel is opened *)
    textFlag,        (* text operations are requested/available *)
    rawFlag,         (* raw operations are requested/available *)
    interactiveFlag, (* interactive use is requested/applies *)
    echoFlag         (* echoing by interactive device on removal of characters from input
                        stream requested/applies *)
  );

  FlagSet = SET OF ChanFlags;

  (* Singleton values of FlagSet, to allow for example, read + write *)

CONST
  read = FlagSet@{readFlag@};   (* input operations are requested/available *)
  write = FlagSet@{writeFlag@}; (* output operations are requested/available *)
  old = FlagSet@{oldFlag@};     (* a file may/must/did exist before the channel is opened *)
  text = FlagSet@{textFlag@};   (* text operations are requested/available *)
  raw = FlagSet@{rawFlag@};     (* raw operations are requested/available *)
  interactive = FlagSet@{interactiveFlag@}; (* interactive use is requested/applies *)
  echo = FlagSet@{echoFlag@};   (* echoing by interactive device on removal of characters from
                                 input stream requested/applies *)

TYPE
  OpenResults =        (* Possible results of open requests *)
    (opened,           (* the open succeeded as requested *)
     wrongNameFormat,  (* given name is in the wrong format for the implementation *)
     wrongFlags,       (* given flags include a value that does not apply to the device *)
     tooManyOpen,      (* this device cannot support any more open channels *)
     outOfChans,       (* no more channels can be allocated *)
     wrongPermissions, (* file or directory permissions do not allow request *)
     noRoomOnDevice,   (* storage limits on the device prevent the open *)
     noSuchFile,       (* a needed file does not exist *)
     fileExists,       (* a file of the given name already exists when a new one is required *)
     wrongFileType,    (* the file is of the wrong type to support the required operations *)
      noTextOperations, (* text operations have been requested, but are not supported *)
     noRawOperations,  (* raw operations have been requested, but are not supported *)
     noMixedOperations,(* text and raw operations have been requested, but they
                          are not supported in combination *)
     alreadyOpen,      (* the source/destination is already open for operations not supported
                          in combination with the requested operations *)
     otherProblem      (* open failed for some other reason *)
    );

END ChanConsts.

@end example
@page


@node gm2-iso/CharClass, gm2-iso/ComplexMath, gm2-iso/ChanConsts, M2 ISO Libraries
@subsection gm2-iso/CharClass

@example
DEFINITION MODULE CharClass;

  (* Classification of values of the type CHAR *)

@findex IsNumeric
PROCEDURE IsNumeric (ch: CHAR): BOOLEAN;
  (* Returns TRUE if and only if ch is classified as a numeric character *)

@findex IsLetter
PROCEDURE IsLetter (ch: CHAR): BOOLEAN;
  (* Returns TRUE if and only if ch is classified as a letter *)

@findex IsUpper
PROCEDURE IsUpper (ch: CHAR): BOOLEAN;
  (* Returns TRUE if and only if ch is classified as an upper case letter *)

@findex IsLower
PROCEDURE IsLower (ch: CHAR): BOOLEAN;
  (* Returns TRUE if and only if ch is classified as a lower case letter *)

@findex IsControl
PROCEDURE IsControl (ch: CHAR): BOOLEAN;
  (* Returns TRUE if and only if ch represents a control function *)

@findex IsWhiteSpace
PROCEDURE IsWhiteSpace (ch: CHAR): BOOLEAN;
  (* Returns TRUE if and only if ch represents a space character or a format effector *)

END CharClass.

@end example
@page


@node gm2-iso/ComplexMath, gm2-iso/ConvTypes, gm2-iso/CharClass, M2 ISO Libraries
@subsection gm2-iso/ComplexMath

@example
DEFINITION MODULE ComplexMath;

  (* Mathematical functions for the type COMPLEX *)

CONST
  i =    CMPLX (0.0, 1.0);
  one =  CMPLX (1.0, 0.0);
  zero = CMPLX (0.0, 0.0);

@findex abs
PROCEDURE abs (z: COMPLEX): REAL;
  (* Returns the length of z *)

@findex arg
PROCEDURE arg (z: COMPLEX): REAL;
  (* Returns the angle that z subtends to the positive real axis *)

@findex conj
PROCEDURE conj (z: COMPLEX): COMPLEX;
  (* Returns the complex conjugate of z *)

@findex power
PROCEDURE power (base: COMPLEX; exponent: REAL): COMPLEX;
  (* Returns the value of the number base raised to the power exponent *)

@findex sqrt
PROCEDURE sqrt (z: COMPLEX): COMPLEX;
  (* Returns the principal square root of z *)

@findex exp
PROCEDURE exp (z: COMPLEX): COMPLEX;
  (* Returns the complex exponential of z *)

@findex ln
PROCEDURE ln (z: COMPLEX): COMPLEX;
  (* Returns the principal value of the natural logarithm of z *)

@findex sin
PROCEDURE sin (z: COMPLEX): COMPLEX;
  (* Returns the sine of z *)

@findex cos
PROCEDURE cos (z: COMPLEX): COMPLEX;
  (* Returns the cosine of z *)

@findex tan
PROCEDURE tan (z: COMPLEX): COMPLEX;
  (* Returns the tangent of z *)

@findex arcsin
PROCEDURE arcsin (z: COMPLEX): COMPLEX;
  (* Returns the arcsine of z *)

@findex arccos
PROCEDURE arccos (z: COMPLEX): COMPLEX;
  (* Returns the arccosine of z *)

@findex arctan
PROCEDURE arctan (z: COMPLEX): COMPLEX;
  (* Returns the arctangent of z *)

@findex polarToComplex
PROCEDURE polarToComplex (abs, arg: REAL): COMPLEX;
  (* Returns the complex number with the specified polar coordinates *)

@findex scalarMult
PROCEDURE scalarMult (scalar: REAL; z: COMPLEX): COMPLEX;
  (* Returns the scalar product of scalar with z *)

@findex IsCMathException
PROCEDURE IsCMathException (): BOOLEAN;
  (* Returns TRUE if the current coroutine is in the exceptional execution state
     because of the raising of an exception in a routine from this module; otherwise
     returns FALSE.
  *)

END ComplexMath.

@end example
@page


@node gm2-iso/ConvTypes, gm2-iso/EXCEPTIONS, gm2-iso/ComplexMath, M2 ISO Libraries
@subsection gm2-iso/ConvTypes

@example
DEFINITION MODULE ConvTypes;

  (* Common types used in the string conversion modules *)

TYPE
  ConvResults =     (* Values of this type are used to express the format of a string *)
  (
    strAllRight,    (* the string format is correct for the corresponding conversion *)
    strOutOfRange,  (* the string is well-formed but the value cannot be represented *)
    strWrongFormat, (* the string is in the wrong format for the conversion *)
    strEmpty        (* the given string is empty *)
  );

  ScanClass =  (* Values of this type are used to classify input to finite state scanners *)
  (
    padding,   (* a leading or padding character at this point in the scan - ignore it *)
    valid,     (* a valid character at this point in the scan - accept it *)
    invalid,   (* an invalid character at this point in the scan - reject it *)
    terminator (* a terminating character at this point in the scan (not part of token) *)
  );

  ScanState =  (* The type of lexical scanning control procedures *)
    PROCEDURE (CHAR, VAR ScanClass, VAR ScanState);

END ConvTypes.

@end example
@page


@node gm2-iso/EXCEPTIONS, gm2-iso/GeneralUser, gm2-iso/ConvTypes, M2 ISO Libraries
@subsection gm2-iso/EXCEPTIONS

@example
DEFINITION MODULE EXCEPTIONS;

(* Provides facilities for raising user exceptions
   and for making enquiries concerning the current execution state.
*)

TYPE
  ExceptionSource;                (* values of this type are used within library modules to
                                     identify the source of raised exceptions
 *)
  ExceptionNumber = CARDINAL;

@findex AllocateSource
PROCEDURE AllocateSource(VAR newSource: ExceptionSource);
  (* Allocates a unique value of type ExceptionSource *)

@findex RAISE
PROCEDURE RAISE (source: ExceptionSource; number: ExceptionNumber; message: ARRAY OF CHAR);
  (* Associates the given values of source, number and message with the current context
     and raises an exception.
  *)

@findex CurrentNumber
PROCEDURE CurrentNumber (source: ExceptionSource): ExceptionNumber;
  (* If the current coroutine is in the exceptional execution state because of the raising
     of an exception from source, returns the corresponding number, and otherwise
     raises an exception.
  *)

@findex GetMessage
PROCEDURE GetMessage (VAR text: ARRAY OF CHAR);
  (* If the current coroutine is in the exceptional execution state, returns the possibly
     truncated string associated with the current context.
     Otherwise, in normal execution state, returns the empty string.
  *)

@findex IsCurrentSource
PROCEDURE IsCurrentSource (source: ExceptionSource): BOOLEAN;
  (* If the current coroutine is in the exceptional execution state because of the raising
     of an exception from source, returns TRUE, and otherwise returns FALSE.
  *)

@findex IsExceptionalExecution
PROCEDURE IsExceptionalExecution (): BOOLEAN;
  (* If the current coroutine is in the exceptional execution state because of the raising
     of an exception, returns TRUE, and otherwise returns FALSE.
  *)

END EXCEPTIONS.
@end example
@page


@node gm2-iso/GeneralUser, gm2-iso/IOChan, gm2-iso/EXCEPTIONS, M2 ISO Libraries
@subsection gm2-iso/GeneralUser

@example
DEFINITION MODULE GeneralUserExceptions;

(* Provides facilities for general user-defined exceptions *)

TYPE
  GeneralExceptions = (problem, disaster);

@findex RaiseGeneralException
PROCEDURE RaiseGeneralException (exception: GeneralExceptions; text: ARRAY OF CHAR);
  (* Raises exception using text as the associated message *)

@findex IsGeneralException
PROCEDURE IsGeneralException (): BOOLEAN;
  (* Returns TRUE if the current coroutine is in the exceptional execution state
     because of the raising of an exception from GeneralExceptions;
     otherwise returns FALSE.
  *)

@findex GeneralException
PROCEDURE GeneralException(): GeneralExceptions;
  (* If the current coroutine is in the exceptional execution state because of the
     raising of an exception from GeneralExceptions, returns the corresponding
     enumeration value, and otherwise raises an exception.
  *)

END GeneralUserExceptions.
@end example
@page


@node gm2-iso/IOChan, gm2-iso/IOConsts, gm2-iso/GeneralUser, M2 ISO Libraries
@subsection gm2-iso/IOChan

@example
DEFINITION MODULE IOChan;

  (* Types and procedures forming the interface to channels for
device-independent data
     transfer modules
  *)

IMPORT IOConsts, ChanConsts, SYSTEM;

TYPE
  ChanId; (* Values of this type are used to identify channels *)

  (* There is one pre-defined value identifying an invalid channel on which
     no data transfer operations are available.  It may be used to
     initialize variables of type ChanId.
  *)

@findex InvalidChan
PROCEDURE InvalidChan (): ChanId;
  (* Returns the value identifying the invalid channel. *)

  (* For each of the following operations, if the device supports the
     operation on the channel, the behaviour of the procedure conforms
     with the description below.  The full behaviour is defined for
     each device module.  If the device does not support the operation
     on the channel, the behaviour of the procedure is to raise the exception
     notAvailable.
  *)

  (* Text operations - these perform any required translation between the
     internal and external representation of text.
  *)

@findex Look
PROCEDURE Look (cid: ChanId; VAR ch: CHAR; VAR res: IOConsts.ReadResults);
  (* If there is a character as the next item in the input stream cid,
     assigns its value to ch without removing it from the stream;
     otherwise the value of ch is not defined.  res
     (and the stored read result) are set to the value allRight,
      endOfLine, or endOfInput.
  *)

@findex Skip
PROCEDURE Skip (cid: ChanId);
  (* If the input stream cid has ended, the exception skipAtEnd
     is raised; otherwise the next character or line mark in cid is removed,
     and the stored read result is set to the value allRight.
  *)

@findex SkipLook
PROCEDURE SkipLook (cid: ChanId; VAR ch: CHAR; VAR res: IOConsts.ReadResults);
  (* If the input stream cid has ended, the exception skipAtEnd is raised;
     otherwise the next character or line mark in cid is removed.
     If there is a character as the next item in cid stream, assigns
     its value to ch without removing it from the stream.
     Otherwise, the value of ch is not defined.  res (and the stored
     read result) are set to the value allRight, endOfLine, or endOfInput.
  *)

@findex WriteLn
PROCEDURE WriteLn (cid: ChanId);
  (* Writes a line mark over the channel cid. *)

@findex TextRead
PROCEDURE TextRead (cid: ChanId; to: SYSTEM.ADDRESS; maxChars: CARDINAL;
                    VAR charsRead: CARDINAL);
  (* Reads at most maxChars characters from the current line in cid,
     and assigns corresponding values to successive components of
     an ARRAY OF CHAR variable for which the address of the first
     component is to. The number of characters read is assigned to charsRead.
     The stored read result is set to allRight, endOfLine, or endOfInput.
  *)

@findex TextWrite
PROCEDURE TextWrite (cid: ChanId; from: SYSTEM.ADDRESS;
                     charsToWrite: CARDINAL);
  (* Writes a number of characters given by the value of charsToWrite,
     from successive components of an ARRAY OF CHAR variable for which
     the address of the first component is from, to the channel cid.
  *)

  (* Direct raw operations  - these do not effect translation between
     the internal and external representation of data
  *)

@findex RawRead
PROCEDURE RawRead (cid: ChanId; to: SYSTEM.ADDRESS; maxLocs: CARDINAL;
                   VAR locsRead: CARDINAL);
  (* Reads at most maxLocs items from cid, and assigns corresponding
     values to successive components of an ARRAY OF LOC variable for
     which the address of the first component is to. The number of
     characters read is assigned to charsRead. The stored read result
     is set to the value allRight, or endOfInput.
  *)

@findex RawWrite
PROCEDURE RawWrite (cid: ChanId; from: SYSTEM.ADDRESS; locsToWrite: CARDINAL);
  (* Writes a number of items given by the value of charsToWrite,
     from successive components of an ARRAY OF LOC variable for
     which the address of the first component is from, to the channel cid.
  *)

  (* Common operations *)

@findex GetName
PROCEDURE GetName (cid: ChanId; VAR s: ARRAY OF CHAR);
  (* Copies to s a name associated with the channel cid, possibly truncated
     (depending on the capacity of s).
  *)

@findex Reset
PROCEDURE Reset (cid: ChanId);
  (* Resets the channel cid to a state defined by the device module. *)

@findex Flush
PROCEDURE Flush (cid: ChanId);
  (* Flushes any data buffered by the device module out to the channel cid. *)

  (* Access to read results *)

@findex SetReadResult
PROCEDURE SetReadResult (cid: ChanId; res: IOConsts.ReadResults);
  (* Sets the read result value for the channel cid to the value res. *)

@findex ReadResult
PROCEDURE ReadResult (cid: ChanId): IOConsts.ReadResults;
  (* Returns the stored read result value for the channel cid.
     (This is initially the value notKnown).
  *)

  (* Users can discover which flags actually apply to a channel *)

@findex CurrentFlags
PROCEDURE CurrentFlags (cid: ChanId): ChanConsts.FlagSet;
  (* Returns the set of flags that currently apply to the channel cid. *)

  (* The following exceptions are defined for this module and its clients *)

TYPE
  ChanExceptions =
    (wrongDevice,      (* device specific operation on wrong device *)
     notAvailable,     (* operation attempted that is not available on that
                          channel *)
     skipAtEnd,        (* attempt to skip data from a stream that has ended *)
     softDeviceError,  (* device specific recoverable error *)
     hardDeviceError,  (* device specific non-recoverable error *)
     textParseError,   (* input data does not correspond to a character or
                          line mark - optional detection *)
     notAChannel       (* given value does not identify a channel -
                          optional detection *)
    );

@findex IsChanException
PROCEDURE IsChanException (): BOOLEAN;
  (* Returns TRUE if the current coroutine is in the exceptional
     execution state because of the raising of an exception from
     ChanExceptions; otherwise returns FALSE.
  *)

@findex ChanException
PROCEDURE ChanException (): ChanExceptions;
  (* If the current coroutine is in the exceptional execution state
     because of the raising of an exception from ChanExceptions,
     returns the corresponding enumeration value, and otherwise
     raises an exception.
  *)

  (* When a device procedure detects a device error, it raises the
     exception softDeviceError or hardDeviceError.  If these
     exceptions are handled, the following facilities may be
     used to discover an implementation-defined error number for
     the channel.
  *)

TYPE
  DeviceErrNum = INTEGER;

@findex DeviceError
PROCEDURE DeviceError (cid: ChanId): DeviceErrNum;
  (* If a device error exception has been raised for the channel cid,
     returns the error number stored by the device module.
  *)

END IOChan.

@end example
@page


@node gm2-iso/IOConsts, gm2-iso/IOLink, gm2-iso/IOChan, M2 ISO Libraries
@subsection gm2-iso/IOConsts

@example
DEFINITION MODULE IOConsts;

  (* Types and constants for input/output modules *)

TYPE
  ReadResults =  (* This type is used to classify the result of an input operation *)
  (
    notKnown,    (* no read result is set *)
    allRight,    (* data is as expected or as required *)
    outOfRange,  (* data cannot be represented *)
    wrongFormat, (* data not in expected format *)
    endOfLine,   (* end of line seen before expected data *)
    endOfInput   (* end of input seen before expected data *)
  );

END IOConsts.

@end example
@page


@node gm2-iso/IOLink, gm2-iso/IOResult, gm2-iso/IOConsts, M2 ISO Libraries
@subsection gm2-iso/IOLink

@example
DEFINITION MODULE IOLink;

  (* Types and procedures for the standard implementation of channels *)

IMPORT IOChan, IOConsts, ChanConsts, SYSTEM;

TYPE
  DeviceId;
    (* Values of this type are used to identify new device modules, and are normally
       obtained by them during their initialization.
    *)

@findex AllocateDeviceId
PROCEDURE AllocateDeviceId (VAR did: DeviceId);
  (* Allocates a unique value of type DeviceId, and assigns this value to did. *)

@findex MakeChan
PROCEDURE MakeChan (did: DeviceId; VAR cid: IOChan.ChanId);
  (* Attempts to make a new channel for the device module identified by did. If no more
     channels can be made, the identity of the invalid channel is assigned to cid.
     Otherwise, the identity of a new channel is assigned to cid.
  *)

@findex UnMakeChan
PROCEDURE UnMakeChan (did: DeviceId; VAR cid: IOChan.ChanId);
  (* If the device module identified by did is not the module that made the channel
     identified by cid, the exception wrongDevice is raised; otherwise the channel is
     deallocated, and the value identifying the invalid channel is assigned to cid.
  *)

TYPE
  DeviceTablePtr = POINTER TO DeviceTable;
    (* Values of this type are used to refer to device tables *)

TYPE
  LookProc =      PROCEDURE (DeviceTablePtr, VAR CHAR, VAR IOConsts.ReadResults);
  SkipProc =      PROCEDURE (DeviceTablePtr);
  SkipLookProc =  PROCEDURE (DeviceTablePtr, VAR CHAR, VAR IOConsts.ReadResults);
  WriteLnProc =   PROCEDURE (DeviceTablePtr);
  TextReadProc =  PROCEDURE (DeviceTablePtr, SYSTEM.ADDRESS, CARDINAL, VAR CARDINAL);
  TextWriteProc = PROCEDURE (DeviceTablePtr, SYSTEM.ADDRESS, CARDINAL);
  RawReadProc =   PROCEDURE (DeviceTablePtr, SYSTEM.ADDRESS, CARDINAL, VAR CARDINAL);
  RawWriteProc =  PROCEDURE (DeviceTablePtr, SYSTEM.ADDRESS, CARDINAL);
  GetNameProc =   PROCEDURE (DeviceTablePtr, VAR ARRAY OF CHAR);
  ResetProc =     PROCEDURE (DeviceTablePtr);
  FlushProc =     PROCEDURE (DeviceTablePtr);
  FreeProc =      PROCEDURE (DeviceTablePtr);
      (* Carry out the operations involved in closing the corresponding channel, including
         flushing buffers, but do not unmake the channel.
      *)

TYPE
  DeviceData = SYSTEM.ADDRESS;

  DeviceTable =
    RECORD                         (* Initialized by MakeChan to: *)
      cd: DeviceData;              (* the value NIL *)
      did: DeviceId;               (* the value given in the call of MakeChan *)
      cid: IOChan.ChanId;          (* the identity of the channel *)
      result: IOConsts.ReadResults;(* the value notKnown *)
      errNum: IOChan.DeviceErrNum; (* undefined *)
      flags: ChanConsts.FlagSet;   (* ChanConsts.FlagSet@{@} *)
      doLook: LookProc;            (* raise exception notAvailable *)
      doSkip: SkipProc;            (* raise exception notAvailable *)
      doSkipLook: SkipLookProc;    (* raise exception notAvailable *)
      doLnWrite: WriteLnProc;      (* raise exception notAvailable *)
      doTextRead: TextReadProc;    (* raise exception notAvailable *)
      doTextWrite: TextWriteProc;  (* raise exception notAvailable *)
      doRawRead: RawReadProc;      (* raise exception notAvailable *)
      doRawWrite: RawWriteProc;    (* raise exception notAvailable *)
      doGetName: GetNameProc;      (* return the empty string *)
      doReset: ResetProc;          (* do nothing *)
      doFlush: FlushProc;          (* do nothing *)
      doFree: FreeProc;            (* do nothing *)
    END;


  (* The pointer to the device table for a channel is obtained using the
     following procedure: *)

@findex DeviceTablePtrValue
PROCEDURE DeviceTablePtrValue (cid: IOChan.ChanId; did: DeviceId;
                               x: DevExceptionRange; s:  ARRAY OF CHAR): DeviceTablePtr;
  (* If the device module identified by did is not the module that made the channel
     identified by cid, the exception wrongDevice is raised; otherwise the given exception
     is raised, and the string value in s is included in the exception message.
  *)


@findex IsDevice
PROCEDURE IsDevice (cid: IOChan.ChanId; did: DeviceId) : BOOLEAN;
  (* Tests if the device module identified by did is the module that made the channel
     identified by cid.
  *)


TYPE
  DevExceptionRange = [IOChan.notAvailable ..  IOChan.textParseError];

@findex RAISEdevException
PROCEDURE RAISEdevException (cid: IOChan.ChanId; did: DeviceId;
                             x: DevExceptionRange; s: ARRAY OF CHAR);

  (* If the device module identified by did is not the module that made the channel
     identified by cid, the exception wrongDevice is raised; otherwise the given exception
     is raised, and the string value in s is included in the exception message.
  *)

@findex IsIOException
PROCEDURE IsIOException () : BOOLEAN;
  (* Returns TRUE if the current coroutine is in the exceptional execution state
     because of the raising af an exception from ChanExceptions;
     otherwise FALSE.
  *)

@findex IOException
PROCEDURE IOException () : IOChan.ChanExceptions;
  (* If the current coroutine is in the exceptional execution state because of the
     raising af an exception from ChanExceptions, returns the corresponding
     enumeration value, and otherwise raises an exception.
  *)

END IOLink.
@end example
@page


@node gm2-iso/IOResult, gm2-iso/LongComplex, gm2-iso/IOLink, M2 ISO Libraries
@subsection gm2-iso/IOResult

@example
DEFINITION MODULE IOResult;

  (* Read results for specified channels *)

IMPORT IOConsts, IOChan;

TYPE
  ReadResults = IOConsts.ReadResults;

  (*
    ReadResults =  (* This type is used to classify the result of an input operation *)
    (
      notKnown,    (* no read result is set *)
      allRight,    (* data is as expected or as required *)
      outOfRange,  (* data cannot be represented *)
      wrongFormat, (* data not in expected format *)
      endOfLine,   (* end of line seen before expected data *)
      endOfInput   (* end of input seen before expected data *)
    );
  *)

@findex ReadResult
PROCEDURE ReadResult (cid: IOChan.ChanId): ReadResults;
  (* Returns the result for the last read operation on the channel cid. *)

END IOResult.

@end example
@page


@node gm2-iso/LongComplex, gm2-iso/LongConv, gm2-iso/IOResult, M2 ISO Libraries
@subsection gm2-iso/LongComplex

@example
DEFINITION MODULE LongComplexMath;

  (* Mathematical functions for the type LONGCOMPLEX *)

CONST
  i =    CMPLX (0.0, 1.0);
  one =  CMPLX (1.0, 0.0);
  zero = CMPLX (0.0, 0.0);

@findex abs
PROCEDURE abs (z: LONGCOMPLEX): LONGREAL;
  (* Returns the length of z *)

@findex arg
PROCEDURE arg (z: LONGCOMPLEX): LONGREAL;
  (* Returns the angle that z subtends to the positive real axis *)

@findex conj
PROCEDURE conj (z: LONGCOMPLEX): LONGCOMPLEX;
  (* Returns the complex conjugate of z *)

@findex power
PROCEDURE power (base: LONGCOMPLEX; exponent: LONGREAL): LONGCOMPLEX;
  (* Returns the value of the number base raised to the power exponent *)

@findex sqrt
PROCEDURE sqrt (z: LONGCOMPLEX): LONGCOMPLEX;
  (* Returns the principal square root of z *)

@findex exp
PROCEDURE exp (z: LONGCOMPLEX): LONGCOMPLEX;
  (* Returns the complex exponential of z *)

@findex ln
PROCEDURE ln (z: LONGCOMPLEX): LONGCOMPLEX;
  (* Returns the principal value of the natural logarithm of z *)

@findex sin
PROCEDURE sin (z: LONGCOMPLEX): LONGCOMPLEX;
  (* Returns the sine of z *)

@findex cos
PROCEDURE cos (z: LONGCOMPLEX): LONGCOMPLEX;
  (* Returns the cosine of z *)

@findex tan
PROCEDURE tan (z: LONGCOMPLEX): LONGCOMPLEX;
  (* Returns the tangent of z *)

@findex arcsin
PROCEDURE arcsin (z: LONGCOMPLEX): LONGCOMPLEX;
  (* Returns the arcsine of z *)

@findex arccos
PROCEDURE arccos (z: LONGCOMPLEX): LONGCOMPLEX;
  (* Returns the arccosine of z *)

@findex arctan
PROCEDURE arctan (z: LONGCOMPLEX): LONGCOMPLEX;
  (* Returns the arctangent of z *)

@findex polarToComplex
PROCEDURE polarToComplex (abs, arg: LONGREAL): LONGCOMPLEX;
  (* Returns the complex number with the specified polar coordinates *)

@findex scalarMult
PROCEDURE scalarMult (scalar: LONGREAL; z: LONGCOMPLEX): LONGCOMPLEX;
  (* Returns the scalar product of scalar with z *)

@findex IsCMathException
PROCEDURE IsCMathException (): BOOLEAN;
  (* Returns TRUE if the current coroutine is in the exceptional execution state
     because of the raising of an exception in a routine from this module; otherwise
     returns FALSE.
  *)

END LongComplexMath.

@end example
@page


@node gm2-iso/LongConv, gm2-iso/LongIO, gm2-iso/LongComplex, M2 ISO Libraries
@subsection gm2-iso/LongConv

@example
DEFINITION MODULE LongConv;

  (* Low-level LONGREAL/string conversions *)

IMPORT
  ConvTypes;

TYPE
  ConvResults = ConvTypes.ConvResults; (* strAllRight, strOutOfRange, strWrongFormat, strEmpty *)

@findex ScanReal
PROCEDURE ScanReal (inputCh: CHAR; VAR chClass: ConvTypes.ScanClass;
                    VAR nextState: ConvTypes.ScanState);
  (* Represents the start state of a finite state scanner for real numbers - assigns
     class of inputCh to chClass and a procedure representing the next state to
     nextState.
  *)

@findex FormatReal
PROCEDURE FormatReal (str: ARRAY OF CHAR): ConvResults;
  (* Returns the format of the string value for conversion to LONGREAL. *)

@findex ValueReal
PROCEDURE ValueReal (str: ARRAY OF CHAR): LONGREAL;
  (* Returns the value corresponding to the real number string value str if str is
     well-formed; otherwise raises the LongConv exception.
  *)

@findex LengthFloatReal
PROCEDURE LengthFloatReal (real: LONGREAL; sigFigs: CARDINAL): CARDINAL;
  (* Returns the number of characters in the floating-point string representation of
     real with sigFigs significant figures.
  *)

@findex LengthEngReal
PROCEDURE LengthEngReal (real: LONGREAL; sigFigs: CARDINAL): CARDINAL;
  (* Returns the number of characters in the floating-point engineering string
     representation of real with sigFigs significant figures.
  *)

@findex LengthFixedReal
PROCEDURE LengthFixedReal (real: LONGREAL; place: INTEGER): CARDINAL;
  (* Returns the number of characters in the fixed-point string representation of real
     rounded to the given place relative to the decimal point.
  *)

@findex IsRConvException
PROCEDURE IsRConvException (): BOOLEAN;
  (* Returns TRUE if the current coroutine is in the exceptional execution state because
     of the raising of an exception in a routine from this module; otherwise returns
     FALSE.
  *)

END LongConv.

@end example
@page


@node gm2-iso/LongIO, gm2-iso/LongMath, gm2-iso/LongConv, M2 ISO Libraries
@subsection gm2-iso/LongIO

@example
DEFINITION MODULE LongIO;

  (* Input and output of long real numbers in decimal text form over specified channels.
     The read result is of the type IOConsts.ReadResults.
  *)

IMPORT IOChan;

  (* The text form of a signed fixed-point real number is
       ["+" | "-"], decimal digit, @{decimal digit@}, [".", @{decimal digit@}]

     The text form of a signed floating-point real number is
       signed fixed-point real number,
       "E", ["+" | "-"], decimal digit, @{decimal digit@}
  *)

@findex ReadReal
PROCEDURE ReadReal (cid: IOChan.ChanId; VAR real: LONGREAL);
  (* Skips leading spaces, and removes any remaining characters from cid that form part of a
     signed fixed or floating point number.  The value of this number is assigned to real.
     The read result is set to the value allRight, outOfRange, wrongFormat, endOfLine, or
     endOfInput.
  *)

@findex WriteFloat
PROCEDURE WriteFloat (cid: IOChan.ChanId; real: LONGREAL; sigFigs: CARDINAL; width: CARDINAL);
  (* Writes the value of real to cid in floating-point text form, with sigFigs significant
     figures, in a field of the given minimum width.
  *)

@findex WriteEng
PROCEDURE WriteEng (cid: IOChan.ChanId; real: LONGREAL; sigFigs: CARDINAL; width: CARDINAL);
  (* As for WriteFloat, except that the number is scaled with one to three digits in the
     whole number part, and with an exponent that is a multiple of three.
  *)

@findex WriteFixed
PROCEDURE WriteFixed (cid: IOChan.ChanId; real: LONGREAL; place: INTEGER; width: CARDINAL);
  (* Writes the value of real to cid in fixed-point text form, rounded to the given place
     relative to the decimal point, in a field of the given minimum width.
  *)

@findex WriteReal
PROCEDURE WriteReal (cid: IOChan.ChanId; real: LONGREAL; width: CARDINAL);
  (* Writes the value of real to cid, as WriteFixed if the sign and magnitude can be shown
     in the given width, or otherwise as WriteFloat.  The number of places or significant
     digits depends on the given width.
  *)

END LongIO.

@end example
@page


@node gm2-iso/LongMath, gm2-iso/LongStr, gm2-iso/LongIO, M2 ISO Libraries
@subsection gm2-iso/LongMath

@example
DEFINITION MODULE LongMath;

  (* Mathematical functions for the type LONGREAL *)

CONST
  pi   = 3.1415926535897932384626433832795028841972;
  exp1 = 2.7182818284590452353602874713526624977572;

@findex sqrt
PROCEDURE __BUILTIN__ sqrt (x: LONGREAL): LONGREAL;
  (* Returns the positive square root of x *)

@findex exp
PROCEDURE exp (x: LONGREAL): LONGREAL;
  (* Returns the exponential of x *)

@findex ln
PROCEDURE ln (x: LONGREAL): LONGREAL;
  (* Returns the natural logarithm of x *)

  (* The angle in all trigonometric functions is measured in radians *)

@findex sin
PROCEDURE __BUILTIN__ sin (x: LONGREAL): LONGREAL;
  (* Returns the sine of x *)

@findex cos
PROCEDURE __BUILTIN__ cos (x: LONGREAL): LONGREAL;
  (* Returns the cosine of x *)

@findex tan
PROCEDURE tan (x: LONGREAL): LONGREAL;
  (* Returns the tangent of x *)

@findex arcsin
PROCEDURE arcsin (x: LONGREAL): LONGREAL;
  (* Returns the arcsine of x *)

@findex arccos
PROCEDURE arccos (x: LONGREAL): LONGREAL;
  (* Returns the arccosine of x *)

@findex arctan
PROCEDURE arctan (x: LONGREAL): LONGREAL;
  (* Returns the arctangent of x *)

@findex power
PROCEDURE power (base, exponent: LONGREAL): LONGREAL;
  (* Returns the value of the number base raised to the power exponent *)

@findex round
PROCEDURE round (x: LONGREAL): INTEGER;
  (* Returns the value of x rounded to the nearest integer *)

@findex IsRMathException
PROCEDURE IsRMathException (): BOOLEAN;
  (* Returns TRUE if the current coroutine is in the exceptional execution state
     because of the raising of an exception in a routine from this module; otherwise
     returns FALSE.
  *)

END LongMath.

@end example
@page


@node gm2-iso/LongStr, gm2-iso/LowLong, gm2-iso/LongMath, M2 ISO Libraries
@subsection gm2-iso/LongStr

@example
DEFINITION MODULE LongStr;

  (* LONGREAL/string conversions *)

IMPORT
  ConvTypes;

TYPE
  ConvResults = ConvTypes.ConvResults; (* strAllRight, strOutOfRange, strWrongFormat, strEmpty *)

(* the string form of a signed fixed-point real number is
     ["+" | "-"], decimal digit, @{decimal digit@}, [".", @{decimal digit@}]
*)

(* the string form of a signed floating-point real number is
     signed fixed-point real number, "E", ["+" | "-"], decimal digit, @{decimal digit@}
*)

@findex StrToReal
PROCEDURE StrToReal (str: ARRAY OF CHAR; VAR real: LONGREAL; VAR res: ConvResults);
  (* Ignores any leading spaces in str. If the subsequent characters in str are in the
     format of a signed real number, assigns a corresponding value to real.
     Assigns a value indicating the format of str to res.
  *)

@findex RealToFloat
PROCEDURE RealToFloat (real: LONGREAL; sigFigs: CARDINAL; VAR str: ARRAY OF CHAR);
  (* Converts the value of real to floating-point string form, with sigFigs significant
     figures, and copies the possibly truncated result to str.
  *)

@findex RealToEng
PROCEDURE RealToEng (real: LONGREAL; sigFigs: CARDINAL; VAR str: ARRAY OF CHAR);
  (* Converts the value of real to floating-point string form, with sigFigs significant
     figures, and copies the possibly truncated result to str. The number is scaled with
     one to three digits in the whole number part and with an exponent that is a
     multiple of three.
  *)

@findex RealToFixed
PROCEDURE RealToFixed (real: LONGREAL; place: INTEGER; VAR str: ARRAY OF CHAR);
  (* Converts the value of real to fixed-point string form, rounded to the given place
     relative to the decimal point, and copies the possibly truncated result to str.
  *)

@findex RealToStr
PROCEDURE RealToStr (real: LONGREAL; VAR str: ARRAY OF CHAR);
  (* Converts the value of real as RealToFixed if the sign and magnitude can be shown
     within the capacity of str, or otherwise as RealToFloat, and copies the possibly
     truncated result to str. The number of places or significant digits depend on the
     capacity of str.
  *)

END LongStr.

@end example
@page


@node gm2-iso/LowLong, gm2-iso/LowReal, gm2-iso/LongStr, M2 ISO Libraries
@subsection gm2-iso/LowLong

@example
DEFINITION MODULE LowLong;

  (* Access to underlying properties of the type LONGREAL *)

CONST
  radix =      <implementation-defined whole number value>;
  places =     <implementation-defined whole number value>;
  expoMin =    <implementation-defined whole number value>;
  expoMax =    <implementation-defined whole number value>;
  large =      <implementation-defined real number value>;
  small =      <implementation-defined real number value>;
  IEEE =       <implementation-defined BOOLEAN value>;
  ISO =        <implementation-defined BOOLEAN value>;
  rounds =     <implementation-defined BOOLEAN value>;
  gUnderflow = <implementation-defined BOOLEAN value>;
  exception =  <implementation-defined BOOLEAN value>;
  extend =     <implementation-defined BOOLEAN value>;
  nModes =     <implementation-defined whole number value>;

TYPE
  Modes = PACKEDSET OF [0 .. nModes-1];

@findex exponent
PROCEDURE exponent (x: LONGREAL): INTEGER;
  (* Returns the exponent value of x *)

@findex fraction
PROCEDURE fraction (x: LONGREAL): LONGREAL;
  (* Returns the significand (or significant part) of x *)

@findex sign
PROCEDURE sign (x: LONGREAL): LONGREAL;
  (* Returns the signum of x *)

@findex succ
PROCEDURE succ (x: LONGREAL): LONGREAL;
  (* Returns the next value of the type LONGREAL greater than x *)

@findex ulp
PROCEDURE ulp (x: LONGREAL): LONGREAL;
  (* Returns the value of a unit in the last place of x *)

@findex pred
PROCEDURE pred (x: LONGREAL): LONGREAL;
  (* Returns the previous value of the type LONGREAL less than x *)

@findex intpart
PROCEDURE intpart (x: LONGREAL): LONGREAL;
  (* Returns the integer part of x *)

@findex fractpart
PROCEDURE fractpart (x: LONGREAL): LONGREAL;
  (* Returns the fractional part of x *)

@findex scale
PROCEDURE scale (x: LONGREAL; n: INTEGER): LONGREAL;
  (* Returns the value of x * radix ** n *)

@findex trunc
PROCEDURE trunc (x: LONGREAL; n: INTEGER): LONGREAL;
  (* Returns the value of the first n places of x *)

@findex round
PROCEDURE round (x: LONGREAL; n: INTEGER): LONGREAL;
  (* Returns the value of x rounded to the first n places *)

@findex synthesize
PROCEDURE synthesize (expart: INTEGER; frapart: LONGREAL): LONGREAL;
  (* Returns a value of the type LONGREAL constructed from the given expart and frapart *)

@findex setMode
PROCEDURE setMode (m: Modes);
  (* Sets status flags appropriate to the underlying implementation of the type LONGREAL *)

@findex currentMode
PROCEDURE currentMode (): Modes;
  (* Returns the current status flags in the form set by setMode *)

@findex IsLowException
PROCEDURE IsLowException (): BOOLEAN;
  (* Returns TRUE if the current coroutine is in the exceptional execution state
     because of the raising of an exception in a routine from this module; otherwise
     returns FALSE.
  *)

END LowLong.

@end example
@page


@node gm2-iso/LowReal, gm2-iso/M2EXCEPTION, gm2-iso/LowLong, M2 ISO Libraries
@subsection gm2-iso/LowReal

@example
DEFINITION MODULE LowReal;

  (* Access to underlying properties of the type REAL *)

CONST
  radix =      <implementation-defined whole number value>;
  places =     <implementation-defined whole number value>;
  expoMin =    <implementation-defined whole number value>;
  expoMax =    <implementation-defined whole number value>;
  large =      <implementation-defined real number value>;
  small =      <implementation-defined real number value>;
  IEEE =       <implementation-defined BOOLEAN value>;
  ISO =        <implementation-defined BOOLEAN value>;
  rounds =     <implementation-defined BOOLEAN value>;
  gUnderflow = <implementation-defined BOOLEAN value>;
  exception =  <implementation-defined BOOLEAN value>;
  extend =     <implementation-defined BOOLEAN value>;
  nModes =     <implementation-defined whole number value>;

TYPE
  Modes = SET OF [0 .. nModes-1];

@findex exponent
PROCEDURE exponent (x: REAL): INTEGER;
  (* Returns the exponent value of x *)

@findex fraction
PROCEDURE fraction (x: REAL): REAL;
  (* Returns the significand (or significant part) of x *)

@findex sign
PROCEDURE sign (x: REAL): REAL;
  (* Returns the signum of x *)

@findex succ
PROCEDURE succ (x: REAL): REAL;
  (* Returns the next value of the type REAL greater than x *)

@findex ulp
PROCEDURE ulp (x: REAL): REAL;
  (* Returns the value of a unit in the last place of x *)

@findex pred
PROCEDURE pred (x: REAL): REAL;
  (* Returns the previous value of the type REAL less than x *)

@findex intpart
PROCEDURE intpart (x: REAL): REAL;
  (* Returns the integer part of x *)

@findex fractpart
PROCEDURE fractpart (x: REAL): REAL;
  (* Returns the fractional part of x *)

@findex scale
PROCEDURE scale (x: REAL; n: INTEGER): REAL;
  (* Returns the value of x * radix ** n *)

@findex trunc
PROCEDURE trunc (x: REAL; n: INTEGER): REAL;
  (* Returns the value of the first n places of x *)

@findex round
PROCEDURE round (x: REAL; n: INTEGER): REAL;
  (* Returns the value of x rounded to the first n places *)

@findex synthesize
PROCEDURE synthesize (expart: INTEGER; frapart: REAL): REAL;
  (* Returns a value of the type REAL constructed from the given expart and frapart *)

@findex setMode
PROCEDURE setMode (m: Modes);
  (* Sets status flags appropriate to the underlying implementation of the type REAL *)

@findex currentMode
PROCEDURE currentMode (): Modes;
  (* Returns the current status flags in the form set by setMode *)

@findex IsLowException
PROCEDURE IsLowException (): BOOLEAN;
  (* Returns TRUE if the current coroutine is in the exceptional execution state
     because of the raising of an exception in a routine from this module; otherwise
     returns FALSE.
  *)

END LowReal.

@end example
@page


@node gm2-iso/M2EXCEPTION, gm2-iso/M2RTS, gm2-iso/LowReal, M2 ISO Libraries
@subsection gm2-iso/M2EXCEPTION

@example
DEFINITION MODULE M2EXCEPTION;

(* Provides facilities for identifying language exceptions *)

TYPE
  M2Exceptions =
    (indexException,     rangeException,         caseSelectException,  invalidLocation,
     functionException,  wholeValueException,    wholeDivException,    realValueException,
     realDivException,   complexValueException,  complexDivException,  protException,
     sysException,       coException,            exException
    );

@findex M2Exception
PROCEDURE M2Exception (): M2Exceptions;
  (* If the current coroutine is in the exceptional execution state because of the raising
     of a language exception, returns the corresponding enumeration value, and otherwise
     raises an exception.
  *)

@findex IsM2Exception
PROCEDURE IsM2Exception (): BOOLEAN;
  (* If the current coroutine is in the exceptional execution state because of the raising
     of a language exception, returns TRUE, and otherwise returns FALSE.
  *)

END M2EXCEPTION.
@end example
@page


@node gm2-iso/M2RTS, gm2-iso/Processes, gm2-iso/M2EXCEPTION, M2 ISO Libraries
@subsection gm2-iso/M2RTS

@example
DEFINITION MODULE M2RTS ;

(*
   Description: Implements the run time system facilities of Modula-2.
*)

FROM SYSTEM IMPORT BITSET ;
EXPORT QUALIFIED HALT, Halt,
                 SubrangeAssignmentError, ArraySubscriptError,
                 FunctionReturnError, NilPointerError,
                 CaseElseError,
                 InstallTerminationProcedure, Terminate,
                 ExitOnHalt, Length ;


(*
   HALT - terminate the current program.
          The procedure Terminate is called before the program is
          stopped.
*)

@findex HALT
PROCEDURE HALT ;


(*
   Halt - provides a more user friendly version of HALT, which takes
          four parameters to aid debugging.
*)

@findex Halt
PROCEDURE Halt (file: ARRAY OF CHAR; line: CARDINAL;
                function: ARRAY OF CHAR; description: ARRAY OF CHAR) ;


(*
   SubrangeAssignmentError - part of the runtime checking, called if a
                             subrange variable is just about to be assigned an illegal value.
*)

@findex SubrangeAssignmentError
PROCEDURE SubrangeAssignmentError (file: ARRAY OF CHAR;
                                   line: CARDINAL;
                                   function: ARRAY OF CHAR) ;


(*
   ArraySubscriptError -  part of the runtime checking, called if an
                          array indice is out of range.
*)

@findex ArraySubscriptError
PROCEDURE ArraySubscriptError (file: ARRAY OF CHAR;
                               line: CARDINAL;
                               function: ARRAY OF CHAR) ;


(*
   FunctionReturnError -  part of the runtime checking, called if a
                          function exits without a RETURN statement.
*)

@findex FunctionReturnError
PROCEDURE FunctionReturnError (file: ARRAY OF CHAR;
                               line: CARDINAL;
                               function: ARRAY OF CHAR) ;


(*
   NilPointerError -  part of the runtime checking, called if a
                      the code is about to dereference NIL.
*)

@findex NilPointerError
PROCEDURE NilPointerError (file: ARRAY OF CHAR;
                           line: CARDINAL;
                           function: ARRAY OF CHAR) ;


(*
   CaseElseError - part of the runtime checking, called if a
                   CASE statement falls into an ELSE statement
                   (which was not declared by the programmer).
*)

@findex CaseElseError
PROCEDURE CaseElseError (file: ARRAY OF CHAR;
                         line: CARDINAL;
                         function: ARRAY OF CHAR) ;


(*
   ExitOnHalt - if HALT is executed then call exit with the exit code, e.
*)

@findex ExitOnHalt
PROCEDURE ExitOnHalt (e: INTEGER) ;


(*
   InstallTerminationProcedure - installs a procedure, p, which will
                                 be called when the procedure Terminate
                                 is ionvoked.
*)

@findex InstallTerminationProcedure
PROCEDURE InstallTerminationProcedure (p: PROC) ;


(*
   Terminate - calls each installed termination procedure in turn.
*)

@findex Terminate
PROCEDURE Terminate ;


(*
   Length - returns the length of a string, a. This is called whenever
            the user calls LENGTH and the parameter cannot be calculated
            at compile time.
*)

@findex Length
PROCEDURE Length (a: ARRAY OF CHAR) : CARDINAL ;


END M2RTS.
@end example
@page


@node gm2-iso/Processes, gm2-iso/ProgramArgs, gm2-iso/M2RTS, M2 ISO Libraries
@subsection gm2-iso/Processes

@example
DEFINITION MODULE Processes;

  (* This module allows concurrent algorithms to be expressed using processes. A process is
     a unit of a program that has the potential to run in parallel with other processes.
  *)

IMPORT SYSTEM;

TYPE
  ProcessId;                      (* Used to identify processes *)
  Parameter     = SYSTEM.ADDRESS; (* Used to pass data between processes *)
  Body          = PROC;           (* Used as the type of a process body *)
  Urgency       = INTEGER;        (* Used by the internal scheduler *)
  Sources       = CARDINAL;       (* Used to identify event sources *)
  ProcessesExceptions =           (* Exceptions raised by this module *)
    (passiveProgram, processError);

(* The following procedures create processes and switch control between them. *)

@findex Create
PROCEDURE Create (procBody: Body; extraSpace: CARDINAL; procUrg: Urgency;
                  procParams: Parameter; VAR procId: ProcessId);
  (* Creates a new process with procBody as its body, and with urgency and parameters
     given by procUrg and procParams.  At least as much workspace (in units of
     SYSTEM.LOC) as is specified by extraSpace is allocated to the process.
     An identity for the new process is returned in procId.
     The process is created in the passive state; it will not run until activated.
  *)

@findex Start
PROCEDURE Start (procBody: Body; extraSpace: CARDINAL; procUrg: Urgency;
                 procParams: Parameter; VAR procId: ProcessId);
  (* Creates a new process, with parameters as for Create.
     The process is created in the ready state; it is eligible to run immediately.
  *)

@findex StopMe
PROCEDURE StopMe ();
  (* Terminates the calling process.
     The process must not be associated with a source of events.
  *)

@findex SuspendMe
PROCEDURE SuspendMe ();
  (* Causes the calling process to enter the passive state.  The procedure only returns
     when the calling process is again activated by another process.
  *)

@findex Activate
PROCEDURE Activate (procId: ProcessId);
  (* Causes the process identified by procId to enter the ready state, and thus to become
     eligible to run again.
  *)

@findex SuspendMeAndActivate
PROCEDURE SuspendMeAndActivate (procId: ProcessId);
  (* Executes an atomic sequence of SuspendMe() and Activate(procId). *)

@findex Switch
PROCEDURE Switch (procId: ProcessId; VAR info: Parameter);
  (* Causes the calling process to enter the passive state; the process identified by procId
     becomes the currently executing process.
     info is used to pass parameter information from the calling to the activated process.
     On return, info will contain information from the process that chooses to switch back to
     this one (or will be NIL if Activate or SuspendMeAndActivate are used instead of
     Switch).
  *)

@findex Wait
PROCEDURE Wait ();
  (* Causes the calling process to enter the waiting state.  The procedure will return when
     the calling process is activated by another process, or when one of its associated
     eventSources has generated an event.
  *)

(* The following procedures allow the association of processes with sources of external
   events.
*)

@findex Attach
PROCEDURE Attach (eventSource: Sources);
  (* Associates the specified eventSource with the calling process. *)

@findex Detach
PROCEDURE Detach (eventSource: Sources);
  (* Dissociates the specified eventSource from the program. *)

@findex IsAttached
PROCEDURE IsAttached (eventSource: Sources): BOOLEAN;
  (* Returns TRUE if and only if the specified eventSource is currently associated with
     one of the processes of the program.
  *)

@findex Handler
PROCEDURE Handler (eventSource: Sources): ProcessId;
  (* Returns the identity of the process, if any, that is associated with the specified
     eventSource.
  *)

(* The following procedures allow processes to obtain their identity, parameters, and
   urgency.
*)

@findex Me
PROCEDURE Me (): ProcessId;
  (* Returns the identity of the calling process (as assigned when the process was first
     created).
  *)

@findex MyParam
PROCEDURE MyParam (): Parameter;
  (* Returns the value specified as procParams when the calling process was created. *)

@findex UrgencyOf
PROCEDURE UrgencyOf (procId: ProcessId): Urgency;
  (* Returns the urgency established when the process identified by procId was first
     created.
  *)

(* The following procedure provides facilities for exception handlers. *)

@findex ProcessesException
PROCEDURE ProcessesException (): ProcessesExceptions;
  (* If the current coroutine is in the exceptional execution state because of the raising
     of a language exception, returns the corresponding enumeration value, and
     otherwise raises an exception.
  *)

@findex IsProcessesException
PROCEDURE IsProcessesException (): BOOLEAN;
  (* Returns TRUE if the current coroutine is in the exceptional execution state
     because of the raising of an exception in a routine from this module; otherwise
     returns FALSE.
  *)

END Processes.

@end example
@page


@node gm2-iso/ProgramArgs, gm2-iso/RawIO, gm2-iso/Processes, M2 ISO Libraries
@subsection gm2-iso/ProgramArgs

@example
DEFINITION MODULE ProgramArgs;

  (* Access to program arguments *)

IMPORT IOChan;

TYPE
  ChanId = IOChan.ChanId;

@findex ArgChan
PROCEDURE ArgChan (): ChanId;
  (* Returns a value that identifies a channel for reading program arguments *)

@findex IsArgPresent
PROCEDURE IsArgPresent (): BOOLEAN;
  (* Tests if there is a current argument to read from. If not, read <=
     IOChan.CurrentFlags() will be FALSE, and attempting to read from the argument channel
     will raise the exception notAvailable.
  *)

@findex NextArg
PROCEDURE NextArg ();
  (* If there is another argument, causes subsequent input from the argument device to come
     from the start of the next argument.  Otherwise there is no argument to read from, and
     a call of IsArgPresent will return FALSE.
  *)

END ProgramArgs.
@end example
@page


@node gm2-iso/RawIO, gm2-iso/RealConv, gm2-iso/ProgramArgs, M2 ISO Libraries
@subsection gm2-iso/RawIO

@example
DEFINITION MODULE RawIO;

  (* Reading and writing data over specified channels using raw operations, that is, with no
     conversion or interpretation. The read result is of the type IOConsts.ReadResults.
  *)

IMPORT IOChan, SYSTEM;

@findex Read
PROCEDURE Read (cid: IOChan.ChanId; VAR to: ARRAY OF SYSTEM.LOC);
  (* Reads storage units from cid, and assigns them to successive components of to. The read
     result is set to the value allRight, wrongFormat, or endOfInput.
  *)

@findex Write
PROCEDURE Write (cid: IOChan.ChanId; from: ARRAY OF SYSTEM.LOC);
  (* Writes storage units to cid from successive components of from. *)

END RawIO.

@end example
@page


@node gm2-iso/RealConv, gm2-iso/RealIO, gm2-iso/RawIO, M2 ISO Libraries
@subsection gm2-iso/RealConv

@example
DEFINITION MODULE RealConv;

  (* Low-level REAL/string conversions *)

IMPORT
  ConvTypes;

TYPE
  ConvResults = ConvTypes.ConvResults; (* strAllRight, strOutOfRange, strWrongFormat, strEmpty *)

@findex ScanReal
PROCEDURE ScanReal (inputCh: CHAR; VAR chClass: ConvTypes.ScanClass;
                    VAR nextState: ConvTypes.ScanState);
  (* Represents the start state of a finite state scanner for real numbers - assigns
     class of inputCh to chClass and a procedure representing the next state to
     nextState.
   *)

@findex FormatReal
PROCEDURE FormatReal (str: ARRAY OF CHAR): ConvResults;
  (* Returns the format of the string value for conversion to REAL. *)

@findex ValueReal
PROCEDURE ValueReal (str: ARRAY OF CHAR): REAL;
  (* Returns the value corresponding to the real number string value str if str is
     well-formed; otherwise raises the RealConv exception.
  *)

@findex LengthFloatReal
PROCEDURE LengthFloatReal (real: REAL; sigFigs: CARDINAL): CARDINAL;
  (* Returns the number of characters in the floating-point string representation of
     real with sigFigs significant figures.
  *)

@findex LengthEngReal
PROCEDURE LengthEngReal (real: REAL; sigFigs: CARDINAL): CARDINAL;
  (* Returns the number of characters in the floating-point engineering string
     representation of real with sigFigs significant figures.
  *)

@findex LengthFixedReal
PROCEDURE LengthFixedReal (real: REAL; place: INTEGER): CARDINAL;
  (* Returns the number of characters in the fixed-point string representation of real
     rounded to the given place relative to the decimal point.
  *)

@findex IsRConvException
PROCEDURE IsRConvException (): BOOLEAN;
  (* Returns TRUE if the current coroutine is in the exceptional execution state because
     of the raising of an exception in a routine from this module; otherwise returns
     FALSE.
  *)

END RealConv.

@end example
@page


@node gm2-iso/RealIO, gm2-iso/RealMath, gm2-iso/RealConv, M2 ISO Libraries
@subsection gm2-iso/RealIO

@example
DEFINITION MODULE RealIO;

  (* Input and output of real numbers in decimal text form over specified channels.
     The read result is of the type IOConsts.ReadResults.
  *)

IMPORT IOChan;

  (* The text form of a signed fixed-point real number is
       ["+" | "-"], decimal digit, @{decimal digit@},
       [".", @{decimal digit@}]

     The text form of a signed floating-point real number is
       signed fixed-point real number,
       "E", ["+" | "-"], decimal digit, @{decimal digit@}
  *)

@findex ReadReal
PROCEDURE ReadReal (cid: IOChan.ChanId; VAR real: REAL);
  (* Skips leading spaces, and removes any remaining characters from cid that form part of a
     signed fixed or floating point number.  The value of this number is assigned to real.
     The read result is set to the value allRight, outOfRange, wrongFormat, endOfLine, or
     endOfInput.
  *)

@findex WriteFloat
PROCEDURE WriteFloat (cid: IOChan.ChanId; real: REAL; sigFigs: CARDINAL; width:
CARDINAL);
  (* Writes the value of real to cid in floating-point text form, with sigFigs significant
     figures, in a field of the given minimum width.
  *)

@findex WriteEng
PROCEDURE WriteEng (cid: IOChan.ChanId; real: REAL; sigFigs: CARDINAL; width: CARDINAL);
  (* As for WriteFloat, except that the number is scaled with one to three digits in the
     whole number part, and with an exponent that is a multiple of three.
  *)

@findex WriteFixed
PROCEDURE WriteFixed (cid: IOChan.ChanId; real: REAL; place: INTEGER; width: CARDINAL);
  (* Writes the value of real to cid in fixed-point text form, rounded to the given place
     relative to the decimal point, in a field of the given minimum width.
  *)

@findex WriteReal
PROCEDURE WriteReal (cid: IOChan.ChanId; real: REAL; width: CARDINAL);
  (* Writes the value of real to cid, as WriteFixed if the sign and magnitude can be shown
     in the given width, or otherwise as WriteFloat.  The number of places or significant
     digits depends on the given width.
  *)

END RealIO.
@end example
@page


@node gm2-iso/RealMath, gm2-iso/RealStr, gm2-iso/RealIO, M2 ISO Libraries
@subsection gm2-iso/RealMath

@example
DEFINITION MODULE RealMath;

  (* Mathematical functions for the type REAL *)

CONST
  pi   = 3.1415926535897932384626433832795028841972;
  exp1 = 2.7182818284590452353602874713526624977572;

@findex sqrt
PROCEDURE __BUILTIN__ sqrt (x: REAL): REAL;
  (* Returns the positive square root of x *)

@findex exp
PROCEDURE exp (x: REAL): REAL;
  (* Returns the exponential of x *)

@findex ln
PROCEDURE ln (x: REAL): REAL;
  (* Returns the natural logarithm of x *)

  (* The angle in all trigonometric functions is measured in radians *)

@findex sin
PROCEDURE __BUILTIN__ sin (x: REAL): REAL;
  (* Returns the sine of x *)

@findex cos
PROCEDURE __BUILTIN__ cos (x: REAL): REAL;
  (* Returns the cosine of x *)

@findex tan
PROCEDURE tan (x: REAL): REAL;
  (* Returns the tangent of x *)

@findex arcsin
PROCEDURE arcsin (x: REAL): REAL;
  (* Returns the arcsine of x *)

@findex arccos
PROCEDURE arccos (x: REAL): REAL;
  (* Returns the arccosine of x *)

@findex arctan
PROCEDURE arctan (x: REAL): REAL;
  (* Returns the arctangent of x *)

@findex power
PROCEDURE power (base, exponent: REAL): REAL;
  (* Returns the value of the number base raised to the power exponent *)

@findex round
PROCEDURE round (x: REAL): INTEGER;
  (* Returns the value of x rounded to the nearest integer *)

@findex IsRMathException
PROCEDURE IsRMathException (): BOOLEAN;
  (* Returns TRUE if the current coroutine is in the exceptional execution state
     because of the raising of an exception in a routine from this module; otherwise
     returns FALSE.
  *)

END RealMath.

@end example
@page


@node gm2-iso/RealStr, gm2-iso/RndFile, gm2-iso/RealMath, M2 ISO Libraries
@subsection gm2-iso/RealStr

@example
DEFINITION MODULE RealStr;

  (* REAL/string conversions *)

IMPORT
  ConvTypes;

TYPE
  ConvResults = ConvTypes.ConvResults; (* strAllRight, strOutOfRange, strWrongFormat, strEmpty *)

(* the string form of a signed fixed-point real number is
     ["+" | "-"], decimal digit, @{decimal digit@}, [".", @{decimal digit@}]
*)

(* the string form of a signed floating-point real number is
     signed fixed-point real number, "E", ["+" | "-"], decimal digit, @{decimal digit@}
*)

@findex StrToReal
PROCEDURE StrToReal (str: ARRAY OF CHAR; VAR real: REAL; VAR res: ConvResults);
  (* Ignores any leading spaces in str. If the subsequent characters in str are in the
     format of a signed real number, assigns a corresponding value to real.
     Assigns a value indicating the format of str to res.
  *)

@findex RealToFloat
PROCEDURE RealToFloat (real: REAL; sigFigs: CARDINAL; VAR str: ARRAY OF CHAR);
  (* Converts the value of real to floating-point string form, with sigFigs significant
     figures, and copies the possibly truncated result to str.
  *)

@findex RealToEng
PROCEDURE RealToEng (real: REAL; sigFigs: CARDINAL; VAR str: ARRAY OF CHAR);
  (* Converts the value of real to floating-point string form, with sigFigs significant
     figures, and copies the possibly truncated result to str. The number is scaled with
     one to three digits in the whole number part and with an exponent that is a
     multiple of three.
  *)

@findex RealToFixed
PROCEDURE RealToFixed (real: REAL; place: INTEGER; VAR str: ARRAY OF CHAR);
  (* Converts the value of real to fixed-point string form, rounded to the given place
     relative to the decimal point, and copies the possibly truncated result to str.
  *)

@findex RealToStr
PROCEDURE RealToStr (real: REAL; VAR str: ARRAY OF CHAR);
  (* Converts the value of real as RealToFixed if the sign and magnitude can be shown
     within the capacity of str, or otherwise as RealToFloat, and copies the possibly
     truncated result to str. The number of places or significant digits are
     implementation-defined.
  *)

END RealStr.

@end example
@page


@node gm2-iso/RndFile, gm2-iso/SIOResult, gm2-iso/RealStr, M2 ISO Libraries
@subsection gm2-iso/RndFile

@example
DEFINITION MODULE RndFile;

  (* Random access files *)

IMPORT IOChan, ChanConsts, SYSTEM;

TYPE
  ChanId = IOChan.ChanId;
  FlagSet = ChanConsts.FlagSet;
  OpenResults = ChanConsts.OpenResults;

  (* Accepted singleton values of FlagSet *)

CONST
  read = FlagSet@{ChanConsts.readFlag@};   (* input operations are requested/available *)
  write = FlagSet@{ChanConsts.writeFlag@}; (* output operations are requested/available *)
  old = FlagSet@{ChanConsts.oldFlag@};     (* a file may/must/did exist before the channel is
                                            opened *)
  text = FlagSet@{ChanConsts.textFlag@};   (* text operations are requested/available *)
  raw = FlagSet@{ChanConsts.rawFlag@};     (* raw operations are requested/available *)

@findex OpenOld
PROCEDURE OpenOld (VAR cid: ChanId; name: ARRAY OF CHAR; flags: FlagSet;
                   VAR res: OpenResults);
  (* Attempts to obtain and open a channel connected to a stored random access file of the
     given name.
     The old flag is implied; without the write flag, read is implied; without the text
     flag, raw is implied.
     If successful, assigns to cid the identity of the opened channel, assigns the value
     opened to res, and sets the read/write position to the start of the file.
     If a channel cannot be opened as required, the value of res indicates the reason, and
     cid identifies the invalid channel.
  *)

@findex OpenClean
PROCEDURE OpenClean (VAR cid: ChanId; name: ARRAY OF CHAR; flags: FlagSet;
                     VAR res: OpenResults);
  (* Attempts to obtain and open a channel connected to a stored random access file of the
     given name.
     The write flag is implied; without the text flag, raw is implied.
     If successful, assigns to cid the identity of the opened channel, assigns the value
     opened to res, and truncates the file to zero length.
     If a channel cannot be opened as required, the value of res indicates the reason, and
     cid identifies the invalid channel.
  *)

@findex IsRndFile
PROCEDURE IsRndFile (cid: ChanId): BOOLEAN;
  (* Tests if the channel identified by cid is open to a random access file. *)

@findex IsRndFileException
PROCEDURE IsRndFileException (): BOOLEAN;
  (* Returns TRUE if the current coroutine is in the exceptional execution state because
     of the raising of a RndFile exception; otherwise returns FALSE.
  *)

CONST
  FilePosSize = <implementation-defined whole number greater than zero>;

TYPE
  FilePos = ARRAY [1 .. FilePosSize] OF SYSTEM.LOC;

@findex StartPos
PROCEDURE StartPos (cid: ChanId): FilePos;
  (* If the channel identified by cid is not open to a random access file, the exception
     wrongDevice is raised; otherwise returns the position of the start of the file.
  *)

@findex CurrentPos
PROCEDURE CurrentPos (cid: ChanId): FilePos;
  (* If the channel identified by cid is not open to a random access file, the exception
     wrongDevice is raised; otherwise returns the position of the current read/write
     position.
  *)

@findex EndPos
PROCEDURE EndPos (cid: ChanId): FilePos;
  (* If the channel identified by cid is not open to a random access file, the exception
     wrongDevice is raised; otherwise returns the first position after which there have been
     no writes.
  *)

@findex NewPos
PROCEDURE NewPos (cid: ChanId; chunks: INTEGER; chunkSize: CARDINAL; from: FilePos): FilePos;
  (* If the channel identified by cid is not open to a random access file, the exception
     wrongDevice is raised; otherwise returns the position (chunks * chunkSize) relative to
     the position given by from, or raises the exception posRange if the required position
     cannot be represented as a value of type FilePos.
  *)

@findex SetPos
PROCEDURE SetPos (cid: ChanId; pos: FilePos);
  (* If the channel identified by cid is not open to a random access file, the exception
     wrongDevice is raised; otherwise sets the read/write position to the value given by
     pos.
  *)

@findex Close
PROCEDURE Close (VAR cid: ChanId);
  (* If the channel identified by cid is not open to a random access file, the exception
     wrongDevice is raised; otherwise closes the channel, and assigns the value identifying
     the invalid channel to cid.
  *)

END RndFile.

@end example
@page


@node gm2-iso/SIOResult, gm2-iso/SLongIO, gm2-iso/RndFile, M2 ISO Libraries
@subsection gm2-iso/SIOResult

@example
DEFINITION MODULE SIOResult;

  (* Read results for the default input channel *)

IMPORT IOConsts;

TYPE
  ReadResults = IOConsts.ReadResults;

  (*
    ReadResults =   (* This type is used to classify the result of an input operation *)
    (
      notKnown,     (* no read result is set *)
      allRight,     (* data is as expected or as required *)
      outOfRange,   (* data cannot be represented *)
      wrongFormat,  (* data not in expected format *)
      endOfLine,    (* end of line seen before expected data *)
      endOfInput    (* end of input seen before expected data *)
    );
  *)

@findex ReadResult
PROCEDURE ReadResult (): ReadResults;
  (* Returns the result for the last read operation on the default input channel. *)

END SIOResult.

@end example
@page


@node gm2-iso/SLongIO, gm2-iso/SRawIO, gm2-iso/SIOResult, M2 ISO Libraries
@subsection gm2-iso/SLongIO

@example
DEFINITION MODULE SLongIO;

  (* Input and output of long real numbers in decimal text form using default channels.  The
     read result is of the type IOConsts.ReadResults.
  *)

  (* The text form of a signed fixed-point real number is
       ["+" | "-"], decimal digit, @{decimal digit@},
       [".", @{decimal digit@}]

     The text form of a signed floating-point real number is
       signed fixed-point real number,
       "E", ["+" | "-"], decimal digit, @{decimal digit@}
  *)

@findex ReadReal
PROCEDURE ReadReal (VAR real: LONGREAL);
  (* Skips leading spaces, and removes any remaining characters from the default input
     channel that form part of a signed fixed or floating point number. The value of this
     number is assigned to real.  The read result is set to the value allRight, outOfRange,
     wrongFormat, endOfLine, or endOfInput.
  *)

@findex WriteFloat
PROCEDURE WriteFloat (real: LONGREAL; sigFigs: CARDINAL; width: CARDINAL);
  (* Writes the value of real to the default output channel in floating-point text form,
     with sigFigs significant figures, in a field of the given minimum width.
  *)

@findex WriteEng
PROCEDURE WriteEng (real: LONGREAL; sigFigs: CARDINAL; width: CARDINAL);
  (* As for WriteFloat, except that the number is scaled with one to three digits in the
     whole number part, and with an exponent that is a multiple of three.
  *)

@findex WriteFixed
PROCEDURE WriteFixed (real: LONGREAL; place: INTEGER; width: CARDINAL);
  (* Writes the value of real to the default output channel in fixed-point text form,
     rounded to the given place relative to the decimal point, in a field of the given
     minimum width.
  *)

@findex WriteReal
PROCEDURE WriteReal (real: LONGREAL; width: CARDINAL);
  (* Writes the value of real to the default output channel, as WriteFixed if the sign and
     magnitude can be shown in the given width, or otherwise as WriteFloat. The number of
     places or significant digits depends on the given width.
  *)

END SLongIO.

@end example
@page


@node gm2-iso/SRawIO, gm2-iso/SRealIO, gm2-iso/SLongIO, M2 ISO Libraries
@subsection gm2-iso/SRawIO

@example
DEFINITION MODULE SRawIO;

  (* Reading and writing data over default channels using raw operations, that is, with no
     conversion or interpretation. The read result is of the type IOConsts.ReadResults.
  *)

IMPORT SYSTEM;

@findex Read
PROCEDURE Read (VAR to: ARRAY OF SYSTEM.LOC);
  (* Reads storage units from the default input channel, and assigns them to successive
     components of to.  The read result is set to the value allRight, wrongFormat, or
     endOfInput.
  *)

@findex Write
PROCEDURE Write (from: ARRAY OF SYSTEM.LOC);
  (* Writes storage units to the default output channel from successive components of from.
  *)

END SRawIO.

@end example
@page


@node gm2-iso/SRealIO, gm2-iso/STextIO, gm2-iso/SRawIO, M2 ISO Libraries
@subsection gm2-iso/SRealIO

@example
DEFINITION MODULE SRealIO;

  (* Input and output of real numbers in decimal text form over default
     channels.  The read result is of the type IOConsts.ReadResults.
  *)

  (* The text form of a signed fixed-point real number is
       ["+" | "-"], decimal digit, @{decimal digit@},
       [".", @{decimal digit@}]

     The text form of a signed floating-point real number is
       signed fixed-point real number,
       "E", ["+" | "-"], decimal digit, @{decimal digit@}
  *)

@findex ReadReal
PROCEDURE ReadReal (VAR real: REAL);
  (* Skips leading spaces, and removes any remaining characters from the default input
     channel that form part of a signed fixed or floating point number. The value of this
     number is assigned to real.  The read result is set to the value allRight, outOfRange,
     wrongFormat, endOfLine, or endOfInput.
  *)

@findex WriteFloat
PROCEDURE WriteFloat (real: REAL; sigFigs: CARDINAL; width: CARDINAL);
  (* Writes the value of real to the default output channel in floating-point text form,
     with sigFigs significant figures, in a field of the given minimum width.
  *)

@findex WriteEng
PROCEDURE WriteEng (real: REAL; sigFigs: CARDINAL; width: CARDINAL);
  (* As for WriteFloat, except that the number is scaled with one to three digits in the
     whole number part, and with an exponent that is a multiple of three.
  *)

@findex WriteFixed
PROCEDURE WriteFixed (real: REAL; place: INTEGER; width: CARDINAL);
  (* Writes the value of real to the default output channel in fixed-point text form,
     rounded to the given place relative to the decimal point, in a field of the given
     minimum width.
  *)

@findex WriteReal
PROCEDURE WriteReal (real: REAL; width: CARDINAL);
  (* Writes the value of real to the default output channel, as WriteFixed if the sign and
     magnitude can be shown in the given width, or otherwise as WriteFloat. The number of
     places or significant digits depends on the given width.
  *)

END SRealIO.

@end example
@page


@node gm2-iso/STextIO, gm2-iso/SWholeIO, gm2-iso/SRealIO, M2 ISO Libraries
@subsection gm2-iso/STextIO

@example
DEFINITION MODULE STextIO;

  (* Input and output of character and string types over default channels. The read result
     is of the type IOConsts.ReadResults.
  *)

  (* The following procedures do not read past line marks *)

@findex ReadChar
PROCEDURE ReadChar (VAR ch: CHAR);
  (* If possible, removes a character from the default input stream, and assigns the
     corresponding value to ch.  The read result is set to allRight, endOfLine or
     endOfInput.
  *)

@findex ReadRestLine
PROCEDURE ReadRestLine (VAR s: ARRAY OF CHAR);
  (* Removes any remaining characters from the default input stream before the next line
     mark, copying to s as many as can be accommodated as a string value.  The read result
     is set to the value allRight, outOfRange, endOfLine, or endOfInput.
  *)

@findex ReadString
PROCEDURE ReadString (VAR s: ARRAY OF CHAR);
  (* Removes only those characters from the default input stream before the next line mark
     that can be accommodated in s as a string value, and copies them to s. The read result
     is set to the value allRight, endOfLine, or endOfInput.
  *)

@findex ReadToken
PROCEDURE ReadToken (VAR s: ARRAY OF CHAR);
  (* Skips leading spaces, and then removes characters from the default input stream before
     the next space or line mark, copying to s as many as can be accommodated as a string
     value.  The read result is set to the value allRight, outOfRange, endOfLine, or
     endOfInput.
  *)

  (* The following procedure reads past the next line mark *)

@findex SkipLine
PROCEDURE SkipLine;
  (* Removes successive items from the default input stream up to and including the next
     line mark or until the end of input is reached. The read result is set to the value
     allRight, or endOfInput.
  *)


  (* Output procedures *)

@findex WriteChar
PROCEDURE WriteChar (ch: CHAR);
  (* Writes the value of ch to the default output stream. *)

@findex WriteLn
PROCEDURE WriteLn;
  (* Writes a line mark to the default output stream. *)

@findex WriteString
PROCEDURE WriteString (s: ARRAY OF CHAR);
  (* Writes the string value of s to the default output stream. *)

END STextIO.

@end example
@page


@node gm2-iso/SWholeIO, gm2-iso/SYSTEM, gm2-iso/STextIO, M2 ISO Libraries
@subsection gm2-iso/SWholeIO

@example
DEFINITION MODULE SWholeIO;

  (* Input and output of whole numbers in decimal text form over default
     channels.  The read result is of the type IOConsts.ReadResults.
  *)

  (* The text form of a signed whole number is
       ["+" | "-"], decimal digit, @{decimal digit@}

     The text form of an unsigned whole number is
       decimal digit, @{decimal digit@}
  *)

@findex ReadInt
PROCEDURE ReadInt (VAR int: INTEGER);
  (* Skips leading spaces, and removes any remaining characters from the default input
     channel that form part of a signed whole number.  The value of this number is assigned
     to int.  The read result is set to the value allRight, outOfRange, wrongFormat,
     endOfLine, or endOfInput.
  *)

@findex WriteInt
PROCEDURE WriteInt (int: INTEGER; width: CARDINAL);
  (* Writes the value of int to the default output channel in text form, in a field of the
     given minimum width.
  *)

@findex ReadCard
PROCEDURE ReadCard (VAR card: CARDINAL);
  (* Skips leading spaces, and removes any remaining characters from the default input
     channel that form part of an unsigned whole number.  The value of this number is
     assigned to card.  The read result is set to the value allRight, outOfRange,
     wrongFormat, endOfLine, or endOfInput.
  *)

@findex WriteCard
PROCEDURE WriteCard (card: CARDINAL; width: CARDINAL);
  (* Writes the value of card to the default output channel in text form, in a field of the
     given minimum width.
  *)

END SWholeIO.
@end example
@page


@node gm2-iso/SYSTEM, gm2-iso/Semaphores, gm2-iso/SWholeIO, M2 ISO Libraries
@subsection gm2-iso/SYSTEM

@example
DEFINITION MODULE SYSTEM;

  (* Gives access to system programming facilities that are probably
     non portable. *)

  (* The constants and types define underlying properties of storage *)

EXPORT QUALIFIED BITSPERLOC, LOCSPERWORD,
                 LOC, BYTE, WORD, BITSET, ADDRESS,
                 ADDADR, SUBADR, DIFADR, MAKEADR, ADR, ROTATE,
                 SHIFT, CAST, TSIZE,

                 (* Internal GM2 compiler functions *)
                 ShiftVal, ShiftLeft, ShiftRight,
                 RotateVal, RotateLeft, RotateRight ;

CONST
                  (* <implementation-defined constant> ; *)
  BITSPERLOC    = __ATTRIBUTE__ __BUILTIN__ ((BITS_PER_UNIT)) ;
                  (* <implementation-defined constant> ; *)
  LOCSPERWORD   = __ATTRIBUTE__ __BUILTIN__ ((UNITS_PER_WORD)) ;
                  (* <implementation-defined constant> ; *)
  LOCSPERBYTE = 8 DIV BITSPERLOC ;

(*
   all the objects below are declared internally to gm2
   ====================================================

TYPE
  LOC; (* A system basic type. Values are the uninterpreted
          contents of the smallest addressable unit of storage *)
  ADDRESS = POINTER TO LOC;
  WORD = ARRAY [0 .. LOCSPERWORD-1] OF LOC;

  (* BYTE and LOCSPERBYTE are provided if appropriate for machine *)

TYPE
  BYTE = ARRAY [0 .. LOCSPERBYTE-1] OF LOC;

@findex ADDADR
PROCEDURE ADDADR (addr: ADDRESS; offset: CARDINAL): ADDRESS;
  (* Returns address given by (addr + offset), or may raise
     an exception if this address is not valid.
  *)

@findex SUBADR
PROCEDURE SUBADR (addr: ADDRESS; offset: CARDINAL): ADDRESS;
  (* Returns address given by (addr - offset), or may raise an
     exception if this address is not valid.
  *)

@findex DIFADR
PROCEDURE DIFADR (addr1, addr2: ADDRESS): INTEGER;
  (* Returns the difference between addresses (addr1 - addr2),
     or may raise an exception if the arguments are invalid
     or address space is non-contiguous.
  *)

@findex MAKEADR
PROCEDURE MAKEADR (high: <some type>; ...): ADDRESS;
  (* Returns an address constructed from a list of values whose
     types are implementation-defined, or may raise an
     exception if this address is not valid.

     In GNU Modula-2, MAKEADR can take any number of arguments
     which are mapped onto the type ADDRESS. The first parameter
     maps onto the high address bits and subsequent parameters map
     onto lower address bits. For example:

     a := MAKEADR(BYTE(0FEH), BYTE(0DCH), BYTE(0BAH), BYTE(098H),
                  BYTE(076H), BYTE(054H), BYTE(032H), BYTE(010H)) ;

     then the value of, a, on a 64 bit machine is: 0FEDCBA9876543210H

     The parameters do not have to have the same type, but constants
     _must_ be typed.
  *)

@findex ADR
PROCEDURE ADR (VAR v: <anytype>): ADDRESS;
  (* Returns the address of variable v. *)

@findex ROTATE
PROCEDURE ROTATE (val: <a packedset type>;
                  num: INTEGER): <type of first parameter>;
  (* Returns a bit sequence obtained from val by rotating up or down
     (left or right) by the absolute value of num.  The direction is
     down if the sign of num is negative, otherwise the direction is up.
  *)

@findex SHIFT
PROCEDURE SHIFT (val: <a packedset type>;
                 num: INTEGER): <type of first parameter>;
  (* Returns a bit sequence obtained from val by shifting up or down
     (left or right) by the absolute value of num, introducing
     zeros as necessary.  The direction is down if the sign of
     num is negative, otherwise the direction is up.
  *)

@findex CAST
PROCEDURE CAST (<targettype>; val: <anytype>): <targettype>;
  (* CAST is a type transfer function.  Given the expression
     denoted by val, it returns a value of the type <targettype>.
     An invalid value for the target value or a
     physical address alignment problem may raise an exception.
  *)

@findex TSIZE
PROCEDURE TSIZE (<type>; ... ): CARDINAL;
  (* Returns the number of LOCS used to store a value of the
     specified <type>.   The extra parameters, if present,
     are used to distinguish variants in a variant record.
  *)
*)


(* The following procedures are invoked by GNU Modula-2 to
   shift non word set types. They are not part of ISO Modula-2
   but are used by GNU Modula-2 to implement the SHIFT procedure
   defined above. *)

(*
   ShiftVal - is a runtime procedure whose job is to implement
              the SHIFT procedure of ISO SYSTEM. GNU Modula-2 will
              inline a SHIFT of a single WORD sized set and will only
              call this routine for larger sets.
*)

@findex ShiftVal
PROCEDURE ShiftVal (VAR s, d: ARRAY OF BITSET;
                    SetSizeInBits: CARDINAL;
                    ShiftCount: INTEGER) ;


(*
   ShiftLeft - performs the shift left for a multi word set.
               This procedure might be called by the back end of
               GNU Modula-2 depending whether amount is known at compile
               time.
*)

@findex ShiftLeft
PROCEDURE ShiftLeft (VAR s, d: ARRAY OF BITSET;
                     SetSizeInBits: CARDINAL;
                     ShiftCount: INTEGER) ;

(*
   ShiftRight - performs the shift left for a multi word set.
                This procedure might be called by the back end of
                GNU Modula-2 depending whether amount is known at compile
                time.
*)

@findex ShiftRight
PROCEDURE ShiftRight (VAR s, d: ARRAY OF BITSET;
                     SetSizeInBits: CARDINAL;
                     ShiftCount: INTEGER) ;


(*
   RotateVal - is a runtime procedure whose job is to implement
               the ROTATE procedure of ISO SYSTEM. GNU Modula-2 will
               inline a ROTATE of a single WORD (or less)
               sized set and will only call this routine for larger sets.
*)

@findex RotateVal
PROCEDURE RotateVal (VAR s, d: ARRAY OF BITSET;
                     SetSizeInBits: CARDINAL;
                     RotateCount: INTEGER) ;


(*
   RotateLeft - performs the rotate left for a multi word set.
                This procedure might be called by the back end of
                GNU Modula-2 depending whether amount is known at compile
                time.
*)

@findex RotateLeft
PROCEDURE RotateLeft (VAR s, d: ARRAY OF BITSET;
                      SetSizeInBits: CARDINAL;
                      RotateCount: INTEGER) ;


(*
   RotateRight - performs the rotate right for a multi word set.
                 This procedure might be called by the back end of
                 GNU Modula-2 depending whether amount is known at compile
                 time.
*)

@findex RotateRight
PROCEDURE RotateRight (VAR s, d: ARRAY OF BITSET;
                       SetSizeInBits: CARDINAL;
                       RotateCount: INTEGER) ;


END SYSTEM.
@end example
@page


@node gm2-iso/Semaphores, gm2-iso/SeqFile, gm2-iso/SYSTEM, M2 ISO Libraries
@subsection gm2-iso/Semaphores

@example
DEFINITION MODULE Semaphores;

  (* Provides mutual exclusion facilities for use by processes. *)

TYPE
  SEMAPHORE;

@findex Create
PROCEDURE Create (VAR s: SEMAPHORE; initialCount: CARDINAL );
  (* Creates and returns s as the identity of a new semaphore that has its associated count
     initialized to initialCount, and has no processes yet waiting on it.
  *)

@findex Destroy
PROCEDURE Destroy (VAR s: SEMAPHORE);
  (* Recovers the resources used to implement the semaphore s, provided that no process is
     waiting for s to become free.
  *)

@findex Claim
PROCEDURE Claim (s: SEMAPHORE);
  (* If the count associated with the semaphore s is non-zero, decrements this count and
     allows the calling process to continue; otherwise suspends the calling process until
     s is released.
  *)

@findex Release
PROCEDURE Release (s: SEMAPHORE);
  (* If there are any processes waiting on the semaphore s, allows one of them
     to enter the ready state; otherwise increments the count associated with s.
  *)

@findex CondClaim
PROCEDURE CondClaim (s: SEMAPHORE): BOOLEAN;
  (* Returns TRUE if the call Claim(s) would cause the calling process to be suspended;
     in this case the count associated with s is not changed. Otherwise returns TRUE and
     the associated count is decremented.
  *)

END Semaphores.

@end example
@page


@node gm2-iso/SeqFile, gm2-iso/StdChans, gm2-iso/Semaphores, M2 ISO Libraries
@subsection gm2-iso/SeqFile

@example
DEFINITION MODULE SeqFile;

  (* Rewindable sequential files *)

IMPORT IOChan, ChanConsts;

TYPE
  ChanId = IOChan.ChanId;
  FlagSet = ChanConsts.FlagSet;
  OpenResults = ChanConsts.OpenResults;

  (* Accepted singleton values of FlagSet *)

CONST
  read = FlagSet@{ChanConsts.readFlag@};   (* input operations are requested/available *)
  write = FlagSet@{ChanConsts.writeFlag@}; (* output operations are requested/available *)
  old = FlagSet@{ChanConsts.oldFlag@};     (* a file may/must/did exist before the channel is
                                            opened *)
  text = FlagSet@{ChanConsts.textFlag@};   (* text operations are requested/available *)
  raw = FlagSet@{ChanConsts.rawFlag@};     (* raw operations are requested/available *)

@findex OpenWrite
PROCEDURE OpenWrite (VAR cid: ChanId; name: ARRAY OF CHAR; flags: FlagSet;
                     VAR res: OpenResults);
  (* Attempts to obtain and open a channel connected to a stored rewindable file of the
     given name.
     The write flag is implied; without the raw flag, text is implied.
     If successful, assigns to cid the identity of the opened channel, assigns the value
     opened to res, and selects output mode, with the write position at the start of the
     file (i.e. the file is of zero length).
     If a channel cannot be opened as required, the value of res indicates the reason, and
     cid identifies the invalid channel.
  *)

@findex OpenAppend
PROCEDURE OpenAppend (VAR cid: ChanId; name: ARRAY OF CHAR; flags: FlagSet;
                      VAR res: OpenResults);
  (* Attempts to obtain and open a channel connected to a stored rewindable file of the
     given name.
     The write and old flags are implied; without the raw flag, text is implied.
     If successful, assigns to cid the identity of the opened channel, assigns the value
     opened to res, and selects output mode, with the write position corresponding to the
     length of the file.
     If a channel cannot be opened as required, the value of res indicates the reason, and
     cid identifies the invalid channel.
  *)

@findex OpenRead
PROCEDURE OpenRead (VAR cid: ChanId; name: ARRAY OF CHAR; flags: FlagSet;
                    VAR res: OpenResults);
  (* Attempts to obtain and open a channel connected to a stored rewindable file of the
     given name.
     The read and old flags are implied; without the raw flag, text is implied.
     If successful, assigns to cid the identity of the opened channel, assigns the value
     opened to res, and selects input mode, with the read position corresponding to the
     start of the file.
     If a channel cannot be opened as required, the value of res indicates the reason, and
     cid identifies the invalid channel.
  *)

@findex IsSeqFile
PROCEDURE IsSeqFile (cid: ChanId): BOOLEAN;
  (* Tests if the channel identified by cid is open to a rewindable sequential file. *)

@findex Reread
PROCEDURE Reread (cid: ChanId);
  (* If the channel identified by cid is not open to a rewindable sequential file, the
     exception wrongDevice is raised; otherwise attempts to set the read position to the
     start of the file, and to select input mode.
     If the operation cannot be performed (perhaps because of insufficient permissions)
     neither input mode nor output mode is selected.
  *)

@findex Rewrite
PROCEDURE Rewrite (cid: ChanId);
  (* If the channel identified by cid is not open to a rewindable sequential file, the
     exception wrongDevice is raised; otherwise, attempts to truncate the file to zero
     length, and to select output mode.
     If the operation cannot be performed (perhaps because of insufficient permissions)
     neither input mode nor output mode is selected.
  *)

@findex Close
PROCEDURE Close (VAR cid: ChanId);
  (* If the channel identified by cid is not open to a rewindable sequential file, the
     exception wrongDevice is raised; otherwise closes the channel, and assigns the value
     identifying the invalid channel to cid.
  *)

END SeqFile.

@end example
@page


@node gm2-iso/StdChans, gm2-iso/Storage, gm2-iso/SeqFile, M2 ISO Libraries
@subsection gm2-iso/StdChans

@example
DEFINITION MODULE StdChans;

  (* Access to standard and default channels *)

IMPORT IOChan;

TYPE
  ChanId = IOChan.ChanId;
    (* Values of this type are used to identify channels *)

  (* The following functions return the standard channel values.
     These channels cannot be closed.
  *)

@findex StdInChan
PROCEDURE StdInChan (): ChanId;
  (* Returns the identity of the implementation-defined standard source for
program
     input.
  *)

@findex StdOutChan
PROCEDURE StdOutChan (): ChanId;
  (* Returns the identity of the implementation-defined standard source for program
     output.
  *)

@findex StdErrChan
PROCEDURE StdErrChan (): ChanId;
  (* Returns the identity of the implementation-defined standard destination for program
     error messages.
  *)

@findex NullChan
PROCEDURE NullChan (): ChanId;
  (* Returns the identity of a channel open to the null device. *)

  (* The following functions return the default channel values *)

@findex InChan
PROCEDURE InChan (): ChanId;
  (* Returns the identity of the current default input channel. *)

@findex OutChan
PROCEDURE OutChan (): ChanId;
  (* Returns the identity of the current default output channel. *)

@findex ErrChan
PROCEDURE ErrChan (): ChanId;
  (* Returns the identity of the current default error message channel. *)

  (* The following procedures allow for redirection of the default channels *)

@findex SetInChan
PROCEDURE SetInChan (cid: ChanId);
  (* Sets the current default input channel to that identified by cid. *)

@findex SetOutChan
PROCEDURE SetOutChan (cid: ChanId);
  (* Sets the current default output channel to that identified by cid. *)

@findex SetErrChan
PROCEDURE SetErrChan (cid: ChanId);
  (* Sets the current default error channel to that identified by cid. *)

END StdChans.

@end example
@page


@node gm2-iso/Storage, gm2-iso/StreamFile, gm2-iso/StdChans, M2 ISO Libraries
@subsection gm2-iso/Storage

@example
DEFINITION MODULE Storage;

  (* Facilities for dynamically allocating and deallocating storage *)

IMPORT SYSTEM;

@findex ALLOCATE
PROCEDURE ALLOCATE (VAR addr: SYSTEM.ADDRESS; amount: CARDINAL);
  (* Allocates storage for a variable of size amount and assigns the address of this
     variable to addr. If there is insufficient unallocated storage to do this, the
     value NIL is assigned to addr.
  *)

@findex DEALLOCATE
PROCEDURE DEALLOCATE (VAR addr: SYSTEM.ADDRESS; amount: CARDINAL);
  (* Deallocates amount locations allocated by ALLOCATE for the storage of the variable
     addressed by addr and assigns the value NIL to addr.
  *)

TYPE
  StorageExceptions = (
    nilDeallocation,             (* first argument to DEALLOCATE is NIL *)
    pointerToUnallocatedStorage, (* storage to deallocate not allocated by ALLOCATE *)
    wrongStorageToUnallocate     (* amount to deallocate is not amount allocated *)
  );

@findex IsStorageException
PROCEDURE IsStorageException (): BOOLEAN;
  (* Returns TRUE if the current coroutine is in the exceptional execution state
     because of the raising of an exception from StorageExceptions;
     otherwise returns FALSE.
  *)

@findex StorageException
PROCEDURE StorageException (): StorageExceptions;
  (* If the current coroutine is in the exceptional execution state because of the
     raising of an exception from StorageExceptions, returns the corresponding
     enumeration value, and otherwise raises an exception.
  *)

END Storage.
@end example
@page


@node gm2-iso/StreamFile, gm2-iso/Strings, gm2-iso/Storage, M2 ISO Libraries
@subsection gm2-iso/StreamFile

@example
DEFINITION MODULE StreamFile;

  (* Independent sequential data streams *)

IMPORT IOChan, ChanConsts;

TYPE
  ChanId = IOChan.ChanId;
  FlagSet = ChanConsts.FlagSet;
  OpenResults = ChanConsts.OpenResults;

  (* Accepted singleton values of FlagSet *)

CONST
  read = FlagSet@{ChanConsts.readFlag@};   (* input operations are requested/available *)
  write = FlagSet@{ChanConsts.writeFlag@}; (* output operations are requested/available *)
  old = FlagSet@{ChanConsts.oldFlag@};     (* a file may/must/did exist before the channel is
                                            opened *)
  text = FlagSet@{ChanConsts.textFlag@};   (* text operations are requested/available *)
  raw = FlagSet@{ChanConsts.rawFlag@};     (* raw operations are requested/available *)


@findex Open
PROCEDURE Open (VAR cid: ChanId; name: ARRAY OF CHAR; flags: FlagSet; VAR res: OpenResults);
  (* Attempts to obtain and open a channel connected to a sequential stream of the given
     name.
     The read flag implies old; without the raw flag, text is implied.
     If successful, assigns to cid the identity of the opened channel, and assigns the value
     opened to res.
     If a channel cannot be opened as required, the value of res indicates the reason, and
     cid identifies the invalid channel.
  *)

@findex IsStreamFile
PROCEDURE IsStreamFile (cid: ChanId): BOOLEAN;
  (* Tests if the channel identified by cid is open to a sequential stream. *)

@findex Close
PROCEDURE Close (VAR cid: ChanId);
  (* If the channel identified by cid is not open to a sequential stream, the exception
     wrongDevice is raised; otherwise closes the channel, and assigns the value identifying
     the invalid channel to cid.
  *)

END StreamFile.

@end example
@page


@node gm2-iso/Strings, gm2-iso/SysClock, gm2-iso/StreamFile, M2 ISO Libraries
@subsection gm2-iso/Strings

@example
DEFINITION MODULE Strings;

  (* Facilities for manipulating strings *)

TYPE
  String1 = ARRAY [0..0] OF CHAR;
    (* String1 is provided for constructing a value of a single-character string type from a
       single character value in order to pass CHAR values to ARRAY OF CHAR parameters.
    *)

@findex Length
PROCEDURE Length (stringVal: ARRAY OF CHAR): CARDINAL;
  (* Returns the length of stringVal (the same value as would be returned by the
     pervasive function LENGTH).
  *)


(* The following seven procedures construct a string value, and attempt to assign it to a
   variable parameter.  They all have the property that if the length of the constructed string
   value exceeds the capacity of the variable parameter, a truncated value is assigned, while
   if the length of the constructed string value is less than the capacity of the variable
   parameter, a string terminator is appended before assignment is performed.
*)

@findex Assign
PROCEDURE Assign (source: ARRAY OF CHAR; VAR destination: ARRAY OF CHAR);
  (* Copies source to destination *)

@findex Extract
PROCEDURE Extract (source: ARRAY OF CHAR; startIndex, numberToExtract: CARDINAL;
                   VAR destination: ARRAY OF CHAR);
  (* Copies at most numberToExtract characters from source to destination, starting at position
     startIndex in source.
  *)

@findex Delete
PROCEDURE Delete (VAR stringVar: ARRAY OF CHAR; startIndex, numberToDelete:
CARDINAL);
  (* Deletes at most numberToDelete characters from stringVar, starting at position
     startIndex.
  *)

@findex Insert
PROCEDURE Insert (source: ARRAY OF CHAR; startIndex: CARDINAL;
                  VAR destination: ARRAY OF CHAR);
  (* Inserts source into destination at position startIndex *)

@findex Replace
PROCEDURE Replace (source: ARRAY OF CHAR; startIndex: CARDINAL;
                   VAR destination: ARRAY OF CHAR);
  (* Copies source into destination, starting at position startIndex. Copying stops when
     all of source has been copied, or when the last character of the string value in
     destination has been replaced.
  *)

@findex Append
PROCEDURE Append (source: ARRAY OF CHAR; VAR destination: ARRAY OF CHAR);
  (* Appends source to destination. *)

@findex Concat
PROCEDURE Concat (source1, source2: ARRAY OF CHAR; VAR destination: ARRAY OF CHAR);
  (* Concatenates source2 onto source1 and copies the result into destination. *)

(* The following predicates provide for pre-testing of the operation-completion
   conditions for the procedures above.
*)

@findex CanAssignAll
PROCEDURE CanAssignAll (sourceLength: CARDINAL; VAR destination: ARRAY OF CHAR): BOOLEAN;
  (* Returns TRUE if a number of characters, indicated by sourceLength, will fit into
     destination; otherwise returns FALSE.
  *)

@findex CanExtractAll
PROCEDURE CanExtractAll (sourceLength, startIndex, numberToExtract: CARDINAL;
                         VAR destination: ARRAY OF CHAR): BOOLEAN;
  (* Returns TRUE if there are numberToExtract characters starting at startIndex and
     within the sourceLength of some string, and if the capacity of destination is
     sufficient to hold numberToExtract characters; otherwise returns FALSE.
  *)

@findex CanDeleteAll
PROCEDURE CanDeleteAll (stringLength, startIndex, numberToDelete: CARDINAL): BOOLEAN;
  (* Returns TRUE if there are numberToDelete characters starting at startIndex and
     within the stringLength of some string; otherwise returns FALSE.
  *)

@findex CanInsertAll
PROCEDURE CanInsertAll (sourceLength, startIndex: CARDINAL;
                        VAR destination: ARRAY OF CHAR): BOOLEAN;
  (* Returns TRUE if there is room for the insertion of sourceLength characters from
     some string into destination starting at startIndex; otherwise returns FALSE.
  *)

@findex CanReplaceAll
PROCEDURE CanReplaceAll (sourceLength, startIndex: CARDINAL;
                         VAR destination: ARRAY OF CHAR): BOOLEAN;
  (* Returns TRUE if there is room for the replacement of sourceLength characters in
     destination starting at startIndex; otherwise returns FALSE.
  *)

@findex CanAppendAll
PROCEDURE CanAppendAll (sourceLength: CARDINAL; VAR destination: ARRAY OF CHAR): BOOLEAN;
  (* Returns TRUE if there is sufficient room in destination to append a string of
     length sourceLength to the string in destination; otherwise returns FALSE.
  *)

@findex CanConcatAll
PROCEDURE CanConcatAll (source1Length, source2Length: CARDINAL;
                        VAR destination: ARRAY OF CHAR): BOOLEAN;
  (* Returns TRUE if there is sufficient room in destination for a two strings of
     lengths source1Length and source2Length; otherwise returns FALSE.
  *)

(* The following type and procedures provide for the comparison of string values, and for the
   location of substrings within strings.
*)

TYPE
  CompareResults = (less, equal, greater);

@findex Compare
PROCEDURE Compare (stringVal1, stringVal2: ARRAY OF CHAR): CompareResults;
  (* Returns less, equal, or greater, according as stringVal1 is lexically less than,
     equal to, or greater than stringVal2.
  *)

@findex Equal
PROCEDURE Equal (stringVal1, stringVal2: ARRAY OF CHAR): BOOLEAN;
  (* Returns Strings.Compare(stringVal1, stringVal2) = Strings.equal *)

@findex FindNext
PROCEDURE FindNext (pattern, stringToSearch: ARRAY OF CHAR; startIndex: CARDINAL;
                    VAR patternFound: BOOLEAN; VAR posOfPattern: CARDINAL);
  (* Looks forward for next occurrence of pattern in stringToSearch, starting the search at
     position startIndex. If startIndex < LENGTH(stringToSearch) and pattern is found,
     patternFound is returned as TRUE, and posOfPattern contains the start position in
     stringToSearch of pattern. Otherwise patternFound is returned as FALSE, and posOfPattern
     is unchanged.
  *)

@findex FindPrev
PROCEDURE FindPrev (pattern, stringToSearch: ARRAY OF CHAR; startIndex: CARDINAL;
                    VAR patternFound: BOOLEAN; VAR posOfPattern: CARDINAL);
  (* Looks backward for the previous occurrence of pattern in stringToSearch and returns the
     position of the first character of the pattern if found. The search for the pattern
     begins at startIndex. If pattern is found, patternFound is returned as TRUE, and
     posOfPattern contains the start position in stringToSearch of pattern in the range
     [0..startIndex]. Otherwise patternFound is returned as FALSE, and posOfPattern is unchanged.
  *)

@findex FindDiff
PROCEDURE FindDiff (stringVal1, stringVal2: ARRAY OF CHAR;
                    VAR differenceFound: BOOLEAN; VAR posOfDifference: CARDINAL);
  (* Compares the string values in stringVal1 and stringVal2 for differences. If they
     are equal, differenceFound is returned as FALSE, and TRUE otherwise. If
     differenceFound is TRUE, posOfDifference is set to the position of the first
     difference; otherwise posOfDifference is unchanged.
  *)

@findex Capitalize
PROCEDURE Capitalize (VAR stringVar: ARRAY OF CHAR);
  (* Applies the function CAP to each character of the string value in stringVar. *)

END Strings.

@end example
@page


@node gm2-iso/SysClock, gm2-iso/TERMINATION, gm2-iso/Strings, M2 ISO Libraries
@subsection gm2-iso/SysClock

@example
DEFINITION MODULE SysClock;

(* Facilities for accessing a system clock that records the date and time of day *)

CONST
  maxSecondParts = <implementation-defined integral value>;

TYPE
  Month    = [1 .. 12];
  Day      = [1 .. 31];
  Hour     = [0 .. 23];
  Min      = [0 .. 59];
  Sec      = [0 .. 59];
  Fraction = [0 .. maxSecondParts];
  UTCDiff  = [-780 .. 720];
  DateTime =
    RECORD
      year:      CARDINAL;
      month:     Month;
      day:       Day;
      hour:      Hour;
      minute:    Min;
      second:    Sec;
      fractions: Fraction;      (* parts of a second *)
      zone:      UTCDiff;       (* Time zone differential factor which is the number
                                   of minutes to add to local time to obtain UTC. *)
      summerTimeFlag: BOOLEAN;  (* Interpretation of flag depends on local usage. *)
    END;

@findex CanGetClock
PROCEDURE CanGetClock(): BOOLEAN;
(* Tests if the clock can be read *)

@findex CanSetClock
PROCEDURE CanSetClock(): BOOLEAN;
(* Tests if the clock can be set *)

@findex IsValidDateTime
PROCEDURE IsValidDateTime(userData: DateTime): BOOLEAN;
(* Tests if the value of userData is a valid *)

@findex GetClock
PROCEDURE GetClock(VAR userData: DateTime);
(* Assigns local date and time of the day to userData *)

@findex SetClock
PROCEDURE SetClock(userData: DateTime): BOOLEAN;
(* Sets the system time clock to the given local date and time *)

END SysClock.
@end example
@page


@node gm2-iso/TERMINATION, gm2-iso/TermFile, gm2-iso/SysClock, M2 ISO Libraries
@subsection gm2-iso/TERMINATION

@example
DEFINITION MODULE TERMINATION;

(* Provides facilities for enquiries concerning the occurrence of termination events. *)

@findex IsTerminating
PROCEDURE IsTerminating (): BOOLEAN ;
  (* Returns true if any coroutine has started  program termination and false otherwise. *)

@findex HasHalted
PROCEDURE HasHalted (): BOOLEAN ;
  (* Returns true if a call to HALT has been made and false otherwise. *)

END TERMINATION.
@end example
@page


@node gm2-iso/TermFile, gm2-iso/TextIO, gm2-iso/TERMINATION, M2 ISO Libraries
@subsection gm2-iso/TermFile

@example
DEFINITION MODULE TermFile;

  (* Access to the terminal device *)

  (* Channels opened by this module are connected to a single terminal device; typed
     characters are distributed between channels according to the sequence of read requests.
  *)

IMPORT IOChan, ChanConsts;

TYPE
  ChanId = IOChan.ChanId;
  FlagSet = ChanConsts.FlagSet;
  OpenResults = ChanConsts.OpenResults;

  (* Accepted singleton values of FlagSet *)

CONST
  read = FlagSet@{ChanConsts.readFlag@};   (* input operations are requested/available *)
  write = FlagSet@{ChanConsts.writeFlag@}; (* output operations are requested/available *)
  text = FlagSet@{ChanConsts.textFlag@};   (* text operations are requested/available *)
  raw = FlagSet@{ChanConsts.rawFlag@};     (* raw operations are requested/available *)
  echo = FlagSet@{ChanConsts.echoFlag@};   (* echoing by interactive device on reading of
                                            characters from input stream requested/applies
                                         *)

@findex Open
PROCEDURE Open (VAR cid: ChanId; flags: FlagSet; VAR res: OpenResults);
  (* Attempts to obtain and open a channel connected to the terminal.
     Without the raw flag, text is implied.
     Without the echo flag, line mode is requested, otherwise single character mode is
     requested.
     If successful, assigns to cid the identity of the opened channel, and assigns the value
     opened to res.
     If a channel cannot be opened as required, the value of res indicates the reason, and
     cid identifies the invalid channel.
  *)

@findex IsTermFile
PROCEDURE IsTermFile (cid: ChanId): BOOLEAN;
  (* Tests if the channel identified by cid is open to the terminal. *)

@findex Close
PROCEDURE Close (VAR cid: ChanId);
  (* If the channel identified by cid is not open to the terminal, the exception wrongDevice
     is raised; otherwise closes the channel and assigns the value identifying the invalid
     channel to cid.
  *)

END TermFile.

@end example
@page


@node gm2-iso/TextIO, gm2-iso/WholeConv, gm2-iso/TermFile, M2 ISO Libraries
@subsection gm2-iso/TextIO

@example
DEFINITION MODULE TextIO;

  (* Input and output of character and string types over specified channels.
     The read result is of the type IOConsts.ReadResults.
  *)

IMPORT IOChan;

  (* The following procedures do not read past line marks *)

@findex ReadChar
PROCEDURE ReadChar (cid: IOChan.ChanId; VAR ch: CHAR);
  (* If possible, removes a character from the input stream cid and assigns the
     corresponding value to ch.  The read result is set to the value allRight, endOfLine, or
     endOfInput.
  *)

@findex ReadRestLine
PROCEDURE ReadRestLine (cid: IOChan.ChanId; VAR s: ARRAY OF CHAR);
  (* Removes any remaining characters from the input stream cid before the next line mark,
     copying to s as many as can be accommodated as a string value. The read result is set
     to the value allRight, outOfRange, endOfLine, or endOfInput.
  *)

@findex ReadString
PROCEDURE ReadString (cid: IOChan.ChanId; VAR s: ARRAY OF CHAR);
  (* Removes only those characters from the input stream cid before the next line mark that
     can be accommodated in s as a string value, and copies them to s.  The read result is
     set to the value allRight, endOfLine, or endOfInput.
  *)

@findex ReadToken
PROCEDURE ReadToken (cid: IOChan.ChanId; VAR s: ARRAY OF CHAR);
  (* Skips leading spaces, and then removes characters from the input stream cid before the
     next space or line mark, copying to s as many as can be accommodated as a string value.
     The read result is set to the value allRight, outOfRange, endOfLine, or endOfInput.
  *)

  (* The following procedure reads past the next line mark *)

@findex SkipLine
PROCEDURE SkipLine (cid: IOChan.ChanId);
  (* Removes successive items from the input stream cid up to and including the next line
     mark, or until the end of input is reached.  The read result is set to the value
     allRight, or endOfInput.
  *)

  (* Output procedures *)

@findex WriteChar
PROCEDURE WriteChar (cid: IOChan.ChanId; ch: CHAR);
  (* Writes the value of ch to the output stream cid. *)

@findex WriteLn
PROCEDURE WriteLn (cid: IOChan.ChanId);
  (* Writes a line mark to the output stream cid. *)

@findex WriteString
PROCEDURE WriteString (cid: IOChan.ChanId; s: ARRAY OF CHAR);
  (* Writes the string value in s to the output stream cid. *)

END TextIO.

@end example
@page


@node gm2-iso/WholeConv, gm2-iso/WholeIO, gm2-iso/TextIO, M2 ISO Libraries
@subsection gm2-iso/WholeConv

@example
DEFINITION MODULE WholeConv;

  (* Low-level whole-number/string conversions *)

IMPORT
  ConvTypes;

TYPE
  ConvResults = ConvTypes.ConvResults; (* strAllRight, strOutOfRange, strWrongFormat, strEmpty *)

@findex ScanInt
PROCEDURE ScanInt (inputCh: CHAR; VAR chClass: ConvTypes.ScanClass;
                   VAR nextState: ConvTypes.ScanState);
  (* Represents the start state of a finite state scanner for signed whole numbers -
     assigns class of inputCh to chClass and a procedure representing the next state to
     nextState.
  *)

@findex FormatInt
PROCEDURE FormatInt (str: ARRAY OF CHAR): ConvResults;
  (* Returns the format of the string value for conversion to INTEGER. *)

@findex ValueInt
PROCEDURE ValueInt (str: ARRAY OF CHAR): INTEGER;
  (* Returns the value corresponding to the signed whole number string value str if str
     is well-formed; otherwise raises the WholeConv exception.
  *)

@findex LengthInt
PROCEDURE LengthInt (int: INTEGER): CARDINAL;
  (* Returns the number of characters in the string representation of int. *)

@findex ScanCard
PROCEDURE ScanCard (inputCh: CHAR; VAR chClass: ConvTypes.ScanClass;
                    VAR nextState: ConvTypes.ScanState);
  (* Represents the start state of a finite state scanner for unsigned whole numbers -
     assigns class of inputCh to chClass and a procedure representing the next state to
     nextState.
  *)

@findex FormatCard
PROCEDURE FormatCard (str: ARRAY OF CHAR): ConvResults;
  (* Returns the format of the string value for conversion to CARDINAL. *)

@findex ValueCard
PROCEDURE ValueCard (str: ARRAY OF CHAR): CARDINAL;
  (* Returns the value corresponding to the unsigned whole number string value str if
     str is well-formed; otherwise raises the WholeConv exception.
   *)

@findex LengthCard
PROCEDURE LengthCard (card: CARDINAL): CARDINAL;
  (* Returns the number of characters in the string representation of card. *)

@findex IsWholeConvException
PROCEDURE IsWholeConvException (): BOOLEAN;
  (* Returns TRUE if the current coroutine is in the exceptional execution state because
     of the raising of an exception in a routine from this module; otherwise returns
     FALSE.
  *)

END WholeConv.

@end example
@page


@node gm2-iso/WholeIO, gm2-iso/WholeStr, gm2-iso/WholeConv, M2 ISO Libraries
@subsection gm2-iso/WholeIO

@example
DEFINITION MODULE WholeIO;

  (* Input and output of whole numbers in decimal text form over specified channels.
     The read result is of the type IOConsts.ReadResults.
  *)

IMPORT IOChan;

  (* The text form of a signed whole number is
       ["+" | "-"], decimal digit, @{decimal digit@}

     The text form of an unsigned whole number is
       decimal digit, @{decimal digit@}
  *)

@findex ReadInt
PROCEDURE ReadInt (cid: IOChan.ChanId; VAR int: INTEGER);
  (* Skips leading spaces, and removes any remaining characters from cid that form part of a
     signed whole number.  The value of this number is assigned to int.  The read result is
     set to the value allRight, outOfRange, wrongFormat, endOfLine, or endOfInput.
  *)

@findex WriteInt
PROCEDURE WriteInt (cid: IOChan.ChanId; int: INTEGER; width: CARDINAL);
  (* Writes the value of int to cid in text form, in a field of the given minimum width. *)

@findex ReadCard
PROCEDURE ReadCard (cid: IOChan.ChanId; VAR card: CARDINAL);
  (* Skips leading spaces, and removes any remaining characters from cid that form part of
     an unsigned whole number.  The value of this number is assigned to card. The read
     result is set to the value allRight, outOfRange, wrongFormat, endOfLine, or endOfInput.
  *)

@findex WriteCard
PROCEDURE WriteCard (cid: IOChan.ChanId; card: CARDINAL; width: CARDINAL);
  (* Writes the value of card to cid in text form, in a field of the given minimum width. *)

END WholeIO.

@end example
@page


@node gm2-iso/WholeStr, , gm2-iso/WholeIO, M2 ISO Libraries
@subsection gm2-iso/WholeStr

@example
DEFINITION MODULE WholeStr;

  (* Whole-number/string conversions *)

IMPORT
  ConvTypes;

TYPE
  ConvResults = ConvTypes.ConvResults; (* strAllRight, strOutOfRange, strWrongFormat, strEmpty *)

(* the string form of a signed whole number is
     ["+" | "-"], decimal digit, @{decimal digit@}
*)

@findex StrToInt
PROCEDURE StrToInt (str: ARRAY OF CHAR; VAR int: INTEGER; VAR res: ConvResults);
  (* Ignores any leading spaces in str. If the subsequent characters in str are in the
     format of a signed whole number, assigns a corresponding value to int. Assigns a
     value indicating the format of str to res.
  *)

@findex IntToStr
PROCEDURE IntToStr (int: INTEGER; VAR str: ARRAY OF CHAR);
  (* Converts the value of int to string form and copies the possibly truncated result to str. *)

(* the string form of an unsigned whole number is
     decimal digit, @{decimal digit@}
*)

@findex StrToCard
PROCEDURE StrToCard (str: ARRAY OF CHAR; VAR card: CARDINAL; VAR res: ConvResults);
  (* Ignores any leading spaces in str. If the subsequent characters in str are in the
     format of an unsigned whole number, assigns a corresponding value to card.
     Assigns a value indicating the format of str to res.
  *)

@findex CardToStr
PROCEDURE CardToStr (card: CARDINAL; VAR str: ARRAY OF CHAR);
  (* Converts the value of card to string form and copies the possibly truncated result to str. *)

END WholeStr.

@end example
@page



@c ---------------------------------------------------------------------
@node ULM System Libraries, ULM Standard Libraries, M2 ISO Libraries, Libraries
@section ULM System Libraries

@menu
* ulm-lib-gm2/sys/Errno::Errno.def
* ulm-lib-gm2/sys/SYSTEM::SYSTEM.def
* ulm-lib-gm2/sys/Sys::Sys.def
* ulm-lib-gm2/sys/SysAccess::SysAccess.def
* ulm-lib-gm2/sys/SysAlarm::SysAlarm.def
* ulm-lib-gm2/sys/SysBreak::SysBreak.def
* ulm-lib-gm2/sys/SysClose::SysClose.def
* ulm-lib-gm2/sys/SysCreat::SysCreat.def
* ulm-lib-gm2/sys/SysDup::SysDup.def
* ulm-lib-gm2/sys/SysExec::SysExec.def
* ulm-lib-gm2/sys/SysExit::SysExit.def
* ulm-lib-gm2/sys/SysFcntl::SysFcntl.def
* ulm-lib-gm2/sys/SysFork::SysFork.def
* ulm-lib-gm2/sys/SysGetpid::SysGetpid.def
* ulm-lib-gm2/sys/SysGetuid::SysGetuid.def
* ulm-lib-gm2/sys/SysIoctl::SysIoctl.def
* ulm-lib-gm2/sys/SysKill::SysKill.def
* ulm-lib-gm2/sys/SysLink::SysLink.def
* ulm-lib-gm2/sys/SysLocations::SysLocations.def
* ulm-lib-gm2/sys/SysLseek::SysLseek.def
* ulm-lib-gm2/sys/SysOpen::SysOpen.def
* ulm-lib-gm2/sys/SysPanic::SysPanic.def
* ulm-lib-gm2/sys/SysPause::SysPause.def
* ulm-lib-gm2/sys/SysPipe::SysPipe.def
* ulm-lib-gm2/sys/SysRead::SysRead.def
* ulm-lib-gm2/sys/SysSetuid::SysSetuid.def
* ulm-lib-gm2/sys/SysSignal::SysSignal.def
* ulm-lib-gm2/sys/SysStat::SysStat.def
* ulm-lib-gm2/sys/SysTermIO::SysTermIO.def
* ulm-lib-gm2/sys/SysTime::SysTime.def
* ulm-lib-gm2/sys/SysUnlink::SysUnlink.def
* ulm-lib-gm2/sys/SysWait::SysWait.def
* ulm-lib-gm2/sys/SysWrite::SysWrite.def
* ulm-lib-gm2/sys/SystemTypes::SystemTypes.def
* ulm-lib-gm2/sys/UnixString::UnixString.def
@end menu


@node ulm-lib-gm2/sys/Errno, ulm-lib-gm2/sys/SYSTEM, , ULM System Libraries
@subsection ulm-lib-gm2/sys/Errno

@example
DEFINITION MODULE Errno;

   (* following constants have been extracted from
         /usr/include/sys/errno.h
      on SunOS 5.5.1 at 1997/02/26
   *)

   CONST
      EPERM           =   1;  EL3RST          =  40;  ELIBSCN         =  85;
      ENOENT          =   2;  ELNRNG          =  41;  ELIBMAX         =  86;
      ESRCH           =   3;  EUNATCH         =  42;  ELIBEXEC        =  87;
      EINTR           =   4;  ENOCSI          =  43;  EILSEQ          =  88;
      EIO             =   5;  EL2HLT          =  44;  ENOSYS          =  89;
      ENXIO           =   6;  EDEADLK         =  45;  ELOOP           =  90;
      E2BIG           =   7;  ENOLCK          =  46;  ERESTART        =  91;
      ENOEXEC         =   8;  ECANCELED       =  47;  ESTRPIPE        =  92;
      EBADF           =   9;  ENOTSUP         =  48;  ENOTEMPTY       =  93;
      ECHILD          =  10;  EDQUOT          =  49;  EUSERS          =  94;
      EAGAIN          =  11;  EBADE           =  50;  ENOTSOCK        =  95;
      ENOMEM          =  12;  EBADR           =  51;  EDESTADDRREQ    =  96;
      EACCES          =  13;  EXFULL          =  52;  EMSGSIZE        =  97;
      EFAULT          =  14;  ENOANO          =  53;  EPROTOTYPE      =  98;
      ENOTBLK         =  15;  EBADRQC         =  54;  ENOPROTOOPT     =  99;
      EBUSY           =  16;  EBADSLT         =  55;  EPROTONOSUPPORT = 120;
      EEXIST          =  17;  EDEADLOCK       =  56;  ESOCKTNOSUPPORT = 121;
      EXDEV           =  18;  EBFONT          =  57;  EOPNOTSUPP      = 122;
      ENODEV          =  19;  ENOSTR          =  60;  EPFNOSUPPORT    = 123;
      ENOTDIR         =  20;  ENODATA         =  61;  EAFNOSUPPORT    = 124;
      EISDIR          =  21;  ETIME           =  62;  EADDRINUSE      = 125;
      EINVAL          =  22;  ENOSR           =  63;  EADDRNOTAVAIL   = 126;
      ENFILE          =  23;  ENONET          =  64;  ENETDOWN        = 127;
      EMFILE          =  24;  ENOPKG          =  65;  ENETUNREACH     = 128;
      ENOTTY          =  25;  EREMOTE         =  66;  ENETRESET       = 129;
      ETXTBSY         =  26;  ENOLINK         =  67;  ECONNABORTED    = 130;
      EFBIG           =  27;  EADV            =  68;  ECONNRESET      = 131;
      ENOSPC          =  28;  ESRMNT          =  69;  ENOBUFS         = 132;
      ESPIPE          =  29;  ECOMM           =  70;  EISCONN         = 133;
      EROFS           =  30;  EPROTO          =  71;  ENOTCONN        = 134;
      EMLINK          =  31;  EMULTIHOP       =  74;  ESHUTDOWN       = 143;
      EPIPE           =  32;  EBADMSG         =  77;  ETOOMANYREFS    = 144;
      EDOM            =  33;  ENAMETOOLONG    =  78;  ETIMEDOUT       = 145;
      ERANGE          =  34;  EOVERFLOW       =  79;  ECONNREFUSED    = 146;
      ENOMSG          =  35;  ENOTUNIQ        =  80;  EHOSTDOWN       = 147;
      EIDRM           =  36;  EBADFD          =  81;  EHOSTUNREACH    = 148;
      ECHRNG          =  37;  EREMCHG         =  82;  EALREADY        = 149;
      EL2NSYNC        =  38;  ELIBACC         =  83;  EINPROGRESS     = 150;
      EL3HLT          =  39;  ELIBBAD         =  84;  ESTALE          = 151;

      EWOULDBLOCK     = EAGAIN;

   CONST
      maxerror = 151;
      maxmsglen = 41;
      maxnamelen = 15;

   TYPE
      ErrorNumber = [0..maxerror];
      ErrorMessage = ARRAY [0..maxmsglen] OF CHAR;
      ErrorName = ARRAY [0..maxnamelen] OF CHAR;

   VAR
      message: ARRAY ErrorNumber OF ErrorMessage;
      name: ARRAY ErrorNumber OF ErrorName;

   VAR
      errno: CARDINAL;

END Errno.
@end example
@page


@node ulm-lib-gm2/sys/SYSTEM, ulm-lib-gm2/sys/Sys, ulm-lib-gm2/sys/Errno, ULM System Libraries
@subsection ulm-lib-gm2/sys/SYSTEM

@example
DEFINITION MODULE FOR "C" SYSTEM ;

(*
    Description: provides a SYSTEM module for GNU Modula-2 so that the
                 ULM libraries can be built.
*)

EXPORT QUALIFIED (* the following are built into the compiler: *)
                 ADDRESS, WORD, BYTE, BITSET, ADR, TSIZE, SIZE,
                 (* the rest are implemented in SYSTEM.c *)
                 UNIXCALL, UNIXSIGNAL, UNIXFORK ;


(*
   UNIXCALL - returns TRUE if the syscall was successful, results from
              the system call are returned in r0 and r1.
*)

@findex UNIXCALL
PROCEDURE UNIXCALL (syscall: CARDINAL; VAR r0, r1: INTEGER; ...) : BOOLEAN;


(*
   UNIXFORK - returns TRUE if successful and pid is set to the son pid
              if the parent is returning. If the child is returning pid=0.
              UNIXFORK returns FALSE if an error occurs and errno is held in pid.
*)

@findex UNIXFORK
PROCEDURE UNIXFORK (VAR pid: CARDINAL) : BOOLEAN ;


(*
   UNIXSIGNAL -
*)

@findex UNIXSIGNAL
PROCEDURE UNIXSIGNAL (signo: CARDINAL; p: PROC;
                      VAR old: PROC; VAR result: CARDINAL) : BOOLEAN;


END SYSTEM.
@end example
@page


@node ulm-lib-gm2/sys/Sys, ulm-lib-gm2/sys/SysAccess, ulm-lib-gm2/sys/SYSTEM, ULM System Libraries
@subsection ulm-lib-gm2/sys/Sys

@example
DEFINITION MODULE Sys;

(*
   The constants included here are those which are needed to get
   the ulm modules working. This is a much reduced list from the
   original ULM library. Please email <gm2 at glam.ac.uk> if you
   require more system calls than those presented below:
*)

CONST
    access = 0 ;
    brk = 1 ;
    close = 2 ;
    creat = 3 ;
    dup = 4 ;
    execve = 5 ;
    exit = 6 ;
    fcntl = 7 ;
    fstat = 8 ;
    getdents = 9 ;
    getgid = 10 ;
    getpid = 11 ;
    gettimeofday = 12 ;
    getuid = 13 ;
    ioctl = 14 ;
    kill = 15 ;
    link = 16 ;
    lseek = 17 ;
    open = 18 ;
    pause = 19 ;
    pipe = 20 ;
    read = 21 ;
    setitimer = 22 ;
    setgid = 23 ;
    setuid = 24 ;
    stat = 25 ;
    times = 26 ;
    unlink = 27 ;
    wait = 28 ;
    write = 29 ;

END Sys.
@end example
@page


@node ulm-lib-gm2/sys/SysAccess, ulm-lib-gm2/sys/SysAlarm, ulm-lib-gm2/sys/Sys, ULM System Libraries
@subsection ulm-lib-gm2/sys/SysAccess

@example
DEFINITION MODULE SysAccess;

   PROCEDURE Access(filename: ARRAY OF CHAR; mode: CARDINAL) : BOOLEAN;

END SysAccess.
@end example
@page


@node ulm-lib-gm2/sys/SysAlarm, ulm-lib-gm2/sys/SysBreak, ulm-lib-gm2/sys/SysAccess, ULM System Libraries
@subsection ulm-lib-gm2/sys/SysAlarm

@example
DEFINITION MODULE SysAlarm;

   VAR
      previous: CARDINAL; (* previous amount *)

@findex Alarm
   PROCEDURE Alarm(sec: CARDINAL) : BOOLEAN;

END SysAlarm.
@end example
@page


@node ulm-lib-gm2/sys/SysBreak, ulm-lib-gm2/sys/SysClose, ulm-lib-gm2/sys/SysAlarm, ULM System Libraries
@subsection ulm-lib-gm2/sys/SysBreak

@example
DEFINITION MODULE SysBreak;

   FROM SYSTEM IMPORT ADDRESS;

@findex Break
   PROCEDURE Break(addr: ADDRESS) : BOOLEAN;

@findex Sbreak
   PROCEDURE Sbreak(incr: CARDINAL) : ADDRESS;

END SysBreak.
@end example
@page


@node ulm-lib-gm2/sys/SysClose, ulm-lib-gm2/sys/SysCreat, ulm-lib-gm2/sys/SysBreak, ULM System Libraries
@subsection ulm-lib-gm2/sys/SysClose

@example
DEFINITION MODULE SysClose;

   PROCEDURE Close(fd: CARDINAL) : BOOLEAN;

END SysClose.
@end example
@page


@node ulm-lib-gm2/sys/SysCreat, ulm-lib-gm2/sys/SysDup, ulm-lib-gm2/sys/SysClose, ULM System Libraries
@subsection ulm-lib-gm2/sys/SysCreat

@example
DEFINITION MODULE SysCreat;

   PROCEDURE Creat(VAR fd: CARDINAL; filename: ARRAY OF CHAR;
                   mode: CARDINAL) : BOOLEAN;

END SysCreat.
@end example
@page


@node ulm-lib-gm2/sys/SysDup, ulm-lib-gm2/sys/SysExec, ulm-lib-gm2/sys/SysCreat, ULM System Libraries
@subsection ulm-lib-gm2/sys/SysDup

@example
DEFINITION MODULE SysDup;

   PROCEDURE Dup(fd: CARDINAL; VAR newfd: CARDINAL) : BOOLEAN;

@findex Dup2
   PROCEDURE Dup2(fd, newfd: CARDINAL) : BOOLEAN;

END SysDup.
@end example
@page


@node ulm-lib-gm2/sys/SysExec, ulm-lib-gm2/sys/SysExit, ulm-lib-gm2/sys/SysDup, ULM System Libraries
@subsection ulm-lib-gm2/sys/SysExec

@example
DEFINITION MODULE SysExec;

   FROM SYSTEM IMPORT ADDRESS;

@findex Exec
   PROCEDURE Exec(name: ARRAY OF CHAR; argv: ADDRESS);

@findex Exece
   PROCEDURE Exece(name: ARRAY OF CHAR; argv, envp: ADDRESS);

END SysExec.
@end example
@page


@node ulm-lib-gm2/sys/SysExit, ulm-lib-gm2/sys/SysFcntl, ulm-lib-gm2/sys/SysExec, ULM System Libraries
@subsection ulm-lib-gm2/sys/SysExit

@example
DEFINITION MODULE SysExit;

   PROCEDURE Exit(exitCode: CARDINAL);

@findex EnterCleanup
   PROCEDURE EnterCleanup(p: PROC);

END SysExit.
@end example
@page


@node ulm-lib-gm2/sys/SysFcntl, ulm-lib-gm2/sys/SysFork, ulm-lib-gm2/sys/SysExit, ULM System Libraries
@subsection ulm-lib-gm2/sys/SysFcntl

@example
DEFINITION MODULE SysFcntl;

   FROM SYSTEM IMPORT WORD;

   TYPE
      FcntlRequest = (dupfd, getfd, setfd, getfl, setfl,getown,
			setown,getlk,setlk,setlkw);

@findex Fcntl
   PROCEDURE Fcntl(fd: CARDINAL; cmd: FcntlRequest; VAR arg: WORD) : BOOLEAN;

END SysFcntl.
@end example
@page


@node ulm-lib-gm2/sys/SysFork, ulm-lib-gm2/sys/SysGetpid, ulm-lib-gm2/sys/SysFcntl, ULM System Libraries
@subsection ulm-lib-gm2/sys/SysFork

@example
DEFINITION MODULE SysFork;

   (* IF pid = 0 THEN son ELSE father END *)

@findex Fork
   PROCEDURE Fork(VAR pid: CARDINAL) : BOOLEAN;

END SysFork.
@end example
@page


@node ulm-lib-gm2/sys/SysGetpid, ulm-lib-gm2/sys/SysGetuid, ulm-lib-gm2/sys/SysFork, ULM System Libraries
@subsection ulm-lib-gm2/sys/SysGetpid

@example
DEFINITION MODULE SysGetpid;			(* mh 11/1987 *)

   FROM SystemTypes IMPORT ProcessId;

@findex Getpid
   PROCEDURE Getpid(): ProcessId;

END SysGetpid.
@end example
@page


@node ulm-lib-gm2/sys/SysGetuid, ulm-lib-gm2/sys/SysIoctl, ulm-lib-gm2/sys/SysGetpid, ULM System Libraries
@subsection ulm-lib-gm2/sys/SysGetuid

@example
DEFINITION MODULE SysGetuid;

   PROCEDURE Getuid() : CARDINAL;

@findex Geteuid
   PROCEDURE Geteuid() : CARDINAL;

@findex Getgid
   PROCEDURE Getgid() : CARDINAL;

@findex Getegid
   PROCEDURE Getegid() : CARDINAL;

END SysGetuid.
@end example
@page


@node ulm-lib-gm2/sys/SysIoctl, ulm-lib-gm2/sys/SysKill, ulm-lib-gm2/sys/SysGetuid, ULM System Libraries
@subsection ulm-lib-gm2/sys/SysIoctl

@example
DEFINITION MODULE SysIoctl;

   (* SUN version *)

   FROM SYSTEM IMPORT BYTE, BITSET;

   CONST
      shift = 0;
      Tandem = @{ shift + 15 @};
      Cbreak = @{ shift + 14 @};
      Lcase  = @{ shift + 13 @};
      Echo   = @{ shift + 12 @};
      Crmod  = @{ shift + 11 @};
      Raw    = @{ shift + 10 @};
      Oddp   = @{ shift + 9 @};
      Evenp  = @{ shift + 8 @};
      Anyp   = Oddp + Evenp;
      Nldelay = @{ shift + 6 , shift + 7 @};
      Tbdelay = @{ shift + 4 , shift + 5 @};
      Xtabs  = @{ shift + 4 , shift + 5 @};
      Crdelay = @{ shift + 2 , 3 @};
      Vtdelay = @{ shift + 1 @};
      Bsdelay = @{ shift + 0 @};
      Alldelay = Bsdelay + Vtdelay + Crdelay +
                 Xtabs + Tbdelay + Nldelay;

      IocVoid = @{ 2 @};
      IocOut = @{ 1 @};
      IocIn = @{ 0 @};
      IocInOut = IocIn + IocOut;

      getd = BITSET(0) + IocOut;
      setd = BITSET(1) + IocIn;
      hpcl = BITSET(2) + IocVoid;
      modg = BITSET(3) + IocOut;
      mods = BITSET(4) + IocIn;
      getp = BITSET(8) + IocOut;
      setp = BITSET(9) + IocIn;
      setn = BITSET(10) + IocIn;
      excl = BITSET(13) + IocVoid;
      nxcl = BITSET(14) + IocVoid;
      flush = BITSET(16) + IocIn;
      setc = BITSET(17) + IocIn;
      getc = BITSET(18) + IocOut;
      (* BSD or SUN specific ioctl-calls *)
      lbis = BITSET(127) + IocIn;
      lbic = BITSET(126) + IocIn;
      lset = BITSET(125) + IocIn;
      lget = BITSET(124) + IocOut;
      sbrk = BITSET(123) + IocVoid;
      cbrk = BITSET(122) + IocVoid;
      cdtr = BITSET(120) + IocVoid;
      gprgp = BITSET(119) + IocOut;
      sprgp = BITSET(118) + IocIn;
      sltc = BITSET(117) + IocIn;
      gltc = BITSET(116) + IocOut;
      outq = BITSET(115) + IocOut;
      sti = BITSET(114) + IocIn;
      notty = BITSET(113) + IocVoid;
      pkt = BITSET(112) + IocIn;
      stop = BITSET(111) + IocVoid;
      start = BITSET(110) + IocVoid;
      mset = BITSET(109) + IocIn;
      mbis = BITSET(108) + IocIn;
      mbic = BITSET(107) + IocIn;
      mget = BITSET(106) + IocOut;
      remote = BITSET(105) + IocIn;
      gwinsz = BITSET(104) + IocOut;
      swinsz = BITSET(103) + IocIn;
      ucntl = BITSET(102) + IocIn;

      SizeOfSgttyb = 6;	(* size of corresponding C-structures *)
      SizeOfTchars = 6;
      SizeOfWinsize = 8;

      (* values of Sgttyb ispeed and ospeed *)
      b0    =  0;
      b50   =  1;
      b75   =  2;
      b110  =  3;
      b134  =  4;
      b150  =  5;
      b200  =  6;
      b300  =  7;
      b600  =  8;
      b1200 =  9;
      b1800 = 10;
      b2400 = 11;
      b4800 = 12;
      b9600 = 13;
      exta  = 14;
      extb  = 15;

   TYPE

      Sgttyb =
         RECORD
            ispeed: CHAR;
            ospeed: CHAR;
            erase: CHAR;
            kill: CHAR;
            flags: BITSET;
         END;

      Tchars =
         RECORD
            intrc: CHAR;
            quitc: CHAR;
            startc: CHAR;
            stopc: CHAR;
            eofc: CHAR;
            brkc: CHAR;
         END;

      Winsize =
	 RECORD
	    rows, cols: CARDINAL;
	    xpixels, ypixels: CARDINAL; (* not used *)
	 END;

@findex Ioctl
   PROCEDURE Ioctl(fd: CARDINAL; request: BITSET;
                   VAR argp: ARRAY OF BYTE;
		   argpsize: CARDINAL) : BOOLEAN;
      (* argpsize: size of corresponding C-structure *)

@findex Stty
   PROCEDURE Stty(fd: CARDINAL; argp: Sgttyb) : BOOLEAN;

@findex Gtty
   PROCEDURE Gtty(fd: CARDINAL; VAR argp: Sgttyb) : BOOLEAN;

@findex Isatty
   PROCEDURE Isatty(fd: CARDINAL) : BOOLEAN;

@findex GetWinsize
   PROCEDURE GetWinsize(fd: CARDINAL; VAR winbuf: Winsize) : BOOLEAN;

@findex Baudrate
   PROCEDURE Baudrate(speed: CHAR) : CARDINAL;

END SysIoctl.
@end example
@page


@node ulm-lib-gm2/sys/SysKill, ulm-lib-gm2/sys/SysLink, ulm-lib-gm2/sys/SysIoctl, ULM System Libraries
@subsection ulm-lib-gm2/sys/SysKill

@example
DEFINITION MODULE SysKill; (* AFB 9/88 *)

   FROM SystemTypes IMPORT Sig, ProcessId;

@findex Kill
   PROCEDURE Kill(pid: ProcessId; sig: Sig) : BOOLEAN;

END SysKill.
@end example
@page


@node ulm-lib-gm2/sys/SysLink, ulm-lib-gm2/sys/SysLocations, ulm-lib-gm2/sys/SysKill, ULM System Libraries
@subsection ulm-lib-gm2/sys/SysLink

@example
DEFINITION MODULE SysLink;

   PROCEDURE Link(name1, name2: ARRAY OF CHAR) : BOOLEAN;

END SysLink.
@end example
@page


@node ulm-lib-gm2/sys/SysLocations, ulm-lib-gm2/sys/SysLseek, ulm-lib-gm2/sys/SysLink, ULM System Libraries
@subsection ulm-lib-gm2/sys/SysLocations

@example
DEFINITION MODULE SysLocations;

   FROM SYSTEM IMPORT ADDRESS;

   VAR
      ProgramEnd, Etext, Edata, Break, Environment: ADDRESS;

END SysLocations.
@end example
@page


@node ulm-lib-gm2/sys/SysLseek, ulm-lib-gm2/sys/SysOpen, ulm-lib-gm2/sys/SysLocations, ULM System Libraries
@subsection ulm-lib-gm2/sys/SysLseek

@example
DEFINITION MODULE SysLseek;

   FROM SystemTypes IMPORT OFF;

@findex Lseek
   PROCEDURE Lseek(fd: CARDINAL; offset: OFF;
                   whence: CARDINAL) : BOOLEAN;

@findex Tell
   PROCEDURE Tell(fd: CARDINAL; VAR offset: OFF) : BOOLEAN;

END SysLseek.
@end example
@page


@node ulm-lib-gm2/sys/SysOpen, ulm-lib-gm2/sys/SysPanic, ulm-lib-gm2/sys/SysLseek, ULM System Libraries
@subsection ulm-lib-gm2/sys/SysOpen

@example
DEFINITION MODULE SysOpen;

   FROM SYSTEM IMPORT WORD;

   (* oflag: see SystemTypes *)

@findex Open
   PROCEDURE Open(VAR fd: CARDINAL; filename: ARRAY OF CHAR;
                  oflag: WORD) : BOOLEAN;

@findex OpenCreat
   PROCEDURE OpenCreat(VAR fd: CARDINAL; filename: ARRAY OF CHAR;
		       oflag: WORD; mode: CARDINAL) : BOOLEAN;

END SysOpen.
@end example
@page


@node ulm-lib-gm2/sys/SysPanic, ulm-lib-gm2/sys/SysPause, ulm-lib-gm2/sys/SysOpen, ULM System Libraries
@subsection ulm-lib-gm2/sys/SysPanic

@example
DEFINITION MODULE SysPanic;

   (* print text on stderr and abort with HALT *)

@findex Panic
   PROCEDURE Panic(text: ARRAY OF CHAR);

END SysPanic.
@end example
@page


@node ulm-lib-gm2/sys/SysPause, ulm-lib-gm2/sys/SysPipe, ulm-lib-gm2/sys/SysPanic, ULM System Libraries
@subsection ulm-lib-gm2/sys/SysPause

@example
DEFINITION MODULE SysPause;

   PROCEDURE Pause;

END SysPause.
@end example
@page


@node ulm-lib-gm2/sys/SysPipe, ulm-lib-gm2/sys/SysRead, ulm-lib-gm2/sys/SysPause, ULM System Libraries
@subsection ulm-lib-gm2/sys/SysPipe

@example
DEFINITION MODULE SysPipe;

   PROCEDURE Pipe(VAR ReadFileDesc, WriteFileDesc: CARDINAL) : BOOLEAN;

END SysPipe.
@end example
@page


@node ulm-lib-gm2/sys/SysRead, ulm-lib-gm2/sys/SysSetuid, ulm-lib-gm2/sys/SysPipe, ULM System Libraries
@subsection ulm-lib-gm2/sys/SysRead

@example
DEFINITION MODULE SysRead;

   FROM SYSTEM IMPORT ADDRESS;

@findex Read
   PROCEDURE Read(fd: CARDINAL; ptr: ADDRESS;
                  VAR bytecount: CARDINAL) : BOOLEAN;

END SysRead.
@end example
@page


@node ulm-lib-gm2/sys/SysSetuid, ulm-lib-gm2/sys/SysSignal, ulm-lib-gm2/sys/SysRead, ULM System Libraries
@subsection ulm-lib-gm2/sys/SysSetuid

@example
DEFINITION MODULE SysSetuid;

   PROCEDURE Setuid(uid: CARDINAL) : BOOLEAN;

@findex Setgid
   PROCEDURE Setgid(gid: CARDINAL) : BOOLEAN;

END SysSetuid.
@end example
@page


@node ulm-lib-gm2/sys/SysSignal, ulm-lib-gm2/sys/SysStat, ulm-lib-gm2/sys/SysSetuid, ULM System Libraries
@subsection ulm-lib-gm2/sys/SysSignal

@example
DEFINITION MODULE SysSignal;

   FROM SystemTypes IMPORT Sig;

   VAR
      default, ignore: PROC;
      old: PROC; (* will be set after each successfull Signal-call *)

@findex Signal
   PROCEDURE Signal(sig: Sig; p: PROC) : BOOLEAN;

END SysSignal.
@end example
@page


@node ulm-lib-gm2/sys/SysStat, ulm-lib-gm2/sys/SysTermIO, ulm-lib-gm2/sys/SysSignal, ULM System Libraries
@subsection ulm-lib-gm2/sys/SysStat

@example
DEFINITION MODULE SysStat;

   FROM SystemTypes IMPORT TIME, OFF;
   FROM SYSTEM IMPORT BITSET ;

   TYPE
      StatBuf =
         RECORD
            dev: CARDINAL;
            ino: CARDINAL;
            mode: BITSET;
            nlink: CARDINAL;
            uid: CARDINAL;
            gid: CARDINAL;
            rdev: CARDINAL;
            size: OFF;
            atime: TIME;
	    spare1 : CARDINAL;
            mtime: TIME;
	    spare2 : CARDINAL;
            ctime: TIME;
	    spare3 : CARDINAL;
	    blksize : CARDINAL;
	    blocks : CARDINAL;
	    spare4 : ARRAY[0..1] OF CARDINAL;
         END;
   CONST
      (* bit masks for mode; bits 0..15 used *)
      FileType = @{ 0..3 @};
      (* IF Ifxxx = mode * FileType *)
      IfDir = @{ 1 @};      (* directory *)
      IfChr = @{ 2 @};      (* character special *)
      IfBlk = @{ 1..2 @};   (* block special *)
      IfReg = @{ 0 @};      (* regular *)
      IfLnk = @{ 0,2 @};	  (* symbolic link *)
      IfSock = @{ 0..1 @};  (* socket *)
      IfFifo = @{ 3 @};     (* fifo *)
      (* IF Isxxx <= mode THEN *)
      IsUid =  @{ 4 @};     (* set user id on execution *)
      IsGid =  @{ 5 @};     (* set group id on execution *)
      IsVtx =  @{ 6 @};     (* save swapped text even after use *)
      (* permissions on file: IF ... <= mode *)
      OwnerRead = @{ 7 @};  (* read permission, owner *)
      OwnerWrite = @{ 8 @}; (* write permission, owner *)
      OwnerExec = @{ 9 @};  (* execute/search permission, owner *)
      GroupRead = @{ 10 @};
      GroupWrite = @{ 11 @};
      GroupExec = @{ 12 @};
      WorldRead = @{ 13 @};
      WorldWrite = @{ 14 @};
      WorldExec = @{ 15 @};

@findex Stat
   PROCEDURE Stat(file: ARRAY OF CHAR; VAR buf: StatBuf) : BOOLEAN;

@findex Fstat
   PROCEDURE Fstat(fd: CARDINAL; VAR buf: StatBuf) : BOOLEAN;

END SysStat.
@end example
@page


@node ulm-lib-gm2/sys/SysTermIO, ulm-lib-gm2/sys/SysTime, ulm-lib-gm2/sys/SysStat, ULM System Libraries
@subsection ulm-lib-gm2/sys/SysTermIO

@example
DEFINITION MODULE SysTermIO;

FROM SYSTEM IMPORT BITSET ;

   (* see termio(7) for explanations *)

   CONST
      (* add ``x-'' globally for big-endian representation of SETs *)
      x = 31;
      (* input modes *)
      ignbrk = @{ 31 @};
      brkint = @{ 30 @};
      ignpar = @{ 29 @};
      parmrk = @{ 28 @};
      inpck = @{ 27 @};
      istrip = @{ 26 @};
      inlcr = @{ 25 @};
      igncr = @{ 24 @};
      icrnl = @{ 23 @};
      iuclc = @{ 22 @};
      ixon = @{ 21 @};
      ixany = @{ 20 @};
      ixoff = @{ 19 @};
      (* output modes *)
      opost = @{ 31 @};
      olcuc = @{ 30 @};
      onlcr = @{ 29 @};
      ocrnl = @{ 28 @};
      onocr = @{ 27 @};
      onlret = @{ 26 @};
      ofill = @{ 25 @};
      ofdel = @{ 24 @};
      (* delays for newline *)
      nldly = @{ 23 @};		(* mask *)
      nl0 = @{ @};
      nl1 = @{ 23 @};
      (* delays for carriage return *)
      crdly = @{ 21, x-22 @};	(* mask *)
      cr0 = @{ @};
      cr1 = @{ 22 @};
      cr2 = @{ 21 @};
      cr3 = @{ 21, x-22 @};
      (* delays for tabs *)
      tabdly = @{ 19, x-20 @};	(* mask *)
      tab1 = @{ 20 @};
      tab2 = @{ 19 @};
      tab3 = @{ 19, x-20 @};	(* expand tabs to spaces *)
      (* delays for backspaces *)
      bsdly = @{ 18 @};		(* mask *)
      bs0 = @{ @};
      bs1 = @{ 18 @};
      (* delays for vertical tabs *)
      vtdly = @{ 17 @};		(* mask *)
      vt0 = @{ @};
      vt1 = @{ 17 @};
      (* delays for form feeds *)
      ffdly = @{ 16 @};
      ff0 = @{ @};
      ff1 = @{ 16 @};

      (* control modes *)
      cbaud = @{ 28, x-29, x-30, x-31 @};	(* mask *)
      b0 = @{@};
      b50 = @{ 31 @};
      b75 = @{ 30 @};
      b110 = @{ 29, x-30 @};
      b134 = @{ 29 @};
      b150 = @{ 29, x-31 @};
      b200 = @{ 29, x-30 @};
      b300 = @{ 29, x-30, x-31 @};
      b600 = @{ 28 @};
      b1200 = @{ 28, x-31 @};
      b1800 = @{ 28, x-30 @};
      b2400 = @{ 28, x-30, x-31 @};
      b4800 = @{ 28, x-29 @};
      b9600 = @{ 28, x-29, x-31 @};
      b19200 = @{ 28, x-29, x-30 @};
      b38400 = @{ 28, x-29, x-30, x-31 @};
      csize = @{ 26, x-27 @};	(* mask *)
      cs5 = @{@};
      cs6 = @{ 27 @};
      cs7 = @{ 26 @};
      cs8 = @{ 26, x-27 @};
      cstopb = @{ 25 @};
      cread = @{ 24 @};
      parenb = @{ 23 @};
      parodd = @{ 22 @};
      hupcl = @{ 21 @};
      clocal = @{ 20 @};

      (* line modes *)
      isig = @{ 31 @};
      icanon = @{ 30 @};
      xcase = @{ 29 @};
      echo = @{ 28 @};
      echoe = @{ 27 @};
      echok = @{ 26 @};
      echonl = @{ 25 @};
      noflsh = @{ 24 @};
   TYPE
      ControlChars = (vintr, vquit, verase, vkill, veof, veol, veol2, vswtch);
   CONST
      vmin = veof; vtime = veol;

   TYPE
      ControlCharsRange = [MIN(ControlChars)..MAX(ControlChars)];
      InputModes = BITSET;
      OutputModes = BITSET;
      ControlModes = BITSET;
      LineModes = BITSET;
      TermIO =
	 RECORD
	    inputmodes: InputModes;
	    outputmodes: OutputModes;
	    controlmodes: ControlModes;
	    linemodes: LineModes;
	    linedisc: CHAR;
	    cc: ARRAY ControlCharsRange OF CHAR;
	 END;

      Winsize =
	 RECORD
	    rows, cols: CARDINAL;
	    xpixels, ypixels: CARDINAL;
	 END;

@findex SetTermIO
   PROCEDURE SetTermIO(fd: CARDINAL; termio: TermIO) : BOOLEAN;

@findex GetTermIO
   PROCEDURE GetTermIO(fd: CARDINAL; VAR termio: TermIO) : BOOLEAN;

@findex GetWinsize
   PROCEDURE GetWinsize(fd: CARDINAL; VAR winbuf: Winsize) : BOOLEAN;

@findex Baudrate
   PROCEDURE Baudrate(termio: TermIO) : CARDINAL;

@findex Isatty
   PROCEDURE Isatty(fd: CARDINAL) : BOOLEAN;

END SysTermIO.
@end example
@page


@node ulm-lib-gm2/sys/SysTime, ulm-lib-gm2/sys/SysUnlink, ulm-lib-gm2/sys/SysTermIO, ULM System Libraries
@subsection ulm-lib-gm2/sys/SysTime

@example
DEFINITION MODULE SysTime; (* AFB 4/84 *)

   FROM SystemTypes IMPORT TIME;

@findex Time
   PROCEDURE Time(VAR t: TIME) : BOOLEAN;

END SysTime.
@end example
@page


@node ulm-lib-gm2/sys/SysUnlink, ulm-lib-gm2/sys/SysWait, ulm-lib-gm2/sys/SysTime, ULM System Libraries
@subsection ulm-lib-gm2/sys/SysUnlink

@example
DEFINITION MODULE SysUnlink;

   PROCEDURE Unlink(name: ARRAY OF CHAR) : BOOLEAN;

END SysUnlink.
@end example
@page


@node ulm-lib-gm2/sys/SysWait, ulm-lib-gm2/sys/SysWrite, ulm-lib-gm2/sys/SysUnlink, ULM System Libraries
@subsection ulm-lib-gm2/sys/SysWait

@example
DEFINITION MODULE SysWait;

   PROCEDURE Wait(VAR pid, status: CARDINAL) : BOOLEAN;

END SysWait.
@end example
@page


@node ulm-lib-gm2/sys/SysWrite, ulm-lib-gm2/sys/SystemTypes, ulm-lib-gm2/sys/SysWait, ULM System Libraries
@subsection ulm-lib-gm2/sys/SysWrite

@example
DEFINITION MODULE SysWrite;

   FROM SYSTEM IMPORT ADDRESS;

@findex Write
   PROCEDURE Write(fd: CARDINAL; ptr: ADDRESS;
                   VAR bytecount: CARDINAL) : BOOLEAN;

END SysWrite.
@end example
@page


@node ulm-lib-gm2/sys/SystemTypes, ulm-lib-gm2/sys/UnixString, ulm-lib-gm2/sys/SysWrite, ULM System Libraries
@subsection ulm-lib-gm2/sys/SystemTypes

@example
DEFINITION MODULE SystemTypes; (* and constants *)

   (* see...
	/usr/include/fcntl.h
	/usr/include/signal.h
	/usr/include/sys/dir.h
	/usr/include/sys/param.h
	/usr/include/sys/types.h
   *)

   CONST
      DirSize = 255;
      MaxOpenFiles = 128;
      (* file control options; arguments of fcntl(2) and open(2) *)
      rdonly = @{@};
      wronly = @{ 31 @};
      rdwr = @{ 30 @};
      ndelay = @{ 29 @};
      append = @{ 28 @};
      async = @{ 25 @};
      creat = @{ 22 @};
      trunc = @{ 21 @};
      excl = @{ 20 @};
      nbio = @{ 19 @};
      sync = @{ 18 @};
   TYPE
      Sig = (SIG0,                                                     (*  0 *)
	     SIGHUP, SIGINT, SIGQUIT, SIGILL, SIGTRAP, SIGIOT, SIGEMT, (*  7 *)
	     SIGFPE, SIGKILL, SIGBUS, SIGSEGV, SIGSYS, SIGPIPE,        (* 13 *)
	     SIGALRM, SIGTERM, SIGUSR1, SIGUSR2, SIGCHLD, SIGPWR,      (* 19 *)
	     SIGWINCH, SIGURG, SIGPOLL, SIGSTOP, SIGTSTP, SIGCONT,     (* 25 *)
	     SIGTTIN, SIGTTOU, SIGVTALRM, SIGPROF, SIGXCPU, SIGXFSZ,   (* 31 *)
	     SIGWAITING, SIGLWP, SIGFREEZE, SIGTHAW,                   (* 35 *)
	     SIGRT36, SIGRT37, SIGRT38, SIGRT39, SIGRT40, SIGRT41,     (* 41 *)
	     SIGRT42, SIGRT43);                                        (* 43 *)
   CONST
      (* aliases *)
      SIGABRT = SIGIOT;
      SIGCLD = SIGCHLD;
      SIGIO = SIGPOLL;
      SIGRTMIN = SIGRT36;
      SIGRTMAX = SIGRT43;

   TYPE
      SigSet = SET OF Sig;

      ProcessId = INTEGER;	(* ProcessId may be -1 for kill *)
      TIME = LONGINT;
      OFF = LONGINT;		(* offset/size of files *)

END SystemTypes.
@end example
@page


@node ulm-lib-gm2/sys/UnixString, , ulm-lib-gm2/sys/SystemTypes, ULM System Libraries
@subsection ulm-lib-gm2/sys/UnixString

@example
DEFINITION MODULE UnixString;

   CONST
      BufSiz = 512;
   TYPE
      Buffer = ARRAY[0..BufSiz-1] OF CHAR;

@findex Copy
   PROCEDURE Copy(VAR buf: Buffer; str: ARRAY OF CHAR);
      (* copy str to Buf and guarantee 0C-termination;
         str is silently truncated on copying if necessary
      *)

END UnixString.
@end example
@page



@c ---------------------------------------------------------------------
@node ULM Standard Libraries, , ULM System Libraries, Libraries
@section ULM Standard Libraries

@menu
* ulm-lib-gm2/std/ASCII::ASCII.def
* ulm-lib-gm2/std/Archive::Archive.def
* ulm-lib-gm2/std/Arguments::Arguments.def
* ulm-lib-gm2/std/Calendar::Calendar.def
* ulm-lib-gm2/std/CallShell::CallShell.def
* ulm-lib-gm2/std/Clock::Clock.def
* ulm-lib-gm2/std/Conversions::Conversions.def
* ulm-lib-gm2/std/Directories::Directories.def
* ulm-lib-gm2/std/Environment::Environment.def
* ulm-lib-gm2/std/EtcGroup::EtcGroup.def
* ulm-lib-gm2/std/Files::Files.def
* ulm-lib-gm2/std/FtdIO::FtdIO.def
* ulm-lib-gm2/std/Functions::Functions.def
* ulm-lib-gm2/std/GetPass::GetPass.def
* ulm-lib-gm2/std/InOut::InOut.def
* ulm-lib-gm2/std/MathLib::MathLib.def
* ulm-lib-gm2/std/Passwd::Passwd.def
* ulm-lib-gm2/std/PipeIO::PipeIO.def
* ulm-lib-gm2/std/Plot::Plot.def
* ulm-lib-gm2/std/RTErrors::RTErrors.def
* ulm-lib-gm2/std/RandomGenerator::RandomGenerator.def
* ulm-lib-gm2/std/ReadIntCard::ReadIntCard.def
* ulm-lib-gm2/std/RealConv::RealConv.def
* ulm-lib-gm2/std/RealInOut::RealInOut.def
* ulm-lib-gm2/std/ScanPwfile::ScanPwfile.def
* ulm-lib-gm2/std/StdFuncs::StdFuncs.def
* ulm-lib-gm2/std/StdIO::StdIO.def
* ulm-lib-gm2/std/Storage::Storage.def
* ulm-lib-gm2/std/StrSpec::StrSpec.def
* ulm-lib-gm2/std/StrToNum::StrToNum.def
* ulm-lib-gm2/std/StrToReal::StrToReal.def
* ulm-lib-gm2/std/Strings::Strings.def
* ulm-lib-gm2/std/SysConf::SysConf.def
* ulm-lib-gm2/std/SysPerror::SysPerror.def
* ulm-lib-gm2/std/Terminal::Terminal.def
* ulm-lib-gm2/std/TimeIO::TimeIO.def
@end menu


@node ulm-lib-gm2/std/ASCII, ulm-lib-gm2/std/Archive, , ULM Standard Libraries
@subsection ulm-lib-gm2/std/ASCII

@example
DEFINITION MODULE ASCII;

   CONST

      (* control characters *)

      nul = 0C;   ack = 6C;   ff  = 14C;  dc2 = 22C;  can = 30C;  rs  = 36C;
      soh = 1C;   bel = 7C;   cr  = 15C;  dc3 = 23C;  em  = 31C;  us  = 37C;
      stx = 2C;   bs  = 10C;  so  = 16C;  dc4 = 24C;  sub = 32C;  sp  = 40C;
      etx = 3C;   ht  = 11C;  si  = 17C;  nak = 25C;  esc = 33C;
      eot = 4C;   lf  = 12C;  dle = 20C;  syn = 26C;  fs  = 34C;
      enq = 5C;   vt  = 13C;  dc1 = 21C;  etb = 27C;  gs  = 35C;

      (* other usual names *)

      null = nul;
      bell = bel;
      nl   = lf; (* new line *)
      tab  = ht;
      np   = ff; (* new page *)

      del  = 177C;

END ASCII.
@end example
@page


@node ulm-lib-gm2/std/Archive, ulm-lib-gm2/std/Arguments, ulm-lib-gm2/std/ASCII, ULM Standard Libraries
@subsection ulm-lib-gm2/std/Archive

@example
DEFINITION MODULE Archive; (* AFB 3/84 *)

   FROM SYSTEM IMPORT BITSET ;
   FROM SystemTypes IMPORT TIME, OFF;

   (* routines for reading an archive file *)

   CONST NameLength = 14;

   TYPE AFILE; (* hidden *)
      FileName = ARRAY[0..NameLength-1] OF CHAR;
      AStat =
         RECORD
            name: FileName;
            uid, gid: CARDINAL;
            date: TIME;
            size: OFF;
            mode: BITSET;
	    offset: OFF; (* absolute offset in archive file *)
         END;

@findex ArchiveOpen
   PROCEDURE ArchiveOpen(VAR a: AFILE; archive: ARRAY OF CHAR;
			 filename: ARRAY OF CHAR) : BOOLEAN;

@findex ArchiveReopen
   PROCEDURE ArchiveReopen(a: AFILE; filename: ARRAY OF CHAR) : BOOLEAN;
   (* in case of an error "a" will be closed *)

@findex ArchiveClose
   PROCEDURE ArchiveClose(a: AFILE);

@findex ArchiveRead
   PROCEDURE ArchiveRead(a: AFILE; VAR ch: CHAR) : BOOLEAN;

@findex ArchiveStat
   PROCEDURE ArchiveStat(a: AFILE; VAR buf: AStat);

END Archive.
@end example
@page


@node ulm-lib-gm2/std/Arguments, ulm-lib-gm2/std/Calendar, ulm-lib-gm2/std/Archive, ULM Standard Libraries
@subsection ulm-lib-gm2/std/Arguments

@example
DEFINITION MODULE Arguments;	(* mh 5/85 *)
				(* rev mh 6/88 *)
(*
 *	This module reads options and other arguments from the command
 *	line. An argument "-" or "--" stops option reading. "-", how-
 *	ever, will be delivered as argument then, whereas "--" will not.
 *)

(*
 *	Example:
 *
 *	xflag := FALSE;
 *	string := defaultstring;
 *	number := 1;
 *	InitArgs("[-x] [-s string] [-nnn] [file]...");
 *	WHILE GetFlag(flag) DO
 *	   CASE flag OF
 *	      "x":  xflag := TRUE;
 *	   |  "s":  FetchString(string);
 *	   |  "0".."9":
 *	            UngetOpt;
 *	            FetchCard(number);
 *	      ELSE  Usage
 *	   END;
 *	END; (*WHILE GetFlag*)
 *	WHILE GetArg(filename) DO
 *	   IF StrCmp(filename,"-") = 0 THEN
 *	      (* process stdin *)
 *	   ELSE
 *	      (* process filename *)
 *	   END;
 *	END; (*WHILE GetArg*)
 *)

@findex InitArgs
   PROCEDURE InitArgs(is: ARRAY OF CHAR);
	(* specifies infoString and (re)starts the reading cyclus *)

@findex Usage
   PROCEDURE Usage;
	(* prints 'Usage: command infoString' on stderr and aborts
	 * program execution. FetchString, FetchCard and FetchInt call
	 * this procedure automatically in case of errors.
	 *)

@findex GetFlag
   PROCEDURE GetFlag(VAR flag: CHAR): BOOLEAN;
	(* tries to read one flag, i.e. a character within a string containing
	 * a leading '-',from the argument list and returns TRUE if successful.
	 *)

@findex GetOpt
   PROCEDURE GetOpt( VAR flag: CHAR; VAR plus: BOOLEAN): BOOLEAN;
	(* reads one character within a string starting in '+' or '-'.
	 *)

@findex FetchString
   PROCEDURE FetchString(VAR string: ARRAY OF CHAR);
	(* The procedures FetchXXX try to read data of type XXX from
	 * the argument list.
	 *)

@findex FetchCard
   PROCEDURE FetchCard(  VAR number: CARDINAL);
	(* syntax of cardinal arguments:  [+]@{digit@}  *)

@findex FetchInt
   PROCEDURE FetchInt(   VAR number: INTEGER);
	(* syntax of integer arguments:  [+|-]@{digit@}  *)

@findex FetchOct
   PROCEDURE FetchOct(   VAR number: CARDINAL);
	(* syntax of octal arguments:  [+]@{octdigit@}  *)

@findex FetchHex
   PROCEDURE FetchHex(   VAR number: CARDINAL);
	(* syntax of hexadecimal arguments:  [+]@{hexdigit@}  *)

@findex GetArg
   PROCEDURE GetArg(VAR arg: ARRAY OF CHAR): BOOLEAN;
	(* reads one argument or returns FALSE if all are read. *)

@findex UngetArg
   PROCEDURE UngetArg;
	(* pushes the argument that has been read just before
	 * back to the argument list.
	 *)

@findex UngetOpt
   PROCEDURE UngetOpt;
	(* pushes the flag or option that has been read just before
	 * back to the argument list.
	 *)

@findex AllArgs
   PROCEDURE AllArgs;
	(* calls 'Usage' if any arguments are not yet read. *)

END Arguments.
@end example
@page


@node ulm-lib-gm2/std/Calendar, ulm-lib-gm2/std/CallShell, ulm-lib-gm2/std/Arguments, ULM Standard Libraries
@subsection ulm-lib-gm2/std/Calendar

@example
DEFINITION MODULE Calendar;

   FROM SystemTypes IMPORT TIME;

(*
 *	Date calculations with
 *	(a)	Julius Caesar's calendar since Jan 01, 0001
 *	(b)	the Gregorian calendar	 since Oct 15, 1582
 *	(c)	Xelos system time.
 *
 *	Martin Hasch, University of Ulm, Jan 1988
 *)

   TYPE
      Time         = TIME;    			(* consecutive seconds *)
      Date         = LONGCARD;			(* consecutive days *)

      Year         = CARDINAL;
      Month        = [1..12];
      Day          = [1..31];
      Hour         = [0..23];
      Minute       = [0..59];
      Second       = [0..59];
      Weekday      = (Mon, Tue, Wed, Thu, Fri, Sat, Sun);
      Week         = [1..53];
      Yearday      = [1..366];

      Daytime      = RECORD
			hour:    Hour;
			minute:  Minute;
			second:  Second;
		     END;
      Calendarday  = RECORD
			year:    Year;
			month:   Month;
			day:     Day;
		     END;
      CalendarInfo = RECORD
			weekday: Weekday;
			week:	 Week;
			yearday: Yearday;
		     END;

@findex CurrentTime
   PROCEDURE CurrentTime(): Time;
   (*
    *	returns actual system time = seconds since Jan 1, 1970, 00:00:00 GMT
    *)

@findex ConvertTime
   PROCEDURE ConvertTime(time: Time; VAR date: Date; VAR daytime: Daytime);
@findex ConvertDate
   PROCEDURE ConvertDate(date: Date; VAR calendarday: Calendarday);
@findex ConvertCald
   PROCEDURE ConvertCald(calendarday: Calendarday; VAR info: CalendarInfo);

@findex CTime
   PROCEDURE CTime   (date: Date; daytime: Daytime):       Time;
@findex CDate
   PROCEDURE CDate   (year: Year; month: Month; day: Day): Date;
@findex CUltimo
   PROCEDURE CUltimo (year: Year; month: Month):	   Date;
@findex CWeekday
   PROCEDURE CWeekday(date: Date):			   Weekday;

@findex DateOK
   PROCEDURE DateOK(year, month, day: CARDINAL): BOOLEAN;

@findex TimeToString
   PROCEDURE TimeToString(time: Time; VAR string: ARRAY OF CHAR);
   (*
    *	converts time to a string, e.g. "Sun Sep 16 01:03:52 1973 GMT"
    *)

@findex SetFirstOfWeek
   PROCEDURE SetFirstOfWeek(weekday: Weekday);
   (*
    *	important for week of year calculation in ConvertCald; default is Mon.
    *)

@findex GetTimezone
   PROCEDURE GetTimezone (VAR tzName: ARRAY OF CHAR);
@findex SetTimezone
   PROCEDURE SetTimezone (    tzName: ARRAY OF CHAR);
@findex GetLocaltime
   PROCEDURE GetLocaltime(VAR delay: Time);
@findex SetLocaltime
   PROCEDURE SetLocaltime(    delay: Time);
   (*
    *	important for CTime, ConvertTime and TimeToString.
    *)

END Calendar.
@end example
@page


@node ulm-lib-gm2/std/CallShell, ulm-lib-gm2/std/Clock, ulm-lib-gm2/std/Calendar, ULM Standard Libraries
@subsection ulm-lib-gm2/std/CallShell

@example
DEFINITION MODULE CallShell;

   PROCEDURE Shell(cmd: ARRAY OF CHAR; VAR status: CARDINAL) : BOOLEAN;

END CallShell.
@end example
@page


@node ulm-lib-gm2/std/Clock, ulm-lib-gm2/std/Conversions, ulm-lib-gm2/std/CallShell, ULM Standard Libraries
@subsection ulm-lib-gm2/std/Clock

@example
DEFINITION MODULE Clock;

   FROM SystemTypes IMPORT TIME;

   CONST UnitsPerSecond = 100;

@findex RealTime
   PROCEDURE RealTime(reset: BOOLEAN): TIME;
@findex CPUTime
   PROCEDURE CPUTime (reset: BOOLEAN): TIME;
   (*
    *	These functions return the time in units elapsed since the start
    *	of the current process or since the last call with argument TRUE.
    *)

END Clock.
@end example
@page


@node ulm-lib-gm2/std/Conversions, ulm-lib-gm2/std/Directories, ulm-lib-gm2/std/Clock, ULM Standard Libraries
@subsection ulm-lib-gm2/std/Conversions

@example
DEFINITION MODULE Conversions;                  (* LG *)

  PROCEDURE ConvertOctal(num, len: CARDINAL; VAR str: ARRAY OF CHAR);
    (* conversion of an octal number to a string *)

@findex ConvertHex
  PROCEDURE ConvertHex(num, len: CARDINAL; VAR str: ARRAY OF CHAR);
    (* conversion of a hexadecimal number to a string *)

@findex ConvertCardinal
  PROCEDURE ConvertCardinal(num, len: CARDINAL; VAR str: ARRAY OF CHAR);
    (* conversion of a cardinal decimal number to a string *)

@findex ConvertInteger
  PROCEDURE ConvertInteger(num: INTEGER; len: CARDINAL;
                           VAR str: ARRAY OF CHAR);
    (* conversion of an integer decimal number to a string *)

END Conversions.
@end example
@page


@node ulm-lib-gm2/std/Directories, ulm-lib-gm2/std/Environment, ulm-lib-gm2/std/Conversions, ULM Standard Libraries
@subsection ulm-lib-gm2/std/Directories

@example
DEFINITION MODULE Directories;

   FROM SystemTypes IMPORT DirSize, OFF;

   TYPE
      DIR;

      FileName = ARRAY [0..DirSize-1] OF CHAR;
      Direct =
         RECORD
            ino: CARDINAL;
            name: FileName;
         END;

@findex OpenDir
   PROCEDURE OpenDir(VAR dirp: DIR; filename: ARRAY OF CHAR) : BOOLEAN;

@findex ReadDir
   PROCEDURE ReadDir(dirp: DIR; VAR direct: Direct) : BOOLEAN;

@findex TellDir
   PROCEDURE TellDir(dirp: DIR; VAR offset: OFF) : BOOLEAN;

@findex SeekDir
   PROCEDURE SeekDir(dirp: DIR; pos: OFF) : BOOLEAN;

@findex RewindDir
   PROCEDURE RewindDir(dirp: DIR) : BOOLEAN;

@findex CloseDir
   PROCEDURE CloseDir(VAR dirp: DIR);

END Directories.
@end example
@page


@node ulm-lib-gm2/std/Environment, ulm-lib-gm2/std/EtcGroup, ulm-lib-gm2/std/Directories, ULM Standard Libraries
@subsection ulm-lib-gm2/std/Environment

@example
DEFINITION MODULE Environment;

   PROCEDURE GetEnv(name: ARRAY OF CHAR; (* parameter name to be looked for *)
		    VAR text: ARRAY OF CHAR; (* parameter contents *)
		    VAR ok: BOOLEAN);

@findex EnvPar
   PROCEDURE EnvPar(index: CARDINAL; (* ranging [0.. #parameters-1] *)
		    VAR text: ARRAY OF CHAR; (* "name=contents" *)
		    VAR ok: BOOLEAN);

END Environment.
@end example
@page


@node ulm-lib-gm2/std/EtcGroup, ulm-lib-gm2/std/Files, ulm-lib-gm2/std/Environment, ULM Standard Libraries
@subsection ulm-lib-gm2/std/EtcGroup

@example
DEFINITION MODULE EtcGroup;
(*
 *	scanning and searching the etc/group file
 *
 *	Martin Hasch, University of Ulm, Dec-06-1988
 *)

   TYPE
      MemberList = POINTER TO Member;
      Member =
	 RECORD
	    logname:  ARRAY [0..7] OF CHAR;
	    nextmem:  MemberList;
	 END;

      Grent =
	 RECORD
	    grname:   ARRAY [0..7] OF CHAR;
	    password: ARRAY [0..15] OF CHAR;
	    gid:      CARDINAL;
	    members:  MemberList;		(* NIL-terminated *)
	 END;

@findex OpenGr
   PROCEDURE OpenGr(filename: ARRAY OF CHAR): BOOLEAN;
   (* returns TRUE on success *)

@findex GetGrent
   PROCEDURE GetGrent(VAR grent: Grent): BOOLEAN;

@findex GetGrgid
   PROCEDURE GetGrgid(gid: CARDINAL; VAR grent: Grent): BOOLEAN;

@findex GetGrnam
   PROCEDURE GetGrnam(grn: ARRAY OF CHAR; VAR grent: Grent): BOOLEAN;

@findex ReopenGr
   PROCEDURE ReopenGr(): BOOLEAN;
   (* returns TRUE if group file is open and seekable *)

@findex CloseGr
   PROCEDURE CloseGr(): BOOLEAN;
   (* returns TRUE if group file was open *)


@findex FetchGrgid
   PROCEDURE FetchGrgid(gid: CARDINAL; VAR grent: Grent): BOOLEAN;
   (* implies OpenGr("/etc/group"), and CloseGr() *)

@findex FetchGrnam
   PROCEDURE FetchGrnam(grn: ARRAY OF CHAR; VAR grent: Grent): BOOLEAN;
   (* implies OpenGr("/etc/group"), and CloseGr() *)

END EtcGroup.
@end example
@page


@node ulm-lib-gm2/std/Files, ulm-lib-gm2/std/FtdIO, ulm-lib-gm2/std/EtcGroup, ULM Standard Libraries
@subsection ulm-lib-gm2/std/Files

@example
DEFINITION MODULE Files;

   FROM SystemTypes IMPORT OFF;

   (* high level module for file handling *)

   IMPORT StdIO;

   TYPE
      FILE = StdIO.FILE;

   VAR Done: BOOLEAN;

@findex OpenRead
   PROCEDURE OpenRead(VAR f: FILE; filename: ARRAY OF CHAR);

@findex OpenWrite
   PROCEDURE OpenWrite(VAR f: FILE; filename: ARRAY OF CHAR);

@findex Close
   PROCEDURE Close(f: FILE);

@findex SetPos
   PROCEDURE SetPos(f: FILE; pos: OFF);

@findex GetPos
   PROCEDURE GetPos(f: FILE; VAR pos: OFF);

@findex Reset
   PROCEDURE Reset(f: FILE);

@findex Delete
   PROCEDURE Delete(filename: ARRAY OF CHAR);

@findex Rename
   PROCEDURE Rename(oldname, newname: ARRAY OF CHAR);

END Files.
@end example
@page


@node ulm-lib-gm2/std/FtdIO, ulm-lib-gm2/std/Functions, ulm-lib-gm2/std/Files, ULM Standard Libraries
@subsection ulm-lib-gm2/std/FtdIO

@example
DEFINITION MODULE FtdIO;

   FROM SYSTEM IMPORT WORD;
   FROM StdIO IMPORT FILE;

   VAR Done: BOOLEAN;
       termCH: CHAR;

@findex FreadInt
   PROCEDURE FreadInt(f: FILE; VAR arg: INTEGER);

@findex FwriteInt
   PROCEDURE FwriteInt(f: FILE; arg: INTEGER; w: CARDINAL);

@findex FreadCard
   PROCEDURE FreadCard(f: FILE; VAR arg: CARDINAL);

@findex FwriteCard
   PROCEDURE FwriteCard(f: FILE; arg: CARDINAL; w: CARDINAL);

@findex FreadString
   PROCEDURE FreadString(f: FILE; VAR str: ARRAY OF CHAR);

@findex FwriteString
   PROCEDURE FwriteString(f: FILE; str: ARRAY OF CHAR);

@findex FwriteLn
   PROCEDURE FwriteLn(f: FILE);

@findex Fread
   PROCEDURE Fread(f: FILE; VAR arr: ARRAY OF WORD);

@findex Fwrite
   PROCEDURE Fwrite(f: FILE; arr: ARRAY OF WORD);

@findex FreadWord
   PROCEDURE FreadWord(f: FILE; VAR w: WORD);

@findex FwriteWord
   PROCEDURE FwriteWord(f: FILE; w: WORD);

@findex FreadChar
   PROCEDURE FreadChar(f: FILE; VAR ch: CHAR);

@findex FwriteChar
   PROCEDURE FwriteChar(f: FILE; ch: CHAR);

END FtdIO.
@end example
@page


@node ulm-lib-gm2/std/Functions, ulm-lib-gm2/std/GetPass, ulm-lib-gm2/std/FtdIO, ULM Standard Libraries
@subsection ulm-lib-gm2/std/Functions

@example
DEFINITION MODULE Functions; (* AFB 12/88 *)

(*
   (C) Andreas Borchert, Universitaet Ulm, 1988

   The expression grammar is Modula-2 oriented with following exceptions:

   (1)	The ?: operator has been added (semantic close to C).
	?: has lowest priority and right-to-left associativity
   (2)	Integer constants are real constants, too.
   (3)  Operator-keywords are not supported, so use
	   &  instead of AND,
	   |  instead of OR, and
	   ~  instead of NOT.
   (4)	TRUE is represented as 1.0 and FALSE as 0.0
	Anything but 0.0 is taken to be TRUE (in conditions).

   The grammar (in EBNF):

      CondExpression = Expression [ "?" CondExpression ":" CondExpression ] .
      Expression = SimpleExpression [ RelOp SimpleExpression ] .
      SimpleExpression = ["+"|"-"] Term @{ AddOp Term @} .
      Term = Factor @{ MulOp Factor @} .
      Factor = Constant | IDENT | FunctionCall | "~" Factor |
	       "(" CondExpression ")" .
      FunctionCall = IDENT "(" CondExpression [ "," CondExpression ] ")" .
      RelOp = "=" | "#" | "<" | ">" | "<=" | ">=" .
      AddOp = "+" | "-" | "|" .
      MulOp = "*" | "/" | "&" .

   The start symbol is CondExpression.
   Identifiers are sequences of letters and digits. The first character
   must be a letter.
   Syntax of constants:

      Digit @{ Digit @} [ "." @{ Digit @} ] [ ("E"|"e") Digit @{ Digit @} ]

   On errors `ParseFunction' returns FALSE after `errpos' has been set
   to the error position.
   Errors can result from

      (1) Syntax errors.
      (2) Bad constants, e.g. exponent is too large
      (3) Bad number of arguments to a function

   Each identifier not declared as a constant or a function is
   considered to be a parameter. The value of a parameter is
   predefined to 0.0. `FirstParam' and `NextParam' give the parameter names
   in alphabetical order. Parameter values can be changed using
   `SetFuncParam'. `EvalFunction' evaluates the function with the
   parameters set previously.

   Example:

      WriteString("func: "); ReadString(functxt);
      IF ParseFunction(func, functxt) THEN
	 FirstParam;
	 WHILE NextParam(func, parname) DO
	    WriteString(parname); WriteString(" = ");
	    ReadReal(val);
	    SetFuncParam(func, parname, val);
	 END;
	 WriteReal(EvalFunction(func), 1); WriteLn;
      ELSE
	 (* error at errpos *)
      END;

   Warning:

   EvalFunction does not check for division by zero or any other
   operations which can result in a floating point exception.

   Hint:

   Import `StdFuncs' for having a standard set of functions and
   constants.

*)

   TYPE
      Function;
      Real = REAL;
      StdFunc1 = PROCEDURE (Real) : Real;
      StdFunc2 = PROCEDURE (Real, Real) : Real;

   VAR
      errpos: CARDINAL; (* error position in expr of ParseFunction *)

@findex InstallStdFunc1
   PROCEDURE InstallStdFunc1(funcname: ARRAY OF CHAR; stdfunc: StdFunc1);

@findex InstallStdFunc2
   PROCEDURE InstallStdFunc2(funcname: ARRAY OF CHAR; stdfunc: StdFunc2);

@findex InstallStdConst
   PROCEDURE InstallStdConst(constname: ARRAY OF CHAR; val: Real);

@findex ParseFunction
   PROCEDURE ParseFunction(expr: ARRAY OF CHAR; VAR func: Function) : BOOLEAN;

@findex FirstParam
   PROCEDURE FirstParam(func: Function);

@findex NextParam
   PROCEDURE NextParam(func: Function; VAR symname: ARRAY OF CHAR) : BOOLEAN;

@findex SetFuncParam
   PROCEDURE SetFuncParam(func: Function; parname: ARRAY OF CHAR;
			  value: Real);

@findex EvalFunction
   PROCEDURE EvalFunction(func: Function) : Real;

@findex DisposeFunction
   PROCEDURE DisposeFunction(VAR func: Function);
      (* release storage associated with `func' *)

END Functions.
@end example
@page


@node ulm-lib-gm2/std/GetPass, ulm-lib-gm2/std/InOut, ulm-lib-gm2/std/Functions, ULM Standard Libraries
@subsection ulm-lib-gm2/std/GetPass

@example
DEFINITION MODULE GetPass;

   PROCEDURE GetPass(prompt: ARRAY OF CHAR;
                     VAR passwd: ARRAY OF CHAR);

END GetPass.
@end example
@page


@node ulm-lib-gm2/std/InOut, ulm-lib-gm2/std/MathLib, ulm-lib-gm2/std/GetPass, ULM Standard Libraries
@subsection ulm-lib-gm2/std/InOut

@example
DEFINITION MODULE InOut; (* stripped version: AFB 4/84 *)

   CONST
      EOL = 12C;
   VAR
      Done: BOOLEAN; (* on eof true *)
      termCH: CHAR; (* set in ReadString and numeric input procs *)

@findex Read
   PROCEDURE Read(VAR ch: CHAR);

@findex ReadString
   PROCEDURE ReadString(VAR str: ARRAY OF CHAR);

@findex ReadCard
   PROCEDURE ReadCard(VAR arg: CARDINAL);

@findex ReadInt
   PROCEDURE ReadInt(VAR arg: INTEGER);

@findex Write
   PROCEDURE Write(ch: CHAR);

@findex WriteLn
   PROCEDURE WriteLn;

@findex WriteString
   PROCEDURE WriteString(s: ARRAY OF CHAR);

   (* n: minimum field width *)

@findex WriteInt
   PROCEDURE WriteInt(x: INTEGER; n: CARDINAL);

@findex WriteCard
   PROCEDURE WriteCard(x: CARDINAL; n: CARDINAL);

@findex WriteOct
   PROCEDURE WriteOct(x: CARDINAL; n: CARDINAL);

@findex WriteHex
   PROCEDURE WriteHex(x: CARDINAL; n: CARDINAL);

END InOut.
@end example
@page


@node ulm-lib-gm2/std/MathLib, ulm-lib-gm2/std/Passwd, ulm-lib-gm2/std/InOut, ULM Standard Libraries
@subsection ulm-lib-gm2/std/MathLib

@example
DEFINITION MODULE MathLib;

   PROCEDURE arctan(x: REAL) : REAL;

@findex exp
   PROCEDURE exp(x: REAL) : REAL;

@findex ln
   PROCEDURE ln(x: REAL) : REAL;

@findex sin
   PROCEDURE sin(x: REAL) : REAL;

@findex cos
   PROCEDURE cos(x: REAL) : REAL;

@findex sqrt
   PROCEDURE sqrt(x: REAL) : REAL;

END MathLib.
@end example
@page


@node ulm-lib-gm2/std/Passwd, ulm-lib-gm2/std/PipeIO, ulm-lib-gm2/std/MathLib, ULM Standard Libraries
@subsection ulm-lib-gm2/std/Passwd

@example
DEFINITION MODULE Passwd;
(*
 *	scanning and searching the passord file
 *
 *	Martin Hasch, University of Ulm, Nov-29-1988
 *)

   TYPE
      Pwent =
	 RECORD
	    logname:  ARRAY [0..7] OF CHAR;
	    password: ARRAY [0..15] OF CHAR;
	    uid:      CARDINAL;
	    gid:      CARDINAL;
	    fullname: ARRAY [0..31] OF CHAR;
	    dir:      ARRAY [0..31] OF CHAR;
	    shell:    ARRAY [0..31] OF CHAR;
	 END;

@findex OpenPw
   PROCEDURE OpenPw(filename: ARRAY OF CHAR): BOOLEAN;
   (* returns TRUE on success *)

@findex GetPwent
   PROCEDURE GetPwent(VAR pwent: Pwent): BOOLEAN;

@findex GetPwuid
   PROCEDURE GetPwuid(uid: CARDINAL; VAR pwent: Pwent): BOOLEAN;

@findex GetPwnam
   PROCEDURE GetPwnam(logn: ARRAY OF CHAR; VAR pwent: Pwent): BOOLEAN;

@findex ReopenPw
   PROCEDURE ReopenPw(): BOOLEAN;
   (* returns TRUE if passwd file is open and seekable *)

@findex ClosePw
   PROCEDURE ClosePw(): BOOLEAN;
   (* returns TRUE if passwd file was open *)


@findex FetchPwuid
   PROCEDURE FetchPwuid(uid: CARDINAL; VAR pwent: Pwent): BOOLEAN;
   (* implies OpenPw("/etc/passwd"), and ClosePw() *)

@findex FetchPwnam
   PROCEDURE FetchPwnam(logn: ARRAY OF CHAR; VAR pwent: Pwent): BOOLEAN;
   (* implies OpenPw("/etc/passwd"), and ClosePw() *)

END Passwd.
@end example
@page


@node ulm-lib-gm2/std/PipeIO, ulm-lib-gm2/std/Plot, ulm-lib-gm2/std/Passwd, ULM Standard Libraries
@subsection ulm-lib-gm2/std/PipeIO

@example
DEFINITION MODULE PipeIO;

   FROM StdIO IMPORT FILE, MODE;

@findex Popen
   PROCEDURE Popen(VAR f: FILE; cmd: ARRAY OF CHAR; mode: MODE;
                   buffered: BOOLEAN) : BOOLEAN;

@findex Pclose
   PROCEDURE Pclose(f: FILE) : BOOLEAN;

END PipeIO.
@end example
@page


@node ulm-lib-gm2/std/Plot, ulm-lib-gm2/std/RTErrors, ulm-lib-gm2/std/PipeIO, ULM Standard Libraries
@subsection ulm-lib-gm2/std/Plot

@example
DEFINITION MODULE Plot;

   FROM StdIO IMPORT FILE;

   (* device independent plotter interface; see plot(3) and plot(5) *)

@findex OpenPlot
   PROCEDURE OpenPlot(f: FILE);

@findex ClosePlot
   PROCEDURE ClosePlot;

@findex Move
   PROCEDURE Move(xto, yto: INTEGER);

@findex Cont
   PROCEDURE Cont(xto, yto: INTEGER);

@findex Point
   PROCEDURE Point(xpoint, ypoint: INTEGER);

@findex Line
   PROCEDURE Line(xfrom, yfrom, xto, yto: INTEGER);

@findex String
   PROCEDURE String(str: ARRAY OF CHAR);

@findex Arc
   PROCEDURE Arc(xcenter, ycenter, xstart, ystart, xend, yend: INTEGER);

@findex Circle
   PROCEDURE Circle(xcenter, ycenter, radius: INTEGER);

@findex Erase
   PROCEDURE Erase;

@findex LineMod
   PROCEDURE LineMod(style: ARRAY OF CHAR);

@findex Space
   PROCEDURE Space(xupleft, yupleft, xlowright, ylowright: INTEGER);

@findex Reverse
   PROCEDURE Reverse(xupleft, yupleft, xlowright, ylowright: INTEGER);

@findex Polygon
   PROCEDURE Polygon(xcenter, ycenter, xstart, ystart, edges: INTEGER);

@findex CharMod
   PROCEDURE CharMod(plotchar: CHAR);

END Plot.
@end example
@page


@node ulm-lib-gm2/std/RTErrors, ulm-lib-gm2/std/RandomGenerator, ulm-lib-gm2/std/Plot, ULM Standard Libraries
@subsection ulm-lib-gm2/std/RTErrors

@example
DEFINITION MODULE RTErrors;

   FROM SYSTEM IMPORT ADDRESS;

   TYPE
      Kind = (noError, halt, case, stack, crend, prio, fret, range);
      RangeCheck = (none, unsigned, signed, sign, dyn);

      Error = POINTER TO ErrorRec;
      ErrorRec =
	 RECORD
	    kind: Kind;
	    module: ADDRESS; (* points to name of module *)
	    line: CARDINAL; (* line number in source *)
	    pc: ADDRESS; (* program counter *)
	    CASE (* kind *) : Kind OF
	    | range: CASE rtype: RangeCheck OF
		     | unsigned, dyn:
			   value, min, max: CARDINAL;
		     | signed:
			   ivalue, imin, imax: INTEGER;
		     END;
	    END;
	 END;

      Handler = PROCEDURE (Error);

@findex Notify
   PROCEDURE Notify(error: Error);
      (* called by runtime system *)

@findex SetHandler
   PROCEDURE SetHandler(newHandler: Handler);
      (* define alternative handler of runtime errors *)

END RTErrors.
@end example
@page


@node ulm-lib-gm2/std/RandomGenerator, ulm-lib-gm2/std/ReadIntCard, ulm-lib-gm2/std/RTErrors, ULM Standard Libraries
@subsection ulm-lib-gm2/std/RandomGenerator

@example
DEFINITION MODULE RandomGenerator;

   (*    Anyone who considers arithmetical
	methods of producing random digits
	 is, of course, in a state of sin.
		 - John von Neumann (1951)
   *)

@findex IntVal
   PROCEDURE IntVal() : INTEGER;
      (* get random 32-bit value *)

@findex RealVal
   PROCEDURE RealVal() : REAL;
      (* get a uniformly distributed real value in [0..1) *)

@findex Random
   PROCEDURE Random(low, high: INTEGER) : INTEGER;
      (* get a uniformly distributed integer in [low..high] *)

@findex Flip
   PROCEDURE Flip() : BOOLEAN;
      (* return TRUE or FALSE *)

@findex Init
   PROCEDURE Init(seed: INTEGER);

END RandomGenerator.
@end example
@page


@node ulm-lib-gm2/std/ReadIntCard, ulm-lib-gm2/std/RealConv, ulm-lib-gm2/std/RandomGenerator, ULM Standard Libraries
@subsection ulm-lib-gm2/std/ReadIntCard

@example
DEFINITION MODULE ReadIntCard;

   FROM SYSTEM IMPORT WORD;

   TYPE
      Type = (int, card);
      ReadProc = PROCEDURE(VAR CHAR);

   VAR Done: BOOLEAN;

   (* convention: ReadChar returns 0C on eof or error *)

@findex Read
   PROCEDURE Read(VAR w: WORD; t: Type; ReadChar: ReadProc);

END ReadIntCard.
@end example
@page


@node ulm-lib-gm2/std/RealConv, ulm-lib-gm2/std/RealInOut, ulm-lib-gm2/std/ReadIntCard, ULM Standard Libraries
@subsection ulm-lib-gm2/std/RealConv

@example
DEFINITION MODULE RealConv; (* AFB 6/84 * rev. wsc 2/85 *)

   TYPE
      ReadProc = PROCEDURE(VAR CHAR);
   VAR
      Done: BOOLEAN;
      termCH: CHAR;

@findex ReadReal
   PROCEDURE ReadReal(Read: ReadProc; VAR x: REAL);
   (* convention: Read returns 0C on eof or error *)

@findex WriteFloat
   PROCEDURE WriteFloat(VAR field: ARRAY OF CHAR; x: REAL; cbase: CARDINAL;
                        dp: CARDINAL);
@findex WriteFix
   PROCEDURE WriteFix(VAR field: ARRAY OF CHAR; x: REAL; cbase: CARDINAL;
                      VAR dp: CARDINAL);

END RealConv.
@end example
@page


@node ulm-lib-gm2/std/RealInOut, ulm-lib-gm2/std/ScanPwfile, ulm-lib-gm2/std/RealConv, ULM Standard Libraries
@subsection ulm-lib-gm2/std/RealInOut

@example
DEFINITION MODULE RealInOut; (* AFB 6/84 * rev. wsc 2/85 *)

   FROM StdIO IMPORT FILE;

   VAR
      Done: BOOLEAN;

   (*
    *	Read REAL number x according to syntax:
    *
    *	["+" | "-"] digit @{ digit @} ["." digit @{ digit @} ]
    *	["E" ["+" | "-"] digit [digit] ]
    *
    *	Done := "a number was read".
    *
    *	at most 16 digits are significant, leading zeroes not
    *	counting. Maximum exponent is 76. Input terminates
    *	with a blank or any control character.
    *)

@findex ReadReal
   PROCEDURE ReadReal(VAR x: REAL);

@findex FreadReal
   PROCEDURE FreadReal(f: FILE; VAR x: REAL);

   (*
    *	Write x using n characters. If fewer than n characters
    *	are needed, leading blanks are inserted.
    *)

@findex WriteReal
   PROCEDURE WriteReal(x: REAL; n: CARDINAL);

@findex FwriteReal
   PROCEDURE FwriteReal(f: FILE; x: REAL; n: CARDINAL);

   (*
    *	Write x in fixed point notation using pd digits in front
    *	of decimal point and dp digits behind decial point. If
    *	fewer than pd digits are needed, leading blanks are
    *	inserted.
    *)

@findex WriteFloat
   PROCEDURE WriteFloat(x: REAL; pd: CARDINAL; dp: CARDINAL);

@findex FwriteFloat
   PROCEDURE FwriteFloat(f: FILE; x: REAL; pd: CARDINAL; dp: CARDINAL);

   (*
    *	Write x in octal/hexadecimal form with exponent and mantissa
    *)

@findex WriteRealOct
   PROCEDURE WriteRealOct(x: REAL);

@findex FwriteRealOct
   PROCEDURE FwriteRealOct(f: FILE; x: REAL);

@findex WriteRealHex
   PROCEDURE WriteRealHex(x: REAL);

@findex FwriteRealHex
   PROCEDURE FwriteRealHex(f: FILE; x: REAL);

END RealInOut.
@end example
@page


@node ulm-lib-gm2/std/ScanPwfile, ulm-lib-gm2/std/StdFuncs, ulm-lib-gm2/std/RealInOut, ULM Standard Libraries
@subsection ulm-lib-gm2/std/ScanPwfile

@example
DEFINITION MODULE ScanPwfile;
(*
 *	utility functions for modules Passwd and EtcGroup
 *
 *	Martin Hasch, University of Ulm, Dec-06-1988
 *)

   FROM StdIO IMPORT FILE;
   FROM ASCII IMPORT nl;

   CONST
      fieldsep = ":";
      linesep = nl;

@findex ReRead
   PROCEDURE ReRead(pwfile: FILE): BOOLEAN;

@findex GetText
   PROCEDURE GetText(pwfile: FILE; VAR text: ARRAY OF CHAR; sepchar: CHAR): BOOLEAN;

@findex GetNumber
   PROCEDURE GetNumber(pwfile: FILE; VAR number: CARDINAL; sepchar: CHAR): BOOLEAN;

END ScanPwfile.
@end example
@page


@node ulm-lib-gm2/std/StdFuncs, ulm-lib-gm2/std/StdIO, ulm-lib-gm2/std/ScanPwfile, ULM Standard Libraries
@subsection ulm-lib-gm2/std/StdFuncs

@example
DEFINITION MODULE StdFuncs;

END StdFuncs.
@end example
@page


@node ulm-lib-gm2/std/StdIO, ulm-lib-gm2/std/Storage, ulm-lib-gm2/std/StdFuncs, ULM Standard Libraries
@subsection ulm-lib-gm2/std/StdIO

@example
DEFINITION MODULE StdIO; (* AFB 1/84 *)

   FROM SYSTEM IMPORT ADDRESS;
   FROM SystemTypes IMPORT OFF;

   TYPE
      FILE; (* hidden *)
      MODE = (read, write, append);

   VAR
      stdin, stdout, stderr: FILE;

   (* all functions return FALSE in error case *)

@findex Fopen
   PROCEDURE Fopen(VAR f: FILE; name: ARRAY OF CHAR; mode: MODE;
		   buffered: BOOLEAN) : BOOLEAN;

@findex Fclose
   PROCEDURE Fclose(f: FILE) : BOOLEAN;

@findex Fread
   PROCEDURE Fread(ptr: ADDRESS; size: CARDINAL; VAR nitems: CARDINAL;
		   f: FILE) : BOOLEAN;

@findex Fwrite
   PROCEDURE Fwrite(ptr: ADDRESS; size: CARDINAL; VAR nitems: CARDINAL;
		    f: FILE) : BOOLEAN;

@findex Fseek
   PROCEDURE Fseek(f: FILE; offset: OFF; whence: CARDINAL) : BOOLEAN;

@findex Ftell
   PROCEDURE Ftell(f: FILE; VAR pos: OFF) : BOOLEAN;

@findex Feof
   PROCEDURE Feof(f: FILE) : BOOLEAN;

@findex Ferror
   PROCEDURE Ferror(f: FILE) : BOOLEAN;

@findex Fgetc
   PROCEDURE Fgetc(VAR ch: CHAR; f: FILE) : BOOLEAN;

@findex Fputc
   PROCEDURE Fputc(ch: CHAR; f: FILE) : BOOLEAN;

@findex Fungetc
   PROCEDURE Fungetc(ch: CHAR; f: FILE) : BOOLEAN;

@findex CloseAll
   PROCEDURE CloseAll() : BOOLEAN;

@findex Fflush
   PROCEDURE Fflush(f: FILE) : BOOLEAN;

@findex Fdopen
   PROCEDURE Fdopen(VAR f: FILE; filedesc: CARDINAL; mode: MODE;
                    buffered: BOOLEAN) : BOOLEAN;

@findex FileNo
   PROCEDURE FileNo(f: FILE) : CARDINAL;

END StdIO.
@end example
@page


@node ulm-lib-gm2/std/Storage, ulm-lib-gm2/std/StrSpec, ulm-lib-gm2/std/StdIO, ULM Standard Libraries
@subsection ulm-lib-gm2/std/Storage

@example
DEFINITION MODULE Storage;              (* A. Borchert *)

   FROM SYSTEM IMPORT ADDRESS;

@findex ALLOCATE
   PROCEDURE ALLOCATE(VAR ptr:ADDRESS; size: CARDINAL);

@findex DEALLOCATE
   PROCEDURE DEALLOCATE(VAR ptr:ADDRESS; size: CARDINAL);

@findex Setmode
   PROCEDURE Setmode(m: CARDINAL);

END Storage.
@end example
@page


@node ulm-lib-gm2/std/StrSpec, ulm-lib-gm2/std/StrToNum, ulm-lib-gm2/std/Storage, ULM Standard Libraries
@subsection ulm-lib-gm2/std/StrSpec

@example
DEFINITION MODULE StrSpec;		(* gsk 1/85 *)

   PROCEDURE StrPartCpy ( VAR target           : ARRAY OF CHAR;
			      source           : ARRAY OF CHAR;
			      position, number : CARDINAL );

@findex StrDel
   PROCEDURE StrDel ( VAR target           : ARRAY OF CHAR ;
			  position, number : CARDINAL );

@findex StrIns
   PROCEDURE StrIns ( VAR target      : ARRAY OF CHAR;
			  insertion   : ARRAY OF CHAR;
			  position    : CARDINAL );

@findex StrPos
   PROCEDURE StrPos ( source, search : ARRAY OF CHAR ) : CARDINAL;

END StrSpec.
@end example
@page


@node ulm-lib-gm2/std/StrToNum, ulm-lib-gm2/std/StrToReal, ulm-lib-gm2/std/StrSpec, ULM Standard Libraries
@subsection ulm-lib-gm2/std/StrToNum

@example
DEFINITION MODULE StrToNum; (* mh 5/85; rev afb 4/86: StrToOct/StrToHex *)

   PROCEDURE StrToCard(str: ARRAY OF CHAR; VAR card: CARDINAL): BOOLEAN;
	(* converts str to the CARDINAL card. Leading spaces, tabs and new-
	 * lines are ignored. Returns FALSE if str is not of the syntax:
	 *   [+] @{digit@} , or if the resulting number exceeds CARDINAL range.
	 *)

@findex StrToInt
   PROCEDURE StrToInt(str: ARRAY OF CHAR; VAR integ: INTEGER): BOOLEAN;
	(* converts str to the INTEGER integ in analogue manner.
	 * Required syntax of str here:  [+|-] @{digit@} .
	 *)

@findex StrToOct
   PROCEDURE StrToOct(str: ARRAY OF CHAR; VAR card: CARDINAL) : BOOLEAN;

@findex StrToHex
   PROCEDURE StrToHex(str: ARRAY OF CHAR; VAR card: CARDINAL) : BOOLEAN;

END StrToNum.
@end example
@page


@node ulm-lib-gm2/std/StrToReal, ulm-lib-gm2/std/Strings, ulm-lib-gm2/std/StrToNum, ULM Standard Libraries
@subsection ulm-lib-gm2/std/StrToReal

@example
DEFINITION MODULE StrToReal;

   PROCEDURE StrToReal(str: ARRAY OF CHAR; VAR real: REAL) : BOOLEAN;
      (* converts str to the REAL real, leading white space is
	 ignored, returns FALSE if str does not conform to following
	 syntax:
	    ["+" | "-"] digit @{ digit @} ["." digit @{ digit @} ]
	    ["E" ["+" | "-"] digit [digit] ]
      *)

END StrToReal.
@end example
@page


@node ulm-lib-gm2/std/Strings, ulm-lib-gm2/std/SysConf, ulm-lib-gm2/std/StrToReal, ULM Standard Libraries
@subsection ulm-lib-gm2/std/Strings

@example
DEFINITION MODULE Strings; (* AFB 7/84 *)

   PROCEDURE StrLen(s: ARRAY OF CHAR) : CARDINAL;

@findex StrCat
   PROCEDURE StrCat(VAR s: ARRAY OF CHAR; s1: ARRAY OF CHAR);

@findex StrCmp
   PROCEDURE StrCmp(s1, s2: ARRAY OF CHAR) : INTEGER;

@findex StrCpy
   PROCEDURE StrCpy(VAR s: ARRAY OF CHAR; s1: ARRAY OF CHAR);

END Strings.
@end example
@page


@node ulm-lib-gm2/std/SysConf, ulm-lib-gm2/std/SysPerror, ulm-lib-gm2/std/Strings, ULM Standard Libraries
@subsection ulm-lib-gm2/std/SysConf

@example
DEFINITION MODULE SysConf; (* AFB 2/97 *)

   (* configuration parameters of the installation *)

@findex GetLibDir
   PROCEDURE GetLibDir(VAR libdirBuf: ARRAY OF CHAR);
      (* GetLibDir returns the directory where the Modula-2 library
         has been installed to; it does not honour the MODLIB
	 environment variable
      *)

@findex GetRelease
   PROCEDURE GetRelease(VAR releaseBuf: ARRAY OF CHAR);
      (* returns the release of the Modula-2 installation *)

END SysConf.
@end example
@page


@node ulm-lib-gm2/std/SysPerror, ulm-lib-gm2/std/Terminal, ulm-lib-gm2/std/SysConf, ULM Standard Libraries
@subsection ulm-lib-gm2/std/SysPerror

@example
DEFINITION MODULE SysPerror; (* AFB 2/84 *)

   PROCEDURE Perror(str: ARRAY OF CHAR);

@findex GetErrorString
   PROCEDURE GetErrorString(errno: CARDINAL; VAR str: ARRAY OF CHAR);

END SysPerror.
@end example
@page


@node ulm-lib-gm2/std/Terminal, ulm-lib-gm2/std/TimeIO, ulm-lib-gm2/std/SysPerror, ULM Standard Libraries
@subsection ulm-lib-gm2/std/Terminal

@example
DEFINITION MODULE Terminal; (* A. Borchert *)

   (* read and write from/to standard input/output channel *)

   VAR Done: BOOLEAN;

@findex Read
   PROCEDURE Read(VAR ch: CHAR);

@findex ReadAgain
   PROCEDURE ReadAgain;

@findex Write
   PROCEDURE Write(ch: CHAR);

@findex WriteLn
   PROCEDURE WriteLn;

@findex WriteString
   PROCEDURE WriteString(s: ARRAY OF CHAR);

END Terminal.
@end example
@page


@node ulm-lib-gm2/std/TimeIO, , ulm-lib-gm2/std/Terminal, ULM Standard Libraries
@subsection ulm-lib-gm2/std/TimeIO

@example
DEFINITION MODULE TimeIO; (* AFB 9/88 *)

   FROM Calendar IMPORT Time, Date;
   FROM StdIO IMPORT FILE;

   TYPE
      Style = (date,	(* date(1) and ctime(3) standard format *)
	       ls,	(* like the ls-command *)
	       env);	(* see for TIMEFMT in environment *)
   VAR
      Done: BOOLEAN;
      termCH: CHAR;

@findex WriteTime
   PROCEDURE WriteTime(format: ARRAY OF CHAR; time: Time);
      (* the output format is very close to date(1): *)
      (* each field descriptor is preceded by % and will be *)
      (* replaced in the output by its corresponding value. *)
      (* WriteTime does not append a newline automatically  *)
      (* like date(1).                                      *)
      (* output is directed to StdIO.stdout                 *)

@findex FwriteTime
   PROCEDURE FwriteTime(file: FILE; format: ARRAY OF CHAR; time: Time);
      (* like WriteTime but output is directed to file      *)

@findex SwriteTime
   PROCEDURE SwriteTime(VAR string: ARRAY OF CHAR;
			format: ARRAY OF CHAR;
			time: Time);
      (* like WriteTime but output is put into string       *)

@findex WriteTimeLike
   PROCEDURE WriteTimeLike(style: Style; time: Time);
      (* write time to StdIO.stdout according to the given  *)
      (* style.                                             *)

@findex FwriteTimeLike
   PROCEDURE FwriteTimeLike(file: FILE; style: Style; time: Time);

@findex SwriteTimeLike
   PROCEDURE SwriteTimeLike(VAR string: ARRAY OF CHAR;
			    style: Style; time: Time);

@findex ReadTime
   PROCEDURE ReadTime(VAR time: Time);
      (* read time from StdIO.stdin *)

@findex FreadTime
   PROCEDURE FreadTime(file: FILE; VAR time: Time);

@findex SreadTime
   PROCEDURE SreadTime(string: ARRAY OF CHAR; VAR time: Time);

@findex WriteDate
   PROCEDURE WriteDate(format: ARRAY OF CHAR; date: Date);

@findex FwriteDate
   PROCEDURE FwriteDate(file: FILE; format: ARRAY OF CHAR; date: Date);

@findex SwriteDate
   PROCEDURE SwriteDate(VAR string: ARRAY OF CHAR;
			format: ARRAY OF CHAR; date: Date);

@findex ReadDate
   PROCEDURE ReadDate(VAR date: Date);

@findex FreadDate
   PROCEDURE FreadDate(file: FILE; VAR date: Date);

@findex SreadDate
   PROCEDURE SreadDate(string: ARRAY OF CHAR; VAR date: Date);

   (* Reading  depends on a set of pattern describing valid      *)
   (* input formats. This formats are stored in an ordered list. *)
   (* If more than one pattern matches the input the first will  *)
   (* be chosen.                                                 *)
   (* Pattern consists of a sequence of letters and some special *)
   (* chars which must match the input. Whitespace (except nl)   *)
   (* is skipped by ReadTime and must not be given inside a      *)
   (* pattern.                                                   *)
   (* Legal Letters:                                             *)
   (*   'y': year, 'm': month,  'd': day                         *)
   (*   'H': hour, 'M': minute, 'S': second                      *)
   (* Examples:                                                  *)
   (*   m/d/yH:M:S        us-date, matches 10/22/86 13:12:14     *)
   (*   d.m.yH:M:S        german date, matches 22.10.86 13:12:14 *)
   (*   md,y              matches Oct 22, 1986                   *)

@findex Append
   PROCEDURE Append(pattern: ARRAY OF CHAR);
      (* appends a new pattern to the end of the list *)

@findex Insert
   PROCEDURE Insert(pattern: ARRAY OF CHAR);
      (* inserts a pattern before the beginning of the list *)

@findex ReleaseList
   PROCEDURE ReleaseList;
      (* causes the list to be emptied *)

@findex DefaultList
   PROCEDURE DefaultList;
      (* appends a list of standard patterns to the list *)
      (* this procedure is called during initialization of TimeIO *)

END TimeIO.
@end example
@page



@c ---------------------------------------------------------------------
