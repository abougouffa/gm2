-- Copyright (C) 2003 Free Software Foundation, Inc.
-- This file is part of GNU Modula-2.
--
-- GNU Modula-2 is free software; you can redistribute it and/or modify it under
-- the terms of the GNU General Public License as published by the Free
-- Software Foundation; either version 2, or (at your option) any later
-- version.
-- 
-- GNU Modula-2 is distributed in the hope that it will be useful, but WITHOUT ANY
-- WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details.
-- 
-- You should have received a copy of the GNU General Public License along
-- with gm2; see the file COPYING.  If not, write to the Free Software
-- Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
--
--
--
% module h2def begin
MODULE h2def ;
(* Copyright (C) 2003 Free Software Foundation, Inc.
   This file is part of GNU Modula-2.

GNU Modula-2 is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2, or (at your option) any later
version.
 
GNU Modula-2 is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.
 
You should have received a copy of the GNU General Public License along
with gm2; see the file COPYING.  If not, write to the Free Software
Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)

(*
   Author     : Gaius Mulley
   Title      : h2def
   Date       : Thu Jan 23 22:04:27 GMT 2003
   SYSTEM     : UNIX (GNU Modula-2)
   Description: a tool which generates a definition module from a C header file.
*)
 
FROM ASCII IMPORT nul, tab, lf ;
FROM Storage IMPORT ALLOCATE ;
FROM CLexBuf IMPORT OpenSource, CloseSource, GetToken, ReInitialize, InsertToken, InsertTokenAndRewind,
                    GetTokenNo, EnableMacroSubstitutions,
                    currenttoken, currentstring, toktype,
                    IsMacroDefined, NoArgs, DefineMacro, UnDefineMacro ;
FROM M2Printf IMPORT printf0, printf1, printf2, printf3, printf4,
                     fprintf0, fprintf1, fprintf2, fprintf3, fprintf4 ;
FROM FormatStrings IMPORT Sprintf0, Sprintf1 ;
FROM SArgs IMPORT Narg, GetArg ;
FROM NameKey IMPORT Name, KeyToCharStar, WriteKey, MakeKey, GetKey, makekey, NulName ;
FROM SymbolKey IMPORT SymbolTree, InitTree, GetSymKey, PutSymKey, NulKey ;

FROM Lists IMPORT List, InitList, IncludeItemIntoList, NoOfItemsInList, GetItemFromList,
                  IsItemInList, RemoveItemFromList, KillList, DuplicateList, PutItemIntoList ;

FROM Strings IMPORT String, InitString, InitStringCharStar, KillString, Add, Length, EqualArray, Mark,
                    string, Dup, Equal, Slice, char, ConCatChar, ConCat, Index, RIndex, Mult, InitStringChar ;

FROM StringConvert IMPORT hstoi ;
FROM StrLib IMPORT StrLen ;
FROM FIO IMPORT File, IsNoError, StdOut, StdErr ;
FROM SFIO IMPORT WriteS, OpenToWrite, Exists ;
FROM M2Options IMPORT ScanCppArgs ;
FROM libc IMPORT exit, memset ;
FROM SYSTEM IMPORT ADDRESS, WORD, TSIZE ;
IMPORT clex ;

TYPE
   nodeType = (ndchain, nderror, nddefined,
               ndor, ndand, ndlor, ndland, ndlxor,
               ndgre, ndless, ndgreequ, ndlessequ, ndequal, ndnotequal,
               ndarray, ndcast,
               ndplus, ndminus, ndmult, nddiv, ndmod,
               ndshiftleft, ndshiftright,
               ndnot, nddummy, ndnegate, ndsizeof, ndlnot,
               ndident,
               ndconststr, ndconstchar, nddecint, ndoctint,
               ndhexint, ndtypedef, ndarraytype, ndenum, ndptr, ndbase,
               ndenumfield, ndstructfield,
               ndfunc, ndstruct, ndunion, ndvararg) ;

   Node = POINTER TO RECORD
                        CASE type: nodeType OF

                        ndchain     :  nextChain: Node |
                        nderror,
                        nddefined   :  cpp: cppNode |
                        ndcast,
                        ndgre,
                        ndless,
                        ndgreequ,
                        ndlessequ,
                        ndequal,
                        ndnotequal,
                        ndor,
                        ndand,
                        ndplus,
                        ndarray,
                        ndminus,
                        ndmult,
                        nddiv,
                        ndmod,
                        ndshiftleft,
                        ndshiftright :  bin: binaryNode |
                        nddummy,
                        ndsizeof,
                        ndnegate,
                        ndlnot,
                        ndnot        :  un : unaryNode |
                        ndident      :  id : identNode |
                        ndconststr,
                        ndconstchar,
                        nddecint,
                        ndoctint,
                        ndhexint     :  value: Name |
                        ndtypedef    :  |
                        ndarraytype  :  max: Node |
                        ndptr        :  |
                        ndenum       :  en: enumNode |
                        ndenumfield  :  ef: enumFieldNode |
                        ndstructfield:  esf: structFieldNode |
                        ndstruct     :  str: structNode |
                        ndunion      :  uni: unionNode |
                        ndfunc       :  func: funcNode |
                        ndbase       :  base: baseNode |
                        ndvararg     :

                        END ;
                        status       :  nodeStatus ;
                        chain        :  Node ;
                     END ;

   nodeStatus = (dontknow, poisoned, true, false, compiled, free) ;

   cppNode = RECORD
                macro: Name ;
             END ;

   funcNode = RECORD
                 type: Node ;
                 list: Node ;
                 name: Name ;
              END ;

   unionNode = RECORD
                  list: Node ;
                  name: Name ;
               END ;

   structNode = RECORD
                   list: Node ;
                   name: Name ;
                END ;

   identNode = RECORD
                   name: Name ;
                   type: Node ;
               END ;

   binaryNode = RECORD
                   left, right: Node ;
                END ;

   unaryNode = RECORD
                  operand: Node ;
               END ;

   enumNode = RECORD
                 list: Node ;
                 name: Name ;
              END ;

   enumFieldNode  = RECORD
                       name: Name ;
                    END ;

   structFieldNode = RECORD
                        type: Node ;
                        decl: Node ;
                     END ;

   baseNode = RECORD
                 name: Name ;
                 list: Node ;
              END ;

   cppIfElseEnd = POINTER TO RECORD
                                doneTrue: BOOLEAN ;
                                compile : BOOLEAN ;
                                next    : cppIfElseEnd ;
                             END ;

   ExpStack = POINTER TO RECORD
                            next :  ExpStack ;
                            value:  WORD ;
                         END ;

   IndentStack = POINTER TO RECORD
                               next          : IndentStack ;
                               previousIndent: CARDINAL ;
                            END ;

   EmitType = (consts, types, procedures, vars, nothing) ;

VAR
   LastReal,
   LastInt,
   LastStr,
   LastChar,
   LastIdent           : ADDRESS ;
   op                  : File ;
   inCpp               : BOOLEAN ;
   CurrentDirectory    : String ;
   DoneList,
   ToDoList,
   CompileTimeList,
   ConstList,
   PoisonedList        : List ;
   freeExp,
   expStack            : ExpStack ;
   freeIndent,
   indentStack         : IndentStack ;
   FreeList            : Node ;
   freeCpp,
   cppStack            : cppIfElseEnd ;
   UseArrayInParameters,
   PoisonNode,
   Debugging,
   DisplayErrors,
   DisplayPoison       : BOOLEAN ;
   emitting            : EmitType ;
   CurColumn,
   Indent              : CARDINAL ;
   CurrentUserPath,
   SystemPath          : String ;
   DummyNo             : CARDINAL ;
   watch               : Node ;


(*
   setwatch - 

*)

PROCEDURE setwatch (n: Node) ;
BEGIN
   watch := n
END setwatch ;


(*
   InitNode - returns a new node.
*)

PROCEDURE InitNode (t: nodeType) : Node ;
VAR
   n: Node ;
BEGIN
   IF FreeList=NIL
   THEN
      NEW(n)
   ELSE
      n := FreeList ;
      FreeList := FreeList^.chain
   END ;
   memset(n, 0, TSIZE(n^)) ;
   WITH n^ DO
      type := t ;
      chain := NIL ;
      status := dontknow
   END ;
   RETURN( n )
END InitNode ;


(*
   MakeBaseNode - builds a base node.
*)

PROCEDURE MakeBaseNode (n: Name) : Node ;
VAR
   t: Node ;
BEGIN
   IF Debugging
   THEN
      hprintf1('making base node (%s)\n', Mark(InitStringCharStar(KeyToCharStar(n))))
   END ;
   t := InitNode(ndbase) ;
   t^.base.name := n ;
   RETURN( t )
END MakeBaseNode ;


(*
   InitChain - creates a chain node and pushes the chained node to the stack.
*)

PROCEDURE InitChain ;
VAR
   n: Node ;
BEGIN
   n := InitNode(ndchain) ;
   n^.chain := Pop() ;
   n^.nextChain := n ;
   Push(n)
END InitChain ;


(*
   ChainOn - places the top of stack into a chained node and combines it with
             the previous chain.
*)

PROCEDURE ChainOn ;
VAR
   n1, n2, t: Node ;
BEGIN
   InitChain ;
   n1 := Pop() ;
   n2 := Pop() ;
   t := n2^.nextChain ;
   WHILE t^.nextChain#n2 DO
      t := t^.nextChain
   END ;
   t^.nextChain := n1 ;
   n1^.nextChain := n2 ;
   Push(n2)
END ChainOn ;


(*
   MakeBinaryNode - returns a created binary node.
*)

PROCEDURE MakeBinaryNode (t: nodeType; l, r: Node) : Node ;
VAR
   n: Node ;
BEGIN
   n := InitNode(t) ;
   WITH n^ DO
      bin.left := l ;
      bin.right := r ;
   END ;
   IF IsPoisoned(l) OR IsPoisoned(r) OR PoisonNode
   THEN
      n := Poison(n)
   END ;
   RETURN( n )
END MakeBinaryNode ;


(*
   MakeUnaryNode - returns a created unary node.
*)

PROCEDURE MakeUnaryNode (t: nodeType; op: Node) : Node ;
VAR
   n: Node ;
BEGIN
   n := InitNode(t) ;
   WITH n^ DO
      un.operand := op ;
   END ;
   IF IsPoisoned(op) OR PoisonNode
   THEN
      n := Poison(n)
   END ;
   RETURN( n )
END MakeUnaryNode ;


(*
   MakeValueNode - returns a value, node.
*)

PROCEDURE MakeValueNode (t: nodeType; v: Name) : Node ;
VAR
   n: Node ;
BEGIN
   n := InitNode(t) ;
   WITH n^ DO
      value := v
   END ;
   IF PoisonNode
   THEN
      n := Poison(n)
   END ;
   RETURN( n )
END MakeValueNode ;


(*
   MakeCppNode - returns a cpp, node.
*)

PROCEDURE MakeCppNode (t: nodeType; v: Name) : Node ;
VAR
   n: Node ;
BEGIN
   n := InitNode(t) ;
   WITH n^ DO
      cpp.macro := v
   END ;
   IF PoisonNode
   THEN
      n := Poison(n)
   END ;
   RETURN( n )
END MakeCppNode ;


(*
   AddNodeToList - adds child, c, to parent, p.
                   The child, c, may be the head of a chain.
*)

PROCEDURE AddNodeToList (p: Node; c: Node) ;
VAR
   s: Node ;
BEGIN
   s := c ;
   WHILE c^.chain#NIL DO
      c := c^.chain
   END ;
   WITH p^ DO
      CASE type OF

      ndenum:   c^.chain := en.list; en.list := s |
      ndstruct: c^.chain := str.list; str.list := s |
      ndunion:  c^.chain := uni.list; uni.list := s

      ELSE
         ErrorArray('internal error: node should not be chained')
      END
   END
END AddNodeToList ;


(*
   ChainTopTwo - chains top of stack to the previous node and removes the top of stack.
*)

PROCEDURE ChainTopTwo ;
VAR
   t, n1, n2: Node;
BEGIN
   n1 := Pop() ;
   n2 := Pop() ;
   t := n2 ;
   WHILE t^.chain#NIL DO
      t := t^.chain
   END ;
   t^.chain := n1 ;
   Push(n2)
END ChainTopTwo ;


(*
   ChainTopTwoIdent - chains top of stack to the previous node,
                      it checks to see the top of stack is an ident
                      and if so it assigns the second element to the
                      type field.
*)

PROCEDURE ChainTopTwoIdent ;
VAR
   n1, n2: Node;
BEGIN
   DisplayStack ;
   n1 := Pop() ;
   n2 := Pop() ;
   IF n1^.type=ndident
   THEN
      IF n1^.id.type#NIL
      THEN
         Push(n1^.id.type) ;
         Push(n2) ;
         ChainTopTwo ;
         n1^.id.type := Pop() ;
         Push(n1)
      ELSIF n2^.type=ndfunc
      THEN
         (* n1^.id.type will be NIL *)
         n2^.func.name := n1^.id.name ;
         Push(n2)
      ELSE
         n1^.id.type := n2 ;
         Push(n1)
      END
   ELSIF n1^.type=ndfunc
   THEN
      IF n1^.func.type=NIL
      THEN
         n1^.func.type := n2
      ELSE
         Push(n1^.func.type) ;
         Push(n2) ;
         ChainTopTwo ;
         n2 := Pop()
      END ;
      Push(n1)
   ELSE
      Push(n2) ;
      Push(n1) ;
      ChainTopTwo
   END
END ChainTopTwoIdent ;


(*
   FlipTwoChain - chains the second element of the stack onto the top element of the stack.
*)

PROCEDURE FlipTwoChain ;
VAR
   n1, n2: Node;
BEGIN
   n1 := Pop() ;
   n2 := Pop() ;
   IF n1^.chain#NIL
   THEN
      ErrorArray('internal error: node should not be on a chain')
   END ;
   n1^.chain := n2 ;
   Push(n1)
END FlipTwoChain ;


(*
   Poison - poisons a node, n.
*)

PROCEDURE Poison (n: Node) : Node ;
BEGIN
   n^.status := poisoned ;
   RETURN( n )
END Poison ;


(*
   True - set node, n, to true
*)

PROCEDURE True (n: Node) : Node ;
BEGIN
   n^.status := true ;
   RETURN( n )
END True ;


(*
   IsTrue - returns TRUE if node was set to true.
*)

PROCEDURE IsTrue (n: Node) : BOOLEAN ;
BEGIN
   IF n=NIL
   THEN
      RETURN( FALSE )
   ELSE
      RETURN( n^.status=true )
   END
END IsTrue ;


(*
   False - set node, n, to false.
*)

PROCEDURE False (n: Node) : Node ;
BEGIN
   n^.status := false ;
   RETURN( n )
END False ;


(*
   IsFalse - returns TRUE if node was set to false.
*)

PROCEDURE IsFalse (n: Node) : BOOLEAN ;
BEGIN
   IF n=NIL
   THEN
      RETURN( FALSE )
   ELSE
      RETURN( n^.status=false )
   END
END IsFalse ;


(*
   Compiled - set node, n, to compiled.
*)

PROCEDURE Compiled (n: Node) : Node ;
BEGIN
   n^.status := compiled ;
   RETURN( n )
END Compiled ;


(*
   IsCompiled - returns TRUE if node was set to compiled.
*)

PROCEDURE IsCompiled (n: Node) : BOOLEAN ;
BEGIN
   IF n=NIL
   THEN
      RETURN( FALSE )
   ELSE
      RETURN( n^.status=compiled )
   END
END IsCompiled ;


(*
   IsPoisoned - 
*)

PROCEDURE IsPoisoned (n: Node) : BOOLEAN ;
BEGIN
   IF n=NIL
   THEN
      RETURN( FALSE )
   ELSE
      RETURN( n^.status=poisoned )
   END
END IsPoisoned ;


(*
   InitCpp - 
*)

PROCEDURE InitCpp () : cppIfElseEnd ;
VAR
   c: cppIfElseEnd ;
BEGIN
   IF freeCpp=NIL
   THEN
      NEW(c)
   ELSE
      c := freeCpp ;
      freeCpp := freeCpp^.next
   END ;
   WITH c^ DO
      doneTrue := FALSE ;
      compile  := FALSE ;
      next     := NIL
   END ;
   RETURN( c )
END InitCpp ;


(*
   KillCpp - 
*)

PROCEDURE KillCpp (c: cppIfElseEnd) ;
BEGIN
   IF c^.next=NIL
   THEN
      c^.next := freeCpp ;
      freeCpp := c
   ELSE
      ErrorArray('internal error: cpp statement already on a list or stacked')
   END
END KillCpp ;


(*
   MarkTrue - 
*)

PROCEDURE MarkTrue (c: cppIfElseEnd) : cppIfElseEnd ;
BEGIN
   IF c#NIL
   THEN
      c^.doneTrue := TRUE
   END ;
   RETURN( c )
END MarkTrue ;


(*
   HaveDoneTrue - 
*)

PROCEDURE HaveDoneTrue (c: cppIfElseEnd) : BOOLEAN ;
BEGIN
   IF c#NIL
   THEN
      RETURN( c^.doneTrue )
   ELSE
      RETURN( FALSE )
   END
END HaveDoneTrue ;


(*
   MarkCompile - 
*)

PROCEDURE MarkCompile (c: cppIfElseEnd) : cppIfElseEnd ;
BEGIN
   IF c#NIL
   THEN
      c^.compile := TRUE
   END ;
   RETURN( c )
END MarkCompile ;


(*
   CompileTime - 
*)

PROCEDURE CompileTime (c: cppIfElseEnd) : BOOLEAN ;
BEGIN
   IF c#NIL
   THEN
      RETURN( c^.compile )
   ELSE
      RETURN( FALSE )
   END
END CompileTime ;


(*
   PushCpp - 
*)

PROCEDURE PushCpp (c: cppIfElseEnd) ;
BEGIN
   IF c#NIL
   THEN
      IF c^.next=NIL
      THEN
         c^.next := cppStack ;
         cppStack := c
      ELSE
         ErrorArray('internal error: cpp statement already stacked')
      END
   END
END PushCpp ;


(*
   PopCpp - returns the last item stacked.
*)

PROCEDURE PopCpp () : cppIfElseEnd ;
VAR
   c: cppIfElseEnd ;
BEGIN
   IF cppStack=NIL
   THEN
      ErrorArray("unbalanced too many #endif's") ;
      RETURN( NIL )
   ELSE
      c := cppStack ;
      cppStack := cppStack^.next ;
      c^.next := NIL ;
      RETURN( c )
   END
END PopCpp ;


(*
   BuildIf - 
*)

PROCEDURE BuildIf ;
VAR
   n: Node ;
   c: cppIfElseEnd ;
   s: nodeStatus ;
BEGIN
   n := Pop() ;
   s := EvaluateNode(n) ;
   c := InitCpp() ;
   IF s=true
   THEN
      c := MarkTrue(c)
   ELSIF s=false
   THEN
      clex.ParsingOn(FALSE)
   ELSE
      (* might be compiled or poisoned *)
      c := MarkCompile(c) ;
      IF (s=poisoned) AND DisplayPoison
      THEN
         printf0('\n(* #if was poisoned *)\n')
      END ;
      printf0('\n# if ') ; CppPrintNode(n) ; hprintf0('\n')
   END ;
   PushCpp(c)
END BuildIf ;


(*
   BuildIfDef - 
*)

PROCEDURE BuildIfDef (b: BOOLEAN) ;
VAR
   c: cppIfElseEnd ;
BEGIN
   c := InitCpp() ;
   IF IsItemInList(CompileTimeList, LastIdent)
   THEN
      c := MarkCompile(c) ;
      IF b
      THEN
         printf1('\n# ifdef %s', Mark(InitStringCharStar(KeyToCharStar(LastIdent))))
      ELSE
         printf1('\n# ifndef %s', Mark(InitStringCharStar(KeyToCharStar(LastIdent))))
      END ;
      hprintf0('\n')
   ELSE
      IF b
      THEN
         IF IsMacroDefined(LastIdent)
         THEN
            c := MarkTrue(c)
         ELSE
            clex.ParsingOn(FALSE)
         END
      ELSE
         IF IsMacroDefined(LastIdent)
         THEN
            clex.ParsingOn(FALSE)
         ELSE
            c := MarkTrue(c)
         END
      END
   END ;
   PushCpp(c)
END BuildIfDef ;


(*
   BuildElse - 
*)

PROCEDURE BuildElse ;
BEGIN
   IF cppStack=NIL
   THEN
      ErrorArray('found #else without a corresponding #if')
   ELSE
      IF CompileTime(cppStack)
      THEN
         printf0('\n# else') ; hprintf0('\n')
      ELSIF HaveDoneTrue(cppStack)
      THEN
         clex.ParsingOn(FALSE)
      ELSE
         cppStack := MarkTrue(cppStack) ;
         clex.ParsingOn(TRUE)
      END
   END
END BuildElse ;


(*
   BuildEndIf - 
*)

PROCEDURE BuildEndIf ;
BEGIN
   IF cppStack=NIL
   THEN
      ErrorArray('found #endif without a corresponding #if')
   ELSE
      IF CompileTime(cppStack)
      THEN
         printf0('\n# endif') ; hprintf0('\n')
      END ;
      clex.ParsingOn(TRUE) ;
      KillCpp(PopCpp())
   END
END BuildEndIf ;


(*
   BuildUndef - 
*)

PROCEDURE BuildUndef ;
BEGIN
   IF (cppStack#NIL) AND CompileTime(cppStack)
   THEN
      printf1('\n# undef %s', Mark(InitStringCharStar(LastIdent))) ;
      hprintf0('\n')
   ELSE
      UnDefineMacro(LastIdent)
   END
END BuildUndef ;


(*
   BuildConst - 
*)

PROCEDURE BuildConst (name: ADDRESS; n: Node) ;
BEGIN
   IF IsPoisoned(n)
   THEN
      IF DisplayPoison
      THEN
         hprintf1('(* constant %s was poisoned *)\n', Mark(InitStringCharStar(name)))
      END
   ELSE
      Emit(consts) ;
      hprintf1('%s = ', Mark(InitStringCharStar(name))) ;
      PrintNode(n, NIL) ; hprintf0(' ;\n')
   END
END BuildConst ;


(*
   Emit - 
*)

PROCEDURE Emit (e: EmitType) ;
BEGIN
   IF e#emitting
   THEN
      CASE emitting OF

      types,
      vars,
      consts    :   PopIndent |
      nothing,
      procedures:
      
      ELSE
      END ;
      CASE e OF

      types     :   hprintf0('\nTYPE') ; Indent := PushIndent(CurColumn) |
      vars      :   hprintf0('\nVAR') ; Indent := PushIndent(CurColumn) |
      consts    :   hprintf0('\nCONST') ; Indent := PushIndent(CurColumn) |
      nothing,
      procedures:

      ELSE
      END ;
      hprintf0('\n') ;
      emitting := e
   END
END Emit ;


(*
   hprintf0 - 
*)

PROCEDURE hprintf0 (a: ARRAY OF CHAR) ;
BEGIN
   IF KillString(writes(Sprintf0(InitString(a))))=NIL
   THEN
   END
END hprintf0 ;


PROCEDURE hprintf1 (a: ARRAY OF CHAR; w: WORD) ;
BEGIN
   IF KillString(writes(Sprintf1(InitString(a), w)))=NIL
   THEN
   END
END hprintf1 ;


(*
   HasType - returns TRUE if, n, specifies a type.
*)

PROCEDURE HasType (n: Node) : BOOLEAN ;
BEGIN
   WHILE n#NIL DO
      CASE n^.type OF

      nddummy,
      nderror: |
      ndbase : WITH n^ DO
                  IF (base.name=MakeKey('const')) OR
                     (base.name=MakeKey('volatile')) OR
                     (base.name=MakeKey('void')) OR
                     (base.name=MakeKey('register')) OR
                     (base.name=MakeKey('extern')) OR
                     (base.name=MakeKey('auto'))
                  THEN
                     (* do nothing *)
                  ELSE
                     RETURN( TRUE )
                  END
               END
      ELSE
         RETURN( TRUE )
      END ;
      n := n^.chain
   END ;
   RETURN( FALSE )
END HasType ;


TYPE
   baseType = (voidp, intp, longp, charp, floatp, doublep, unsignedp) ;
   baseSet  = SET OF baseType ;
   PrintProcedure = PROCEDURE (Node, Node) ;


(*
   GetBaseSet - 
*)

PROCEDURE GetBaseSet (VAR n: Node; VAR t: baseSet) : BOOLEAN ;
VAR
   m: Node ;
BEGIN
   m := n ;
   t := {} ;
   WHILE n#NIL DO
      WITH n^ DO
         CASE type OF

         ndbase:  IF base.name=MakeKey('int')
                  THEN
                     INCL(t, intp)
                  ELSIF base.name=MakeKey('long')
                  THEN
                     INCL(t, longp)
                  ELSIF base.name=MakeKey('char')
                  THEN
                     INCL(t, charp)
                  ELSIF base.name=MakeKey('float')
                  THEN
                     INCL(t, floatp)
                  ELSIF base.name=MakeKey('double')
                  THEN
                     INCL(t, doublep)
                  ELSIF base.name=MakeKey('unsigned')
                  THEN
                     INCL(t, unsignedp)
                  ELSIF base.name=MakeKey('void')
                  THEN
                     INCL(t, voidp)
                  END |

         ndtypedef,
         nddummy:

         ELSE
            IF t={}
            THEN
               n := m ;
               RETURN( FALSE )
            ELSE
               RETURN( TRUE )
            END
         END
      END ;
      n := n^.chain
   END ;
   IF t={}
   THEN
      n := m ;
      RETURN( FALSE )
   ELSE
      RETURN( TRUE )
   END
END GetBaseSet ;


(*
   PrintBasicType - 
*)

PROCEDURE PrintBasicType (n: Node; t: baseSet) ;
BEGIN
   IF (t={longp}) OR (t={intp})
   THEN
      hprintf0('INTEGER')
   ELSIF t={intp, longp}
   THEN
      hprintf0('LONGINT')
   ELSIF t={charp}
   THEN
      hprintf0('CHAR')
   ELSIF t={charp, unsignedp}
   THEN
      hprintf0('BYTE')
   ELSIF t={floatp}
   THEN
      hprintf0('SHORTREAL')
   ELSIF t={doublep}
   THEN
      hprintf0('REAL')
   ELSIF t={longp, doublep}
   THEN
      hprintf0('LONGREAL')
   ELSIF (t={unsignedp, intp}) OR (t={unsignedp})
   THEN
      hprintf0('CARDINAL')
   ELSIF t={unsignedp, intp, longp}
   THEN
      hprintf0('LONGCARD')
   ELSIF n#NIL
   THEN
      CASE n^.type OF

      ndbase  : hprintf1('%s', Mark(InitStringCharStar(KeyToCharStar(n^.base.name)))) |
      ndstruct: hprintf1('%s', Mark(InitStringCharStar(KeyToCharStar(n^.str.name))))

      ELSE
         ErrorArray('dont understand this type')
      END
   ELSE
      ErrorArray('dont understand this type')
   END
END PrintBasicType ;


(*
   PrintBaseType - displays the base type of, n.
*)

PROCEDURE PrintBaseType (n: Node) ;
VAR
   t: baseSet ;
   m: Node ;
BEGIN
   IF n#NIL
   THEN
      IF GetBaseSet(n, t)
      THEN
         IF t={voidp}
         THEN
            IF (n#NIL) AND (n^.type=ndptr)
            THEN
               hprintf0('ADDRESS')
            END
         ELSE
            m := NIL ;
            WHILE n#NIL DO
               IF n^.type=ndptr
               THEN
                  hprintf0('POINTER TO ') ;
                  m := n^.chain
               END ;
               n := n^.chain
            END ;
            PrintBasicType(m, t)
         END
      ELSIF (n^.type=ndbase) OR (n^.type=ndstruct)
      THEN
         PrintBasicType(n, {})
      ELSIF n^.type=ndvararg
      THEN
         hprintf0('...')
      END
   END
END PrintBaseType ;


(*
   PrintSimpleType - 
*)

PROCEDURE PrintSimpleType (n: Node) ;
BEGIN
   IF IsPointer(n)
   THEN
      hprintf0('ADDRESS')
   ELSE
      PrintBaseType(n)      
   END
END PrintSimpleType ;


(*
   PrintChain - 
*)

PROCEDURE PrintChain (n, t: Node; p: PrintProcedure; separator: ARRAY OF CHAR) ;
VAR
   h: Node ;
BEGIN
   IF n#NIL
   THEN
      h := n ;
      REPEAT
         CASE n^.type OF

         ndchain:  p(n^.chain, t)

         ELSE
            ErrorArray('internal error: expecting chain')
         END ;
         n := n^.nextChain ;
         IF n#h
         THEN
            hprintf0(separator)
         END
      UNTIL n=h
   END
END PrintChain ;


(*
   SkipDummy - 
*)

PROCEDURE SkipDummy (n: Node) : Node ;
BEGIN
   WHILE (n#NIL) AND (n^.type=nddummy) DO
      n := n^.chain
   END ;
   RETURN( n )
END SkipDummy ;


(*
   ArrayOrAddress - 
*)

PROCEDURE ArrayOrAddress (a: ARRAY OF CHAR) ;
BEGIN
   IF UseArrayInParameters
   THEN
      hprintf0(a)
   ELSE
      hprintf0('ADDRESS')
   END
END ArrayOrAddress ;


(*
   IsPointer - returns TRUE if list, n, contains a pointer.
*)

PROCEDURE IsPointer (n: Node) : BOOLEAN ;
BEGIN
   WHILE n#NIL DO
      CASE n^.type OF

      ndptr  :  RETURN( TRUE )
   
      ELSE
      END ;
      n := n^.chain
   END ;
   RETURN( FALSE )
END IsPointer ;


(*
   IsSinglePointer - pointers are declared at the end of the list, n.
                     It returns false if the list ends with a **.
*)

PROCEDURE IsSinglePointer (n: Node) : BOOLEAN ;
VAR
   ptr: BOOLEAN ;
BEGIN
   ptr := FALSE ;
   WHILE n#NIL DO
      CASE n^.type OF

      nddummy:  |
      ndptr  :  IF ptr
                THEN
                   RETURN( FALSE )  (* POINTER TO POINTER *)
                END ;
                ptr := TRUE
   
      ELSE
         ptr := FALSE
      END ;
      n := n^.chain
   END ;
   RETURN( ptr )
END IsSinglePointer ;


(*
   IsArray - 
*)

PROCEDURE IsArray (n: Node) : BOOLEAN ;
VAR
   t: baseSet ;
BEGIN
   IF IsSinglePointer(n)
   THEN
      IF GetBaseSet(n, t)
      THEN
         IF t={voidp}
         THEN
            hprintf0('ADDRESS') ;
            RETURN( TRUE )
         ELSIF t={charp}
         THEN
            ArrayOrAddress('ARRAY OF CHAR') ;
            RETURN( TRUE )
         ELSIF t={charp, unsignedp}
         THEN
            ArrayOrAddress('ARRAY OF BYTE') ;
            RETURN( TRUE )
         ELSIF t={intp}
         THEN
            ArrayOrAddress('ARRAY OF INTEGER') ;
            RETURN( TRUE )
         ELSIF t={intp, unsignedp}
         THEN
            ArrayOrAddress('ARRAY OF CARDINAL') ;
            RETURN( TRUE )
         END
      ELSIF (n#NIL) AND (n^.type=ndbase)
      THEN
         IF UseArrayInParameters
         THEN
            hprintf1('ARRAY OF %s', Mark(InitStringCharStar(n^.base.name)))
         ELSE
            hprintf0('ADDRESS')
         END ;
         RETURN( TRUE )
      END
   END ;
   RETURN( FALSE )      
END IsArray ;


(*
   IsVoid - returns TRUE if node, n, contains, void only.
*)

PROCEDURE IsVoid (n: Node) : BOOLEAN ;
BEGIN
   n := SkipDummy(n) ;
   IF (n^.type=ndbase) AND (n^.base.name=MakeKey('void')) AND (n^.chain=NIL)
   THEN
      RETURN( TRUE )
   ELSE
      RETURN( FALSE )
   END
END IsVoid ;


(*
   PrintParameter - 
*)

PROCEDURE PrintParameter (n, t: Node) ;
BEGIN
   IF n#NIL
   THEN
      IF n^.type=ndident
      THEN
         hprintf1('%s: ', Mark(InitStringCharStar(n^.id.name))) ;
         IF IsArray(n^.id.type)
         THEN
            (* do nothing *)
         ELSE
            PrintSimpleType(n^.id.type)
         END
      ELSE
         n := SkipDummy(n) ;
         IF (emitting=procedures) AND (n#NIL) AND (n^.type#ndvararg)
         THEN
            hprintf1('__gm2param%d: ', DummyNo) ;
            INC(DummyNo)
         END ;
         IF IsArray(n)
         THEN
            (* do nothing *)
         ELSE
            PrintSimpleType(n)
         END
      END
   END
END PrintParameter ;


(*
   PrintParameters - 
*)

PROCEDURE PrintParameters (n, t: Node) ;
BEGIN
   IF emitting=procedures
   THEN
      DummyNo := 1 ;
      PrintChain(n, t, PrintParameter, '; ')
   ELSE
      PrintChain(n, t, PrintParameter, ', ')
   END
END PrintParameters ;


(*
   FindFunc - returns a func node (or NIL) from a list of nodes, n.
*)

PROCEDURE FindFunc (n: Node) : Node ;
VAR
   m: Node ;
BEGIN
   WHILE n#NIL DO
      IF n^.type=ndfunc
      THEN
         RETURN( n )
      END ;
      n := n^.chain
   END ;
   RETURN( NIL )
END FindFunc ;


(*
   CheckProcedureParameters - checks to see whether we have a
                              parameter which is a function and manipulates
                              this into a typedef and a parameter name.
*)

PROCEDURE CheckProcedureParameters (n: Node) ;
VAR
   f, i, t, m: Node ;
BEGIN
   IF (n#NIL) AND (n^.type=ndchain)
   THEN
      m := n ;
      REPEAT
         IF (n^.chain#NIL) AND (n^.chain^.type=ndident)
         THEN
            f := FindFunc(n^.chain^.id.type)
         ELSE
            f := NIL
         END ;
         IF f#NIL
         THEN
            i := InitNode(ndident) ;
            i^.id.name := makekey(string(Sprintf1(Mark(InitString('__gm2param%d')), DummyNo))) ;
            i^.id.type := MakeBaseNode(n^.chain^.id.name) ;
            
            t := InitNode(ndtypedef) ;
            t^.chain := n^.chain^.id.type ;
            n^.chain^.id.type := t ;
            PutItemIntoList(ToDoList, n^.chain) ;
            n^.chain := i
         END ;
         m := m^.nextChain
      UNTIL m=n
   END
END CheckProcedureParameters ;


(*
   RemoveOnlyVoidParameter - 
*)

PROCEDURE RemoveOnlyVoidParameter (VAR n: Node) ;
BEGIN
   IF (n#NIL) AND (n^.type=ndchain)
   THEN
      IF n^.nextChain=n
      THEN
         n^.chain := SkipDummy(n^.chain) ;
         IF IsVoid(n^.chain)
         THEN
            n := NIL
         END
      END
   END
END RemoveOnlyVoidParameter ;


(*
   PrintNode - 
*)

PROCEDURE PrintNode (n, t: Node) ;
VAR
   s, s2: baseSet ;
BEGIN
   IF n=NIL
   THEN
      IF t#NIL
      THEN
         PrintNode(t, NIL)
      END
   ELSE
      hprintf0(' ') ;
      WITH n^ DO
         CASE type OF

         ndchain     : PrintChain(n, t, PrintNode, ';\n') ; RETURN |
         nderror     : hprintf0('error node') |
         nddefined   : hprintf1('defined(%s)', Mark(InitStringCharStar(cpp.macro))) |
         ndcast      : hprintf0('VAL(') ; PrintNode(bin.left, t) ; hprintf0(', ') ; PrintNode(bin.right, t) ; hprintf0(')') |
         ndgre       : hprintf0('(') ; PrintNode(bin.left, t) ; hprintf0(') > (') ; PrintNode(bin.right, t) ; hprintf0(')') |
         ndless      : hprintf0('(') ; PrintNode(bin.left, t) ; hprintf0(') < (') ; PrintNode(bin.right, t) ; hprintf0(')') |
         ndgreequ    : hprintf0('(') ; PrintNode(bin.left, t) ; hprintf0(') >= (') ; PrintNode(bin.right, t) ; hprintf0(')') |
         ndlessequ   : hprintf0('(') ; PrintNode(bin.left, t) ; hprintf0(') <= (') ; PrintNode(bin.right, t) ; hprintf0(')') |
         ndequal     : hprintf0('(') ; PrintNode(bin.left, t) ; hprintf0(') = (') ; PrintNode(bin.right, t) ; hprintf0(')') |
         ndnotequal  : hprintf0('(') ; PrintNode(bin.left, t) ; hprintf0(') # (') ; PrintNode(bin.right, t) ; hprintf0(')') |
         ndor        : hprintf0('(') ; PrintNode(bin.left, t) ; hprintf0(') OR (') ; PrintNode(bin.right, t) ; hprintf0(')') |
         ndand       : hprintf0('(') ; PrintNode(bin.left, t) ; hprintf0(') AND (') ; PrintNode(bin.right, t) ; hprintf0(')') |
         ndarray     : PrintNode(bin.left, t) ; hprintf0('[') ; PrintNode(bin.right, t) ; hprintf0(']') |
         ndplus      : hprintf0('(') ; PrintNode(bin.left, t) ; hprintf0(') + (') ; PrintNode(bin.right, t) ; hprintf0(')') |
         ndminus     : hprintf0('(') ; PrintNode(bin.left, t) ; hprintf0(') - (') ; PrintNode(bin.right, t) ; hprintf0(')') |
         ndmult      : hprintf0('(') ; PrintNode(bin.left, t) ; hprintf0(') * (') ; PrintNode(bin.right, t) ; hprintf0(')') |
         nddiv       : hprintf0('(') ; PrintNode(bin.left, t) ; hprintf0(') DIV (') ; PrintNode(bin.right, t) ; hprintf0(')') |
         ndmod       : hprintf0('(') ; PrintNode(bin.left, t) ; hprintf0(') MOD (') ; PrintNode(bin.right, t) ; hprintf0(')') |
         ndshiftleft : hprintf0('(') ; PrintNode(bin.left, t) ; hprintf0(') << (') ; PrintNode(bin.right, t) ; hprintf0(')') |
         ndshiftright: hprintf0('(') ; PrintNode(bin.left, t) ; hprintf0(') >> (') ; PrintNode(bin.right, t) ; hprintf0(')') |
         nddummy     : PrintNode(un.operand, t) |
         ndsizeof    : hprintf0('SIZE(') ; PrintNode(un.operand, t) ; hprintf0(')') |
         ndnegate    : hprintf0('-(') ; PrintNode(un.operand, t) ; hprintf0(')') |
         ndlnot      : hprintf0('-BITSET(') ; PrintNode(un.operand, t) ; hprintf0(')') |
         ndnot       : hprintf0('(NOT (') ; PrintNode(un.operand, t) ; hprintf0('))') |
         ndconststr,
         ndconstchar,
         nddecint,
         ndoctint,
         ndhexint     :  hprintf1('%s', Mark(InitStringCharStar(value))) |
         ndident      :  IF id.type=NIL
                         THEN
                            IF (emitting=consts) OR IsItemInList(ConstList, id.name)
                            THEN
                               hprintf1('%s', Mark(InitStringCharStar(id.name)))
                            ELSE
                               hprintf1('%s:', Mark(InitStringCharStar(id.name)))
                            END
                         ELSE
                            IF IsTypeDef(id.type)
                            THEN
                               Emit(types) ;
                               clex.AddTypeDef(KeyToCharStar(id.name)) ;
                               hprintf1('%s = ', Mark(InitStringCharStar(id.name)))
                            ELSE
                               hprintf1('%s:', Mark(InitStringCharStar(id.name)))
                            END ;
                            PrintNode(id.type, t) ;
                            IF chain=NIL
                            THEN
                               t := NIL
                            END
                         END |
         ndtypedef    :  |
         ndarraytype  :  IF max=NIL
                         THEN
                            hprintf0('POINTER TO')
                         ELSE
                            hprintf0('ARRAY [0..') ; PrintNode(max, NIL) ; hprintf0('-1] OF')
                         END |
         ndptr        :  IF ((chain#NIL) AND (chain^.type=ndfunc)) OR
                            ((t#NIL) AND (t^.type=ndfunc))
                         THEN
                            (* hprintf0('silent PTR TO') *)
                         ELSE
                            IF GetBaseSet(t, s)
                            THEN
                            END ;
                            IF GetBaseSet(n^.chain, s2)
                            THEN
                            END ;
                            s := s+s2 ;
                            IF s={voidp}
                            THEN
                               hprintf0('ADDRESS') ;
                               RETURN
                            ELSE
                               hprintf0('POINTER TO ') ;
                               IF s#{}
                               THEN
                                  PrintBasicType(NIL, s) ;
                                  RETURN
                               END
                            END
                         END |
         ndenum       :  (* IF emitting=vars
                         THEN
                            hprintf0(':')
                         END ; *)
                         IF en.name=NIL
                         THEN
                            hprintf0('(') ;
                            PrintNode(en.list, t) ;
                            hprintf0(')')
                         ELSE
                            hprintf1('%s', Mark(InitStringCharStar(en.name))) ;
                            IF en.list#NIL
                            THEN
                               hprintf0(' ;\n')
                            END ;
                            PutItemIntoList(ToDoList, n)
                         END |
         ndstruct     :  IF str.name=NIL
                         THEN
                            Indent := PushIndent(CurColumn+4) ;
                            Indent := PushIndent(CurColumn+4) ;
                            hprintf0('RECORD\n') ;
                            PrintNode(str.list, t) ;
                            hprintf0('END') ;
                            PopIndent
                         ELSE
                            hprintf1('%s', Mark(InitStringCharStar(str.name))) ;
                            IF emitting=vars
                            THEN
                               hprintf0('; (* var *)')
                            END ;
                            PutItemIntoList(ToDoList, n)
                         END |
         ndstructfield:  PrintNode(esf.decl, esf.type) ; (* hprintf0('<:') ; PrintNode(esf.type, t) ; *)
                         IF chain=NIL
                         THEN
                            PopIndent
                         END ;
                         hprintf0(' ;\n') |
         ndenumfield  :  hprintf1('%s', Mark(InitStringCharStar(ef.name))) ;
                         IF chain#NIL
                         THEN
                            hprintf0(',')
                         END |
(*
         ndunion      :  uni: unionNode |
*)
         ndfunc       :  hprintf0('PROCEDURE ') ;
                         IF func.name#NIL
                         THEN
                            hprintf1('%s ', Mark(InitStringCharStar(func.name)))
                         END ;
                         CheckProcedureParameters(func.list) ;
                         RemoveOnlyVoidParameter(func.list) ;
                         IF HasType(func.type) OR (func.list#NIL)
                         THEN
                            hprintf0('(') ; PrintParameters(func.list, NIL) ; hprintf0(')') ;
                            IF HasType(func.type)
                            THEN
                               hprintf0(' : ') ;
                               PrintSimpleType(func.type)
                            END
                         END |
         ndbase       :  PrintBaseType(n) ; RETURN (* hprintf1('%s', Mark(InitStringCharStar(base.name))) *) |
         ndvararg     :  hprintf0(', ...')


         ELSE
            ErrorArray('internal error: unknown node type')
         END ;
         PrintNode(chain, t)
      END
   END
END PrintNode ;


(*
   PushIndent - 
*)

PROCEDURE PushIndent (n: CARDINAL) : CARDINAL ;
VAR
   e: IndentStack ;
BEGIN
   IF freeIndent=NIL
   THEN
      NEW(e)
   ELSE
      e := freeIndent ;
      freeIndent := freeIndent^.next
   END ;
   WITH e^ DO
      next := indentStack ;
      previousIndent := Indent ;
   END ;
   indentStack := e ;
   RETURN( n )
END PushIndent ;


(*
   PopIndent - 
*)

PROCEDURE PopIndent ;
VAR
   e: IndentStack ;
BEGIN
   IF indentStack=NIL
   THEN
      ErrorArray('internal error: indent stack underflow') ;
      CurColumn := 0
   ELSE
      e := indentStack ;
      Indent := indentStack^.previousIndent ;
      indentStack := indentStack^.next ;
      e^.next := freeIndent ;
      freeIndent := e
   END
END PopIndent ;


(*
   LocalWrite - 
*)

PROCEDURE LocalWrite (ch: CHAR) ;
BEGIN
   IF KillString(WriteS(StdOut, InitStringChar(ch)))=NIL
   THEN
      INC(CurColumn)
   END ;
   IF ch=lf
   THEN
      IF KillString(WriteS(StdOut, Mult(Mark(InitString(' ')), Indent)))=NIL
      THEN
      END ;
      CurColumn := 0
   END
END LocalWrite ;


(*
   writes - 
*)

PROCEDURE writes (s: String) : String ;
VAR
   p: POINTER TO CHAR ;
BEGIN
   p := string(s) ;
   WHILE p^#nul DO
      LocalWrite(p^) ;
      INC(p)
   END ;
   RETURN( s )
END writes ;


(*
   IsTypeDef - 
*)

PROCEDURE IsTypeDef (n: Node) : BOOLEAN ;
BEGIN
   WHILE n#NIL DO
      IF n^.type=ndtypedef
      THEN
         RETURN( TRUE )
      ELSE
         n := n^.chain
      END
   END ;
   RETURN( FALSE )
END IsTypeDef ;


(*
   PrintCNode - 
*)

PROCEDURE PrintCNode (n: Node) ;
BEGIN
   DisplayStack ;
   IF n#NIL
   THEN
      WITH n^ DO
         CASE type OF

         ndstruct:  IF n^.str.name#NIL
                    THEN
                       IF NOT IsItemInList(DoneList, n^.str.name)
                       THEN
                          PutItemIntoList(DoneList, n^.str.name) ;
                          Emit(types) ;
                          hprintf1('%s = ', Mark(InitStringCharStar(str.name))) ;
                          Indent := PushIndent(CurColumn+4) ;
                          Indent := PushIndent(CurColumn+4) ;
                          hprintf0('RECORD\n') ;
                          PrintNode(str.list, NIL) ;
                          hprintf0('END') ;
                          PopIndent ;
                       END ;
                    END ;
                    RETURN |
         ndenum:    IF n^.en.name#NIL
                    THEN
                       IF NOT IsItemInList(DoneList, n^.en.name)
                       THEN
                          PutItemIntoList(DoneList, n^.en.name) ;
                          Emit(types) ;
                          hprintf1('%s = ', Mark(InitStringCharStar(en.name))) ;
                          hprintf0(' (') ;
                          PrintNode(en.list, NIL) ;
                          hprintf0(')')
                       END ;
                    END ;
                    RETURN |
         ndident :  IF IsTypeDef(id.type)
                    THEN
                       Emit(types)
                    ELSE
                       Emit(vars)
                    END |
         ndfunc :   Emit(procedures)

         ELSE
         END
      END ;
      PrintNode(n, NIL) ;
      WHILE NoOfItemsInList(ToDoList)#0 DO
         n := GetItemFromList(ToDoList, 1) ;
         RemoveItemFromList(ToDoList, n) ;
         IF emitting=procedures
         THEN
            hprintf0(';\n')
         END ;
         Emit(types) ;
         PrintCNode(n)
      END
   END
END PrintCNode ;


(*
   CppPrintNode - 
*)

PROCEDURE CppPrintNode (n: Node) ;
BEGIN
   IF n#NIL
   THEN
      WITH n^ DO
         CASE type OF

         nderror     : hprintf0('error node') |
         nddefined   : hprintf1('defined(%s)', Mark(InitStringCharStar(cpp.macro))) |
         ndcast      : hprintf0('(') ; CppPrintNode(bin.left) ; hprintf0(') (') ; CppPrintNode(bin.right) ; hprintf0(')') |
         ndgre       : hprintf0('(') ; CppPrintNode(bin.left) ; hprintf0(') > (') ; CppPrintNode(bin.right) ; hprintf0(')') |
         ndless      : hprintf0('(') ; CppPrintNode(bin.left) ; hprintf0(') < (') ; CppPrintNode(bin.right) ; hprintf0(')') |
         ndgreequ    : hprintf0('(') ; CppPrintNode(bin.left) ; hprintf0(') >= (') ; CppPrintNode(bin.right) ; hprintf0(')') |
         ndlessequ   : hprintf0('(') ; CppPrintNode(bin.left) ; hprintf0(') <= (') ; CppPrintNode(bin.right) ; hprintf0(')') |
         ndequal     : hprintf0('(') ; CppPrintNode(bin.left) ; hprintf0(') = (') ; CppPrintNode(bin.right) ; hprintf0(')') |
         ndnotequal  : hprintf0('(') ; CppPrintNode(bin.left) ; hprintf0(') # (') ; CppPrintNode(bin.right) ; hprintf0(')') |
         ndor        : hprintf0('(') ; CppPrintNode(bin.left) ; hprintf0(') || (') ; CppPrintNode(bin.right) ; hprintf0(')') |
         ndand       : hprintf0('(') ; CppPrintNode(bin.left) ; hprintf0(') && (') ; CppPrintNode(bin.right) ; hprintf0(')') |
         ndarray     : PrintNode(bin.left, NIL) ; hprintf0('[') ; PrintNode(bin.right, NIL) ; hprintf0(']') |
         ndplus      : hprintf0('(') ; CppPrintNode(bin.left) ; hprintf0(') + (') ; CppPrintNode(bin.right) ; hprintf0(')') |
         ndminus     : hprintf0('(') ; CppPrintNode(bin.left) ; hprintf0(') - (') ; CppPrintNode(bin.right) ; hprintf0(')') |
         ndmult      : hprintf0('(') ; CppPrintNode(bin.left) ; hprintf0(') * (') ; CppPrintNode(bin.right) ; hprintf0(')') |
         nddiv       : hprintf0('(') ; CppPrintNode(bin.left) ; hprintf0(') DIV (') ; CppPrintNode(bin.right) ; hprintf0(')') |
         ndmod       : hprintf0('(') ; CppPrintNode(bin.left) ; hprintf0(') MOD (') ; CppPrintNode(bin.right) ; hprintf0(')') |
         ndshiftleft : hprintf0('(') ; CppPrintNode(bin.left) ; hprintf0(') << (') ; CppPrintNode(bin.right) ; hprintf0(')') |
         ndshiftright: hprintf0('(') ; CppPrintNode(bin.left) ; hprintf0(') >> (') ; CppPrintNode(bin.right) ; hprintf0(')') |
         nddummy     : CppPrintNode(un.operand) |
         ndsizeof    : hprintf0('sizeof(') ; CppPrintNode(un.operand) ; hprintf0(')') |
         ndnegate    : hprintf0('-(') ; CppPrintNode(un.operand) ; hprintf0(')') |
         ndlnot      : hprintf0('~(') ; CppPrintNode(un.operand) ; hprintf0(')') |
         ndnot       : hprintf0('(!(') ; CppPrintNode(un.operand) ; hprintf0('))') |
         ndconststr,
         ndconstchar,
         nddecint,
         ndoctint,
         ndhexint    : hprintf1('%s', Mark(InitStringCharStar(value))) |
         ndident     : hprintf1('%s', Mark(InitStringCharStar(id.name)))

         ELSE
            ErrorArray('internal error: unknown node type')
         END
      END
   END
END CppPrintNode ;


(*
   EvaluateNode - evaluates and returns the status for node, n.
*)

PROCEDURE EvaluateNode (n: Node) : nodeStatus ;
VAR
   s1, s2: nodeStatus ;
BEGIN
   IF n#NIL
   THEN
      WITH n^ DO
         CASE type OF

         nderror     : RETURN( poisoned ) |
         nddefined   : IF IsItemInList(CompileTimeList, cpp.macro)
                       THEN
                          RETURN( compiled )
                       ELSIF IsMacroDefined(cpp.macro)
                       THEN
                          RETURN( true )
                       ELSE
                          RETURN( false )
                       END |
         ndcast      : RETURN( poisoned ) |
         ndgre       : RETURN( poisoned ) |
         ndless      : RETURN( poisoned ) |
         ndgreequ    : RETURN( poisoned ) |
         ndlessequ   : RETURN( poisoned ) |
         ndequal     : RETURN( poisoned ) |
         ndnotequal  : RETURN( poisoned ) |
         ndor        : s1 := EvaluateNode(bin.left) ;
                       IF s1=true
                       THEN
                          RETURN( true )
                       END ;
                       s2 := EvaluateNode(bin.right) ;
                       IF s2=true
                       THEN
                          RETURN( true )
                       END ;
                       IF (s1=false) AND (s2=false)
                       THEN
                          RETURN( false )
                       END ;
                       IF (s1=poisoned) OR (s2=poisoned)
                       THEN
                          RETURN( poisoned )
                       ELSE
                          RETURN( compiled )
                       END |
         ndand       : s1 := EvaluateNode(bin.left) ;
                       IF s1=false
                       THEN
                          RETURN( false )
                       END ;
                       s2 := EvaluateNode(bin.right) ;
                       IF s2=false
                       THEN
                          RETURN( false )
                       END ;
                       IF (s1=true) AND (s2=true)
                       THEN
                          RETURN( true )
                       END ;
                       IF (s1=poisoned) OR (s2=poisoned)
                       THEN
                          RETURN( poisoned )
                       ELSE
                          RETURN( compiled )
                       END |
         ndarray     : RETURN( poisoned ) |
         ndplus      : RETURN( poisoned ) |
         ndminus     : RETURN( poisoned ) |
         ndmult      : RETURN( poisoned ) |
         nddiv       : RETURN( poisoned ) |
         ndmod       : RETURN( poisoned ) |
         ndshiftleft : RETURN( poisoned ) |
         ndshiftright: RETURN( poisoned ) |
         nddummy     : PrintNode(un.operand, NIL) |
         ndsizeof    : RETURN( poisoned ) |
         ndnegate    : RETURN( poisoned ) |
         ndlnot      : RETURN( poisoned ) |
         ndnot       : s1 := EvaluateNode(un.operand) ;
                       IF s1=true
                       THEN
                          RETURN( false )
                       ELSIF s1=false
                       THEN
                          RETURN( true )
                       ELSE
                          RETURN( s1 )
                       END |
         ndident,
         ndconststr,
         ndconstchar,
         nddecint,
         ndoctint,
         ndhexint    : RETURN( poisoned )

         ELSE
            ErrorArray('internal error: unknown node type')
         END
      END
   END ;
   RETURN( poisoned )
END EvaluateNode ;


(*
   Push - 
*)

PROCEDURE Push (w: WORD) ;
VAR
   e: ExpStack ;
BEGIN
   IF freeExp=NIL
   THEN
      NEW(e)
   ELSE
      e := freeExp ;
      freeExp := freeExp^.next
   END ;
   WITH e^ DO
      next := expStack ;
      value := w ;
   END ;
   expStack := e
END Push ;


(*
   Pop - 
*)

PROCEDURE Pop () : WORD ;
VAR
   e: ExpStack ;
   w: WORD ;
BEGIN
   IF expStack=NIL
   THEN
      ErrorArray('internal error: stack underflow') ;
      w := 0
   ELSE
      e := expStack ;
      w := expStack^.value ;
      expStack := expStack^.next ;
      e^.next := freeExp ;
      freeExp := e
   END ;
   RETURN( w )
END Pop ;


(*
   DisplayNode - 
*)

PROCEDURE DisplayNode (n: Node) ;
BEGIN
   IF n#NIL
   THEN
      CASE n^.type OF

      ndchain  :  hprintf0('ndchain\n') |
      nderror  :  hprintf0('nderror\n') |
      nddefined:  hprintf0('nddefined\n') |
      ndor     :  hprintf0('ndor\n') |
      ndand    :  hprintf0('ndand\n') |
      ndlor    :  hprintf0('ndlor\n') |
      ndland   :  hprintf0('ndland\n') |
      ndlxor   :  hprintf0('ndlxor\n') |
      ndgre    :  hprintf0('ndgre\n') |
      ndless   :  hprintf0('ndless\n') |
      ndgreequ :  hprintf0('ndgreequ\n') |
      ndlessequ:  hprintf0('ndlessequ\n') |
      ndequal  :  hprintf0('ndequal\n') |
      ndnotequal:  hprintf0('ndnotequal\n') |
      ndarray   :  hprintf0('ndarray\n') |
      ndcast    :  hprintf0('ndcast\n') |
      ndplus    :  hprintf0('ndplus\n') |
      ndminus   :  hprintf0('ndminus\n') |
      ndmult    :  hprintf0('ndmult\n') |
      nddiv     :  hprintf0('nddiv\n') |
      ndmod      :  hprintf0('ndmod\n') |
      ndshiftleft:  hprintf0('ndshiftleft\n') |
      ndshiftright:  hprintf0('ndshiftright\n') |
      ndnot       :  hprintf0('ndnot\n') |
      nddummy     :  hprintf0('nddummy\n') |
      ndnegate    :  hprintf0('ndnegate\n') |
      ndsizeof    :  hprintf0('ndsizeof\n') |
      ndlnot      :  hprintf0('ndlnot\n') |
      ndident     :  hprintf1('ndident %s\n', Mark(InitStringCharStar(n^.id.name))) |
      ndconststr  :  hprintf0('ndconststr\n') |
      ndconstchar :  hprintf0('ndconstchar\n') |
      nddecint    :  hprintf0('nddecint\n') |
      ndoctint:  hprintf0('ndoctint\n') |
      ndhexint:  hprintf0('ndhexint\n') |
      ndtypedef:  hprintf0('ndtypedef\n') |
      ndarraytype:  hprintf0('ndarraytype\n') |
      ndenum:  hprintf0('ndenum\n') |
      ndptr:  hprintf0('ndptr\n') |
      ndbase:  hprintf0('ndbase\n') |
      ndenumfield:  hprintf0('ndenumfield\n') |
      ndstructfield:  hprintf0('ndstructfield\n') |
      ndfunc:  hprintf0('ndfunc\n') |
      ndstruct:  hprintf0('ndstruct\n') |
      ndunion:  hprintf0('ndunion\n') |
      ndvararg:  hprintf0('ndvararg\n')

      ELSE
         ErrorArray('unknown node')
      END
   END
END DisplayNode ;


(*
   DisplayStack - 
*)

PROCEDURE DisplayStack ;
VAR
   e: ExpStack ;
BEGIN
   IF Debugging
   THEN
      hprintf0('\nnode stack\n') ;
      e := expStack ;
      WHILE e#NIL DO
         DisplayNode(e^.value) ;
         e := e^.next
      END
   END
END DisplayStack ;


(*
   SafePop - 
*)

PROCEDURE SafePop () : Node ;
BEGIN
   IF expStack#NIL
   THEN
      RETURN( Pop() )
   ELSE
      RETURN( NIL )
   END
END SafePop ;


(*
   AddName - 
*)

PROCEDURE AddName (n: Node; m: Name) ;
BEGIN
   CASE n^.type OF

   nderror     : |
   ndenum      :  n^.en.name := m |
   ndenumfield :  n^.ef.name := m |
   ndstruct    :  n^.str.name := m |
   ndunion     :  n^.uni.name := n |
   ndfunc      :  n^.func.name := m |
   ndbase      :  n^.base.name := m

   ELSE
      ErrorArray('no name associated with this node')
   END
END AddName ;


% declaration h2def begin


(*
   ErrorArray - 
*)

PROCEDURE ErrorArray (a: ARRAY OF CHAR) ;
BEGIN
   ErrorString(InitString(a))
END ErrorArray ;


(*
   ErrorString - 
*)

PROCEDURE ErrorString (s: String) ;
BEGIN
   IF DisplayErrors
   THEN
      clex.CError(string(s))
   END
END ErrorString ;


(*
   SyntaxError - after a syntax error we skip all tokens up until we reach
                 a stop symbol.
*)

PROCEDURE SyntaxError (stopset0: SetOfStop0; stopset1: SetOfStop1; stopset2: SetOfStop2) ;
BEGIN
   PoisonNode := TRUE ;
   IF Debugging
   THEN
      DescribeError(stopset0, stopset1, stopset2)
   END ;
   IF inCpp
   THEN
      WHILE currenttoken#endhashtok DO
         GetToken
      END
   ELSE
      WHILE NOT (((ORD(currenttoken)<32)  AND (currenttoken IN stopset0)) OR
                 ((ORD(currenttoken)>=32) AND (currenttoken IN stopset1)) OR
                 ((ORD(currenttoken)>=64) AND (currenttoken IN stopset2)))
         DO
         GetToken
      END
   END
END SyntaxError ;


(*
   SyntaxCheck - 
*)

PROCEDURE SyntaxCheck (stopset0: SetOfStop0; stopset1: SetOfStop1; stopset2: SetOfStop2) ;
BEGIN
   (* and again (see above re: ORD)
    *)
   IF NOT (((ORD(currenttoken)<32)  AND (currenttoken IN stopset0)) OR
     	   ((ORD(currenttoken)>=32) AND (currenttoken IN stopset1)) OR
     	   ((ORD(currenttoken)>=64) AND (currenttoken IN stopset2)))
   THEN
      SyntaxError(stopset0, stopset1, stopset2)
   END
END SyntaxCheck ;


(*
   WarnMissingToken - generates a warning message about a missing token, t.
*)

PROCEDURE WarnMissingToken (t: toktype) ;
VAR
   s0 : SetOfStop0 ;
   s1 : SetOfStop1 ;
   s2 : SetOfStop2 ;
   str: String ;
BEGIN
   s0 := SetOfStop0{} ;
   s1 := SetOfStop1{} ;
   s2 := SetOfStop2{} ;
   IF ORD(t)<32
   THEN
      s0 := SetOfStop0{t}
   ELSIF ORD(t)<64
   THEN
      s1 := SetOfStop1{t}
   ELSE
      s2 := SetOfStop2{t}
   END ;
   str := DescribeStop(s0, s1, s2) ;
   
   str := ConCat(InitString('syntax error,'), Mark(str)) ;
   ErrorString(str)
END WarnMissingToken ;


(*
   MissingToken - generates a warning message about a missing token, t.
*)

PROCEDURE MissingToken (t: toktype) ;
BEGIN
   WarnMissingToken(t)
END MissingToken ;


(*
   InStopSet 
*)

PROCEDURE InStopSet (t: toktype; stopset0: SetOfStop0; stopset1: SetOfStop1; stopset2: SetOfStop2) : BOOLEAN ;
BEGIN
   IF ((ORD(t)<32) AND (t IN stopset0)) OR
      ((ORD(t)>=32) AND (t IN stopset1)) OR
      ((ORD(t)>=64) AND (t IN stopset2))
   THEN
      RETURN( TRUE )
   ELSE
      RETURN( FALSE )
   END
END InStopSet ;


(*
   Expect - 
*)

PROCEDURE Expect (t: toktype; stopset0: SetOfStop0; stopset1: SetOfStop1; stopset2: SetOfStop2) ;
BEGIN
   IF currenttoken=t
   THEN
      GetToken
   ELSE
      MissingToken(t)
   END ;
   SyntaxCheck(stopset0, stopset1, stopset2)
END Expect ;


(*
   CompilationUnit - parses the source file.
*)

PROCEDURE CompilationUnit ;
BEGIN
   FileUnit({eoftok}, {}, {})
END CompilationUnit ;


(*
   Ident - error checking varient of Ident
*)

PROCEDURE Ident (stopset0: SetOfStop0; stopset1: SetOfStop1; stopset2: SetOfStop2) ;
BEGIN
   LastIdent := currentstring ;
   Expect(identtok, stopset0, stopset1, stopset2)
END Ident ;


(*
   TypeDefName - is an ident which has already been defined as a type.
*)

PROCEDURE TypeDefName (stopset0: SetOfStop0; stopset1: SetOfStop1; stopset2: SetOfStop2) ;
BEGIN
   LastIdent := currentstring ;
   Expect(typetok, stopset0, stopset1, stopset2)
END TypeDefName ;


(*
   strconstant -
*)

PROCEDURE strconstant (stopset0: SetOfStop0; stopset1: SetOfStop1; stopset2: SetOfStop2) ;
BEGIN
   LastStr := currentstring ;
   Expect(conststringtok, stopset0, stopset1, stopset2)
END strconstant ;


(*
   charconstant -
*)

PROCEDURE charconstant (stopset0: SetOfStop0; stopset1: SetOfStop1; stopset2: SetOfStop2) ;
BEGIN
   LastChar := currentstring ;
   Expect(constchartok, stopset0, stopset1, stopset2)
END charconstant ;


(*
   DecimalInteger -
*)

PROCEDURE DecimalInteger (stopset0: SetOfStop0; stopset1: SetOfStop1; stopset2: SetOfStop2) ;
BEGIN
   LastInt := currentstring ;
   Expect(integertok, stopset0, stopset1, stopset2)
END DecimalInteger ;


(*
   OctalInteger -
*)

PROCEDURE OctalInteger (stopset0: SetOfStop0; stopset1: SetOfStop1; stopset2: SetOfStop2) ;
BEGIN
   LastInt := currentstring ;
   Expect(octintegertok, stopset0, stopset1, stopset2)
END OctalInteger ;


(*
   HexInteger -
*)

PROCEDURE HexInteger (stopset0: SetOfStop0; stopset1: SetOfStop1; stopset2: SetOfStop2) ;
BEGIN
   LastInt := makekey(string(Sprintf1(Mark(InitString('%d')), hstoi(Slice(InitStringCharStar(currentstring), 2, 0))))) ;
   Expect(hexintegertok, stopset0, stopset1, stopset2)
END HexInteger ;


(*
   Real -
*)

PROCEDURE Real (stopset0: SetOfStop0; stopset1: SetOfStop1; stopset2: SetOfStop2) ;
BEGIN
   LastReal := currentstring ;
   Expect(realtok, stopset0, stopset1, stopset2)
END Real ;


% module h2def end

(*
   OpenOutputFile - attempts to open an output file.
*)

PROCEDURE OpenOutputFile (s: String) ;
BEGIN
   IF EqualArray(s, '-')
   THEN
      op := StdOut
   ELSE
      op := OpenToWrite(s) ;
      IF NOT IsNoError(op)
      THEN
         fprintf1(StdErr, 'cannot write to: %s\n', s) ;
         exit(1)
      END
   END
END OpenOutputFile ;


(*
   BaseName - returns a new string containing the base name of file, s.
*)

PROCEDURE BaseName (s: String) : String ;
VAR
   i: INTEGER ;
BEGIN
   i := RIndex(s, '/', 0) ;
   IF i>0
   THEN
      s := Slice(s, i+1, 0)
   END ;
   i := Index(s, '.', 0) ;
   IF i>0
   THEN
      RETURN( Slice(s, 0, i) )
   ELSE
      RETURN( Dup(s) )
   END
END BaseName ;


(*
   GetDirectory - strips the directory component of, s.
*)

PROCEDURE GetDirectory (s: String) : String ;
VAR
   i: INTEGER ;
BEGIN
   i := RIndex(s, '/', 0) ;
   IF i=-1
   THEN
      RETURN( InitString('./') )
   ELSE
      RETURN( Slice(s, i+1, 0) )
   END
END GetDirectory ;


(*
   Usage - 
*)

PROCEDURE Usage ;
BEGIN
   printf0('Usage: h2def [-h] [-Ddefinedsymbol [-Cresolveatcompiletime] [-Isearchpath] [-o outputfile] includefile\n') ;
   printf0('       -Dsymbol            define symbol\n') ;
   printf0('       -Csymbol            set symbol to be resolved at compile time\n') ;
   printf0('       -o outputfile       write output to outputfile, use stdout if outputfile is -\n') ;
   exit(0)
END Usage ;


(*
   ParseArgs - parses the arguments and then calls the main program.
*)

PROCEDURE ParseArgs ;
VAR
   CurrentArg: CARDINAL ;
   args,
   s,
   OutputFile: String ;
BEGIN
   op := StdOut ;
   args := InitString('') ;
   CurrentArg := 1 ;
   IF Narg()>1
   THEN
      WHILE GetArg(s, CurrentArg) DO
         args := ConCat(args, Mark(ConCatChar(Dup(s), ' '))) ;
         IF EqualArray(Slice(s, 0, 2), '-I')
         THEN
            CurrentUserPath := ConCat(ConCatChar(CurrentUserPath, ':'), Slice(s, 2, 0)) ;
            clex.SetSearchPath(string(ConCat(ConCatChar(CurrentUserPath, ':'), SystemPath)))
         ELSIF EqualArray(s, '-o')
         THEN
            INC(CurrentArg) ;
            IF NOT GetArg(OutputFile, CurrentArg)
            THEN
               printf0('-o expecting an output file\n') ;
               exit(1)
            END ;
            OpenOutputFile(OutputFile)
         ELSIF EqualArray(Slice(s, 0, 2), '-D')
         THEN
            DefineMacro(makekey(string(Slice(s, 2, 0))), 0)
         ELSIF EqualArray(Slice(s, 0, 2), '-C')
         THEN
            IncludeItemIntoList(CompileTimeList, makekey(string(Slice(s, 2, 0))))
         ELSIF EqualArray(Slice(s, 0, 2), '-d')
         THEN
            Debugging := TRUE
         ELSIF EqualArray(Slice(s, 0, 2), '-p')
         THEN
            DisplayPoison := TRUE
         ELSIF EqualArray(Slice(s, 0, 2), '-e')
         THEN
            DisplayErrors := TRUE
         ELSIF EqualArray(Slice(s, 0, 2), '-a')
         THEN
            UseArrayInParameters := TRUE
         ELSIF EqualArray(s, '-h')
         THEN
            Usage
         ELSE
            IF OpenSource(s)
            THEN
               CurrentDirectory := GetDirectory(s) ;
               fprintf1(op, '(* automatically generated for GNU Modula-2 by:\n   h2def %s\n*)\n', args) ;
               fprintf1(op, 'DEFINITION MODULE FOR "C" %s ;\n\n', Mark(BaseName(s))) ;
               CompilationUnit ;
               fprintf1(op, '\nEND %s.\n', Mark(BaseName(s)))
            ELSE
               fprintf1(StdErr, 'h2def: cannot find %s\n', s)
            END
         END ;
         s := KillString(s) ;
         INC(CurrentArg)
      END
   ELSE
      Usage
   END
END ParseArgs ;


(*
   Init - initializes the data structures and calls ParseArgs
*)

PROCEDURE Init ;
BEGIN
   CurrentUserPath := InitString('') ;
   SystemPath := InitString('/usr/include') ;
   clex.SetSearchPath(string(SystemPath)) ;
   UseArrayInParameters := FALSE ;
   DisplayErrors := FALSE ;
   DisplayPoison := FALSE ;
   PoisonNode := FALSE ;
   inCpp := FALSE ;
   FreeList := NIL ;
   emitting := nothing ;
   cppStack := NIL ;
   freeCpp := NIL ;
   expStack := NIL ;
   freeExp := NIL ;
   freeIndent := NIL ;
   indentStack := NIL ;
   Debugging := FALSE ;
   InitList(PoisonedList) ;
   InitList(CompileTimeList) ;
   InitList(ToDoList) ;
   InitList(DoneList) ;
   InitList(ConstList) ;
   Indent := 0 ;
   CurColumn := 0 ;
   ParseArgs
END Init ;


BEGIN
   Init
END h2def.
% rules
error       'ErrorArray' 'ErrorString'
tokenfunc   'currenttoken'

token   ''                eoftok      -- internal token
token   '*'               startok
token   '->'              arrowtok
token   'struct'          structtok
token   '['               lsbratok
token   ']'               rsbratok
token   '{'               lcbratok
token   '}'               rcbratok
token   '('               lparatok
token   ')'               rparatok
token   ';'               semicolontok
token   'long'            longtok
token   'int'             inttok
token   'char'            chartok
token   'enum'            enumtok
token   'typedef'         typedeftok
token   'float'           floattok
token   'double'          doubletok
token   'unsigned'        unsignedtok
token   'const'           consttok
token   '...'             periodperiodperiodtok
token   'integer number'  integertok
token   'hexadecimal number' hexintegertok
token   'octal number'    octintegertok
token   'identifier'      identtok
token   'real number'     realtok
token   'constant string' conststringtok
token   'constant char'   constchartok
token   'some C code'     codetok
token   'start#'          starthashtok
token   'end#'            endhashtok
token   'define'          definetok
token   'undef'           undeftok
token   'if'              iftok
token   'else'            elsetok
token   'endif'           endiftok
token   'ifdef'           ifdeftok
token   'ifndef'          ifndeftok
token   'include'         includetok
token   '!'               nottok
token   ','               commatok
token   '.'               periodtok
token   '>'               gretok
token   '<'               lesstok
token   '||'              ortok
token   '&&'              andtok
token   '|'               bartok
token   '&'               ambersandtok
token   '<<'              shiftlefttok
token   '>>'              shiftrighttok
token   '/'               divtok
token   '%'               modtok
token   'sizeof'          sizeoftok
token   'defined'         definedtok
token   '^'               hattok
token   '=='              equaltok
token   '!='              notequaltok
token   '>='              greequaltok
token   '<='              lessequaltok
token   '+'               plustok
token   '-'               minustok
token   '~'               tildetok
token   'extern'          externtok
token   'static'          statictok
token   'auto'            autotok
token   'register'        registertok
token   'void'            voidtok
token   'short'           shorttok
token   'signed'          signedtok
token   'union'           uniontok
token   ':'               colontok
token   '='               becomestok
token   'volatile'        volatiletok
token   'defined type'    typetok

special Ident             first { < identtok > } follow { }
special TypeDefName       first { < typetok > } follow { }
special DecimalInteger    first { < integertok > } follow { }
special OctalInteger      first { < octintegertok > } follow { }
special HexInteger        first { < hexintegertok > } follow { }
special Real              first { < realtok > } follow { }
special strconstant       first { < conststringtok > } follow { }
special charconstant      first { < constchartok > } follow { }

BNF

FileUnit := { CppLine | TranslationUnit } =:

CppLine := 'start#'                                               % inCpp := TRUE %
           ( define | undef | if | ifdef | ifndef |
             else | endif | "include" ) 'end#'                    % inCpp := FALSE %
        =:

define := 'define'                                                % VAR t: CARDINAL ; %
                                                                  % PoisonNode := FALSE %
                                                                  % EnableMacroSubstitutions(FALSE) %
              Ident                                               % t := GetTokenNo() %
                                                                  % IncludeItemIntoList(ConstList, makekey(LastIdent)) %
                                                                  % IF currenttoken=endhashtok
                                                                    THEN
                                                                       t := 0
                                                                    END %
                    ( DefinedConstExpression
                                             |                    % WHILE currenttoken#endhashtok DO
                                                                       GetToken
                                                                    END %
                    )
                                                                  % DefineMacro(LastIdent, t) ;
                                                                    EnableMacroSubstitutions(TRUE) %
          =:

undef := 'undef' Ident                                            % BuildUndef %
       =:
if    := 'if' ConstExpression                                     % BuildIf %
       =:
ifdef := 'ifdef' Ident                                            % BuildIfDef(TRUE) %
       =:
ifndef := 'ifndef' Ident                                          % BuildIfDef(FALSE) %
        =:
else := 'else'                                                    % BuildElse %
       =:
endif := 'endif'                                                  % BuildEndIf %
       =:

TranslationUnit := { ExternalDeclaration }
                 =:

ExternalDeclaration := DeclarationSpecifiers                      % VAR n: Node ; %
                                                                  % n := Pop() ;
                                                                    Push(n) %
                                                                    
                           [ Declarator                           % ChainTopTwoIdent ;
                                                                    PrintCNode(Pop()) ; hprintf0(' ;\n') %
                                        { ','                     % Push(n) %
                                              Declarator          % ChainTopTwoIdent ;
                                                                    PrintCNode(Pop()) ; hprintf0(' ;\n') %
                                                         } ]    
                       ';' =:

DeclarationSpecifiers :=
                         DeclarationSpecifier
                                     { DeclarationSpecifier       % ChainTopTwo %
                                     }
                       =:

DeclarationSpecifier := StorageClassSpecifier | TypeSpecifier | TypeQualifier =:

StorageClassSpecifier :=
	  "typedef"                                               % Push(InitNode(ndtypedef)) %
	| "extern"                                                % Push(InitNode(nddummy)) %
	| "static"                                                % Push(MakeBaseNode(MakeKey('static'))) %
	| "auto"                                                  % Push(InitNode(nddummy)) %
	| "register"                                              % Push(InitNode(nddummy)) %
                       =:

TypeSpecifier :=
          "void"                                                  % Push(MakeBaseNode(MakeKey('void'))) %
        | "char"                                                  % Push(MakeBaseNode(MakeKey('char'))) %
        | "short"                                                 % Push(MakeBaseNode(MakeKey('short'))) %
        | "int"                                                   % Push(MakeBaseNode(MakeKey('int'))) %
        | "long"                                                  % Push(MakeBaseNode(MakeKey('long'))) %
        | "float"                                                 % Push(MakeBaseNode(MakeKey('float'))) %
        | "double"                                                % Push(MakeBaseNode(MakeKey('double'))) %
        | "signed"                                                % Push(MakeBaseNode(MakeKey('signed'))) %
        | "unsigned"                                              % Push(MakeBaseNode(MakeKey('unsigned'))) %
        | StructOrUnionSpecifier
        | EnumSpecifier
        | TypeDefName                                             % Push(MakeBaseNode(LastIdent)) %
               =:


StructOrUnionSpecifier := StructOrUnion Specifier
                        =:

Specifier := Ident                                                % VAR n1, n2: Node ; %
                                                                  % n1 := Pop() ;
                                                                    AddName(n1, LastIdent) ;
                                                                    Push(n1) %
                   [ '{' StructDeclarationList '}'                % AddNodeToList(n1, Pop()) %
                   ]
             | '{' StructDeclarationList '}'                      % AddNodeToList(n1, Pop()) %
           =:

StructOrUnion := "struct"                                         % Push(InitNode(ndstruct)) %
                 | "union"                                        % Push(InitNode(ndunion)) %
               =:

StructDeclarationList := StructDeclaration { StructDeclaration    % ChainTopTwo %
                                           } =:

StructDeclaration := SpecifierQualifierList
                     StructDeclaratorList                         % VAR n: Node ; %
                                                                  % n := InitNode(ndstructfield) ;
                                                                    n^.esf.decl := Pop() ;
                                                                    n^.esf.type := Pop() ;
                                                                    Push(n) %
                     ';'
                   =:

SpecifierQualifierList := SpecifierList | QualifierList =:

SpecifierList := TypeSpecifier { TypeSpecifier                    % ChainTopTwo %
                               } =:

QualifierList := TypeQualifier { TypeQualifier                    % ChainTopTwo %
                               } =:

StructDeclaratorList := StructDeclarator                          % InitChain %
                                         { "," StructDeclarator   % ChainOn %
                                         } =:

StructDeclarator :=
                    ':' ConstantExpression                        % VAR n: Node ; %
                                                                  % n := Pop() ;
                                                                    Push(Poison(Pop())) %
                    | Declarator [ ':' ConstantExpression         % n := Pop() ;
                                                                    Push(Poison(Pop())) %
                                 ]
                  =:

EnumSpecifier := 'enum'                                           % Push(InitNode(ndenum)) %
                        ( Ident                                   % VAR n: Node ; %
                                                                  % n := Pop() ; n^.en.name := LastIdent ;
                                                                    Push(n) %
                                [ '{' EnumeratorList              % AddNodeToList(n, Pop()) %
                                  '}' ] |
                        '{' EnumeratorList                        % AddNodeToList(n, Pop()) %
                        '}' ) =:

EnumeratorList := Enumerator
                             { ',' Enumerator                     % ChainTopTwo %
                             } =:

Enumerator := Ident                                               % VAR n: Node ; %
                                                                  % Push(InitNode(ndenumfield)) %
                                                                  % n := Pop() ;
                                                                    n^.ef.name := LastIdent ;
                                                                    Push(n) %
                    [ '='                                         % n := Poison(n) %
                          ConstantExpression                      % n := Pop() %
                    ] =:

TypeQualifier := 'const'                                          % Push(InitNode(nddummy)) %
               | 'volatile'                                       % Push(InitNode(nddummy)) %
               =:

Declarator := Pointer [ DirectDeclarator                          % ChainTopTwoIdent %
                                         ]
              | DirectDeclarator =:

DirectDeclarator := DirectDeclaratorBeta { DirectDeclaratorAlpha
                                         }
                  =:

DirectDeclaratorBeta := Ident                                     % VAR n, m: Node ; %
                                                                  % n := InitNode(ndident) ;
                                                                    n^.id.name := LastIdent ;
                                                                    n^.id.type := NIL ;
                                                                    Push(n) ;
                                                                    (* hprintf1('might be type %s\n', Mark(InitStringCharStar(KeyToCharStar(LastIdent)))) *) %
                             | '(' Declarator ')' =:

DirectDeclaratorAlpha :=   '['                                    % VAR n, t, i: Node ; %
                                                                  % n := InitNode(ndarraytype) ;
                                                                    i := Pop() ;  (* the ident *)
                                                                    n^.max := NIL ;
                                                                    Push(n) ;
                                                                    Push(i) %
                               [ ConstantExpression               % n^.max := Pop() %
                                                    ]             % ChainTopTwoIdent %
                                                      ']' |
                           '('
                                                                  % DisplayStack ;
                                                                    i := Pop() ;
                                                                    t := Pop() ;
                                                                    IF i^.type#ndident
                                                                    THEN
                                                                       ErrorArray('internal error: expecting ident')
                                                                    END %
                               [ ParameterTypeList                % n := InitNode(ndfunc) ;
                                                                    n^.func.type := t ;
                                                                    n^.func.list := Pop() %
                                                   ]              % Push(InitNode(nddummy)) ;
                                                                    Push(n) ;
                                                                    Push(i) ;
                                                                    ChainTopTwoIdent %
                                                     ')'
                       =:

Pointer := '*'                                                    % Push(InitNode(ndptr)) %
               { '*'                                              % Push(InitNode(ndptr)) ;
                                                                    ChainTopTwo %
                     | TypeQualifier                              % ChainTopTwo %
               } =:

TypeQualifierList := TypeQualifier { TypeQualifier                % ChainTopTwo %
                                   } =:

ParameterTypeList := ParameterDeclaration                         % InitChain %
                     { ',' ( ParameterDeclaration                 % ChainOn %
                                                  | '...'         % Push(InitNode(ndvararg)) ;
                                                                    ChainOn %
                                                          ) }
                   =:

AbstractDeclarator := DirectDeclarator =:

ParameterDeclaration := DeclarationSpecifiers
                              [ Declarator                        % ChainTopTwoIdent (* was DirectDeclarator *) %
                              ] =:

IdentifierList := Ident                                           % Push(MakeValueNode(ndident, LastIdent)) %
                        { ',' Ident                               % Push(MakeValueNode(ndident, LastIdent)) ;
                                                                    ChainTopTwo %
                        } =:

TypeName := SpecifierQualifierList [ AbstractDeclarator           % ChainTopTwo %
                                   ] =:

-- expression rules below

ConstantExpression := ConstExpression =:

DefinedConstExpression :=                                         % VAR constName: ADDRESS ;
                                                                        t        : CARDINAL ;
                                                                        n        : Node ; %
                                                                  % constName := LastIdent ;
                                                                    t := GetTokenNo() %
                          ConstExpression                         % n := Pop() ;
                                                                    IF IsPoisoned(n)
                                                                    THEN
                                                                       DefineMacro(makekey(constName), t)
                                                                    ELSE
                                                                       BuildConst(constName, n)
                                                                    END %
                       =:

ConstExpression := LogicalOrExpression =: 

LogicalOrExpression := LogicalAndExpression
                       { '||' LogicalAndExpression                % Push(MakeBinaryNode(ndor, Pop(), Pop())) %
                       } =:

LogicalAndExpression := InclusiveOrExpression
                        { '&&' InclusiveOrExpression              % Push(MakeBinaryNode(ndand, Pop(), Pop())) %
                        } =:

InclusiveOrExpression := ExclusiveOrExpression
                         { '|' ExclusiveOrExpression              % Push(MakeBinaryNode(ndlor, Pop(), Pop())) %
                         } =:

ExclusiveOrExpression := AndExpression
                         { '^' AndExpression                      % Push(MakeBinaryNode(ndlxor, Pop(), Pop())) %
                         } =:

AndExpression := EqualityExpression
                 { '&' EqualityExpression                         % Push(MakeBinaryNode(ndland, Pop(), Pop())) %
                 } =:

EqualityExpression := RelationalExpression
                      { EqualityOperator RelationalExpression     % VAR l: Node ; nd: nodeType ; %
                                                                  % l := Pop() ;
                                                                    nd := VAL(nodeType, Pop()) %
                                                                  % Push(MakeBinaryNode(nd, l, Pop())) %
                      } =:

EqualityOperator := '=='                                          % Push(ndequal) %
                 | '!='                                           % Push(ndnotequal) %
                  =:

RelationalExpression := ShiftExpression
                        { RelationalOperator ShiftExpression      % VAR l: Node ; nd: nodeType ; %
                                                                  % l := Pop() ;
                                                                    nd := VAL(nodeType, Pop()) %
                                                                  % Push(MakeBinaryNode(nd, l, Pop())) %
                        } =:

RelationalOperator := '>'                                         % Push(ndgre) %
                      | '<'                                       % Push(ndless) %
                      | '>='                                      % Push(ndgreequ) %
                      | '<='                                      % Push(ndlessequ) %
                   =:

ShiftExpression := AdditiveExpression
                   { ShiftOperator AdditiveExpression             % VAR l: Node ; nd: nodeType ; %
                                                                  % l := Pop() ;
                                                                    nd := VAL(nodeType, Pop()) %
                                                                  % Push(MakeBinaryNode(nd, l, Pop())) %
                   } =:

ShiftOperator := '<<'                                             % Push(ndshiftleft) %
                 | '>>'                                           % Push(ndshiftright) %
               =:

AdditiveExpression := MultiplicativeExpression
                      { AddOperator MultiplicativeExpression      % VAR l: Node ; nd: nodeType ; %
                                                                  % l := Pop() ;
                                                                    nd := VAL(nodeType, Pop()) %
                                                                  % Push(MakeBinaryNode(nd, l, Pop())) %
                      } =:

AddOperator := '+'                                                % Push(ndplus) %
             | '-'                                                % Push(ndminus) %
             =:

MultiplicativeExpression := CastExpression
                            { MultOperator CastExpression         % VAR l: Node ; nd: nodeType ; %
                                                                  % l := Pop() ;
                                                                    nd := VAL(nodeType, Pop()) %
                                                                  % Push(MakeBinaryNode(nd, l, Pop())) %
                            } =:

MultOperator := '*'                                               % Push(ndmult) %
              | '/'                                               % Push(nddiv) %
              | '%'                                               % Push(ndmod) %
              =:

CastExpression := '('
                     ( TypeName ')' UnaryExpression               % VAR n: Node ; %
                                                                  % n := Pop() ;
                                                                    Push(MakeBinaryNode(ndcast, Pop(), n)) %
                       | ConstExpression ')' )
                | UnaryExpression
                =:

UnaryExpression := PostfixExpression |
                   UnaryOperator CastExpression                   % VAR nd: nodeType ;
                                                                         n: Node ; %
                                                                  % n := Pop() ;
                                                                    nd := VAL(nodeType, Pop()) %
                                                                  % Push(MakeUnaryNode(nd, n)) %
                   | SizeofExpression
                   | DefinedExpression
                   =:

DefinedExpression :=  'defined' ( '(' Ident ')'                   % Push(MakeCppNode(nddefined, LastIdent)) %
                                | Ident                           % Push(MakeCppNode(nddefined, LastIdent)) %
                                )
                   =:

SizeofExpression := 'sizeof' UnaryExpOrTypeName                   % Push(MakeUnaryNode(ndsizeof, Pop())) %
                  =:

UnaryExpOrTypeName := UnaryExpression | '(' TypeName ')' =:

UnaryOperator := '+'                                              % Push(nddummy) %
                 | '-'                                            % Push(ndnegate) %
                 | '~'                                            % Push(ndlnot) %
                 | '!'                                            % Push(ndnot) %
               =:

PostfixExpression := PrimaryExpression
                     { '[' ConstExpression ']'                    % VAR n: Node ; %
                                                                  % n := Pop() ;
                                                                    Push(MakeBinaryNode(ndarray, Pop(), n)) %
                     } =:

PrimaryExpression := Ident                                        % Push(MakeValueNode(ndident, LastIdent)) %
                   | IntegerConstant
                   | charconstant                                 % Push(MakeValueNode(ndconstchar, LastChar)) %
                   | strconstant                                  % Push(MakeValueNode(ndconststr, LastStr)) %
                   =:

IntegerConstant := DecimalInteger                                 % Push(MakeValueNode(nddecint, LastInt)) %
                 | OctalInteger                                   % Push(MakeValueNode(ndoctint, LastInt)) %
                 | HexInteger                                     % Push(MakeValueNode(ndhexint, LastInt)) %
                 =:

EnumerationConstant := Ident =:

FNB
