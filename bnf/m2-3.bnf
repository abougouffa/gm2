-- Copyright (C) 2001 Free Software Foundation, Inc.
-- This file is part of GNU Modula-2.
--
-- GNU Modula-2 is free software; you can redistribute it and/or modify it under
-- the terms of the GNU General Public License as published by the Free
-- Software Foundation; either version 2, or (at your option) any later
-- version.
-- 
-- GNU Modula-2 is distributed in the hope that it will be useful, but WITHOUT ANY
-- WARRANTY; without even the implied warranty of MERCHANTABILITY or
-- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-- for more details.
-- 
-- You should have received a copy of the GNU General Public License along
-- with gm2; see the file COPYING.  If not, write to the Free Software
-- Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
--
--
--
-- the ebnf grammer for Modula-2 together with actions for pass 3.
-- pg takes this file and produces a top down parser for Modula-2.
-- The only difference between this grammer and P1 P2 grammer is that
-- we have introduced SilentConstExpr which allows us to parse
-- (with no actions varient record declarations (CASE))
-- and parse with actions constant declarations.
--
% module P3Build begin
(* Copyright (C) 2001 Free Software Foundation, Inc.
   This file is part of GNU Modula-2.

GNU Modula-2 is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2, or (at your option) any later
version.
 
GNU Modula-2 is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.
 
You should have received a copy of the GNU General Public License along
with gm2; see the file COPYING.  If not, write to the Free Software
Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)
IMPLEMENTATION MODULE P3Build ;

FROM M2LexBuf IMPORT currentstring, currenttoken, GetToken, InsertToken, InsertTokenAndRewind, GetTokenNo ;
FROM M2Error IMPORT ErrorStringAt, WriteFormat1, WriteFormat2 ;
FROM NameKey IMPORT NulName, Name ;
FROM Strings IMPORT String, InitString, KillString, Mark, ConCat, ConCatChar ;
FROM M2Printf IMPORT printf0 ;
FROM M2Debug IMPORT Assert ;
FROM P2SymBuild IMPORT BuildString, BuildNumber ;

FROM M2Reserved IMPORT tokToTok, toktype,
                       NulTok, ImportTok, ExportTok, QualifiedTok, UnQualifiedTok,
                       EqualTok, HashTok, LessGreaterTok, LessTok, LessEqualTok,
                       GreaterTok, GreaterEqualTok, InTok, PlusTok, MinusTok,
                       OrTok, TimesTok, DivTok, ModTok, AndTok, AmbersandTok ;

FROM M2Quads IMPORT PushT, PopT, PushTF, PopTF, PopNothing,
                    StartBuildDefFile, StartBuildModFile,
                    EndBuildFile,
                    StartBuildInit,
                    EndBuildInit,
                    BuildProcedureStart,
                    BuildProcedureEnd,
                    BuildAssignment,
      	       	    BuildLineNo,
                    BuildFunctionCall,
                    BuildBinaryOp, BuildUnaryOp, BuildRelOp, BuildNot,
      	       	    BuildEmptySet, BuildInclRange, BuildInclBit,
                    BuildBitsetStart, BuildSetEnd,
                    BuildLineNo, BuildSizeCheckStart,
                    BuildBuiltinConst,
                    BuildAssignment,
                    BuildRepeat, BuildUntil,
                    BuildWhile, BuildDoWhile, BuildEndWhile,
                    BuildLoop, BuildExit, BuildEndLoop,
                    BuildThenIf, BuildElse, BuildEndIf,
                    BuildForToByDo, BuildPseudoBy, BuildEndFor,
                    BuildElsif1, BuildElsif2,
                    BuildProcedureCall, BuildReturn, BuildNulExpression,
                    StartBuildWith, EndBuildWith,
                    BuildInline,
                    BuildCaseStart,
                    BuildCaseOr,
                    BuildCaseElse,
                    BuildCaseEnd,
                    BuildCaseStartStatementSequence,
                    BuildCaseEndStatementSequence,
                    BuildCaseList,
                    BuildCaseRange, BuildCaseEquality,
                    RecordOp,
                    BuildNulParam,
                    BuildDesignatorRecord,
                    BuildDesignatorArray,
                    BuildDesignatorPointer,
                    BuildBooleanVariable,
                    CheckWithReference,
                    CheckOuterScopeProcedureVariable,
                    DumpStack,
                    IsAutoPushOn, PushAutoOff, PushAutoOn, PopAuto ;

FROM P3SymBuild IMPORT P3StartBuildProgModule,
                       P3EndBuildProgModule,

                       P3StartBuildDefModule,
                       P3EndBuildDefModule,

                       P3StartBuildImpModule,
                       P3EndBuildImpModule,

                       StartBuildInnerModule,
                       EndBuildInnerModule,

                       StartBuildProcedure,
                       BuildProcedureHeading,
                       EndBuildProcedure,
                       BuildConst,
                       BuildSubrange,
                       BuildNulName ;

FROM SymbolTable IMPORT MakeGnuAsm, PutGnuAsmVolatile, PutGnuAsm, PutGnuAsmInput,
                        PutGnuAsmOutput, PutGnuAsmTrash, PutGnuAsmVolatile,
                        MakeRegInterface,
                        PutRegInterface,
                        GetSymName, GetType,
                        NulSym,
                        StartScope, EndScope,
                        PutIncluded,
                        IsVarParam, IsProcedure, IsDefImp, IsModule,
                        IsRecord,
                        RequestSym,
                        GetSym, GetLocalSym,
                        RequestSym ;

FROM M2Batch IMPORT IsModuleKnown ;


CONST
   Debugging = FALSE ;
   Pass1     = FALSE ;          (* permanently disabled for the time being *)
   Pass2     =  TRUE ;
   Pass3     = FALSE ;          (* permanently disabled for the time being *)

VAR
   WasNoError: BOOLEAN ;


PROCEDURE ErrorString (s: String) ;
BEGIN
   ErrorStringAt(s, GetTokenNo()) ;
   WasNoError := FALSE
END ErrorString ;


PROCEDURE ErrorArray (a: ARRAY OF CHAR) ;
BEGIN
   ErrorString(InitString(a))
END ErrorArray ;


% declaration P3Build begin


(*
   SyntaxError - after a syntax error we skip all tokens up until we reach
                 a stop symbol.
*)

PROCEDURE SyntaxError (stopset0: SetOfStop0; stopset1: SetOfStop1; stopset2: SetOfStop2) ;
BEGIN
   DescribeError(stopset0, stopset1, stopset2) ;
   IF Debugging
   THEN
      printf0('\nskipping token *** ')
   END ;
   (*
      yes the ORD(currenttoken) looks ugly, but it is *much* safer than
      using currenttoken<sometok as a change to the ordering of the
      token declarations below would cause this to break. Using ORD() we are
      immune from such changes
   *)
   WHILE NOT (((ORD(currenttoken)<32)  AND (currenttoken IN stopset0)) OR
              ((ORD(currenttoken)>=32) AND (ORD(currenttoken)<64) AND (currenttoken IN stopset1)) OR
              ((ORD(currenttoken)>=64) AND (currenttoken IN stopset2)))
   DO
      GetToken
   END ;
   IF Debugging
   THEN
      printf0(' ***\n')
   END
END SyntaxError ;


(*
   SyntaxCheck - 
*)

PROCEDURE SyntaxCheck (stopset0: SetOfStop0; stopset1: SetOfStop1; stopset2: SetOfStop2) ;
BEGIN
   (* and again (see above re: ORD)
    *)
   IF NOT (((ORD(currenttoken)<32)  AND (currenttoken IN stopset0)) OR
     	   ((ORD(currenttoken)>=32) AND (ORD(currenttoken)<64) AND (currenttoken IN stopset1)) OR
           ((ORD(currenttoken)>=64) AND (currenttoken IN stopset2)))
   THEN
      SyntaxError(stopset0, stopset1, stopset2)
   END
END SyntaxCheck ;


(*
   WarnMissingToken - generates a warning message about a missing token, t.
*)

PROCEDURE WarnMissingToken (t: toktype) ;
VAR
   s0 : SetOfStop0 ;
   s1 : SetOfStop1 ;
   s2 : SetOfStop2 ;
   str: String ;
BEGIN
   s0 := SetOfStop0{} ;
   s1 := SetOfStop1{} ;
   s2 := SetOfStop2{} ;
   IF ORD(t)<32
   THEN
      s0 := SetOfStop0{t}
   ELSIF ORD(t)<64
   THEN
      s1 := SetOfStop1{t}
   ELSE
      s2 := SetOfStop2{t}
   END ;
   str := DescribeStop(s0, s1, s2) ;
   
   str := ConCat(InitString('syntax error,'), Mark(str)) ;
   ErrorStringAt(str, GetTokenNo())
END WarnMissingToken ;


(*
   MissingToken - generates a warning message about a missing token, t.
*)

PROCEDURE MissingToken (t: toktype) ;
BEGIN
   WarnMissingToken(t) ;
   IF (t#identtok) AND (t#integertok) AND (t#realtok) AND (t#stringtok)
   THEN
      IF Debugging
      THEN
         printf0('inserting token\n')
      END ;
      InsertToken(t)
   END
END MissingToken ;


(*
   CheckAndInsert - 
*)

PROCEDURE CheckAndInsert (t: toktype; stopset0: SetOfStop0; stopset1: SetOfStop1; stopset2: SetOfStop2) : BOOLEAN ;
BEGIN
   IF ((ORD(t)<32) AND (t IN stopset0)) OR
      ((ORD(t)>=32) AND (ORD(t)<64) AND (t IN stopset1)) OR
      ((ORD(t)>=64) AND (t IN stopset2))
   THEN
      WarnMissingToken(t) ;
      InsertTokenAndRewind(t) ;
      RETURN( TRUE )
   ELSE
      RETURN( FALSE )
   END
END CheckAndInsert ;


(*
   InStopSet 
*)

PROCEDURE InStopSet (t: toktype; stopset0: SetOfStop0; stopset1: SetOfStop1; stopset2: SetOfStop2) : BOOLEAN ;
BEGIN
   IF ((ORD(t)<32) AND (t IN stopset0)) OR
      ((ORD(t)>=32) AND (ORD(t)<64) AND (t IN stopset1)) OR
      ((ORD(t)>=64) AND (t IN stopset2))
   THEN
      RETURN( TRUE )
   ELSE
      RETURN( FALSE )
   END
END InStopSet ;


(*
   PeepToken - peep token checks to see whether the stopset is satisfied by currenttoken
               If it is not then it will insert a token providing the token
               is one of ; ] ) } . OF END ,

               if the stopset contains <identtok> then we do not insert a token
*)

PROCEDURE PeepToken (stopset0: SetOfStop0; stopset1: SetOfStop1; stopset2: SetOfStop2) ;
BEGIN
   (* and again (see above re: ORD)
    *)
   IF (NOT (((ORD(currenttoken)<32)  AND (currenttoken IN stopset0)) OR
     	    ((ORD(currenttoken)>=32) AND (ORD(currenttoken)<64) AND (currenttoken IN stopset1)) OR
            ((ORD(currenttoken)>=64) AND (currenttoken IN stopset2)))) AND
      (NOT InStopSet(identtok, stopset0, stopset1, stopset2))
   THEN
      (* SyntaxCheck would fail since currentoken is not part of the stopset
         we check to see whether any of currenttoken might be a commonly omitted token *)
      IF CheckAndInsert(semicolontok, stopset0, stopset1, stopset2) OR
         CheckAndInsert(rsbratok, stopset0, stopset1, stopset2) OR
         CheckAndInsert(rparatok, stopset0, stopset1, stopset2) OR
         CheckAndInsert(rcbratok, stopset0, stopset1, stopset2) OR
         CheckAndInsert(periodtok, stopset0, stopset1, stopset2) OR
         CheckAndInsert(oftok, stopset0, stopset1, stopset2) OR
         CheckAndInsert(endtok, stopset0, stopset1, stopset2) OR
         CheckAndInsert(commatok, stopset0, stopset1, stopset2)
      THEN
      END
   END
END PeepToken ;


(*
   Expect - 
*)

PROCEDURE Expect (t: toktype; stopset0: SetOfStop0; stopset1: SetOfStop1; stopset2: SetOfStop2) ;
BEGIN
   IF currenttoken=t
   THEN
      GetToken ;
      IF Pass1
      THEN
         PeepToken(stopset0, stopset1, stopset2)
      END
   ELSE
      MissingToken(t)
   END ;
   SyntaxCheck(stopset0, stopset1, stopset2)
END Expect ;


(*
   CompilationUnit - returns TRUE if the input was correct enough to parse
                     in future passes.
*)

PROCEDURE CompilationUnit () : BOOLEAN ;
BEGIN
   WasNoError := TRUE ;
   FileUnit({eoftok}, {}, {}) ;
   RETURN( WasNoError )
END CompilationUnit ;


(*
   Ident - error checking varient of Ident
*)

PROCEDURE Ident (stopset0: SetOfStop0; stopset1: SetOfStop1; stopset2: SetOfStop2) ;
BEGIN
   IF IsAutoPushOn()
   THEN
      PushTF(currentstring, identtok)
   END ;
   Expect(identtok, stopset0, stopset1, stopset2)
END Ident ;


(*
   string -
*)

PROCEDURE string (stopset0: SetOfStop0; stopset1: SetOfStop1; stopset2: SetOfStop2) ;
BEGIN
   IF IsAutoPushOn()
   THEN
      PushTF(currentstring, stringtok) ;
      BuildString
   END ;
   Expect(stringtok, stopset0, stopset1, stopset2)
END string ;


(*
   Integer -
*)

PROCEDURE Integer (stopset0: SetOfStop0; stopset1: SetOfStop1; stopset2: SetOfStop2) ;
BEGIN
   IF IsAutoPushOn()
   THEN
      PushTF(currentstring, integertok) ;
      BuildNumber
   END ;
   Expect(integertok, stopset0, stopset1, stopset2)
END Integer ;


(*
   Real -
*)

PROCEDURE Real (stopset0: SetOfStop0; stopset1: SetOfStop1; stopset2: SetOfStop2) ;
BEGIN
   IF IsAutoPushOn()
   THEN
      PushTF(currentstring, realtok) ;
      BuildNumber
   END ;
   Expect(realtok, stopset0, stopset1, stopset2)
END Real ;

% module P3Build end
END P3Build.
% rules
error       'ErrorArray' 'ErrorString'
tokenfunc   'currenttoken'

token   ''                eoftok      -- internal token
token   '+'               plustok
token   '-'               minustok
token   '*'               timestok
token   '/'               dividetok
token   ':='              becomestok
token   '&'               ambersandtok
token   "."               periodtok
token   ","               commatok
token   ";"               semicolontok
token   '('               lparatok
token   ')'               rparatok
token   '['               lsbratok   -- left  square brackets
token   ']'               rsbratok   -- right square brackets
token   '{'               lcbratok   -- left  curly brackets
token   '}'               rcbratok   -- right curly brackets
token   '^'               uparrowtok
token   "'"               singlequotetok
token   '='               equaltok
token   '#'               hashtok
token   '<'               lesstok
token   '>'               greatertok
token   '<>'              lessgreatertok
token   '<='              lessequaltok
token   '>='              greaterequaltok
token   '..'              periodperiodtok
token   ':'               colontok
token   '"'               doublequotestok
token   '|'               bartok
token   'AND'             andtok
token   'ARRAY'           arraytok
token   'BEGIN'           begintok
token   'BY'              bytok
token   'CASE'            casetok
token   'CONST'           consttok
token   'DEFINITION'      definitiontok
token   'DIV'             divtok
token   'DO'              dotok
token   'ELSE'            elsetok
token   'ELSIF'           elsiftok
token   'END'             endtok
token   'EXIT'            exittok
token   'EXPORT'          exporttok
token   'FOR'             fortok
token   'FROM'            fromtok
token   'IF'              iftok
token   'IMPLEMENTATION'  implementationtok
token   'IMPORT'          importtok
token   'IN'              intok
token   'LOOP'            looptok
token   'MOD'             modtok
token   'MODULE'          moduletok
token   'NOT'             nottok
token   'OF'              oftok
token   'OR'              ortok
token   'POINTER'         pointertok
token   'PROCEDURE'       proceduretok
token   'QUALIFIED'       qualifiedtok
token   'UNQUALIFIED'     unqualifiedtok
token   'RECORD'          recordtok
token   'REPEAT'          repeattok
token   'RETURN'          returntok
token   'SET'             settok
token   'THEN'            thentok
token   'TO'              totok
token   'TYPE'            typetok
token   'UNTIL'           untiltok
token   'VAR'             vartok
token   'WHILE'           whiletok
token   'WITH'            withtok
token   'ASM'             asmtok
token   'VOLATILE'        volatiletok
token   '...'             periodperiodperiodtok
token   '__DATE__'        datetok
token   '__LINE__'        linetok
token   '__FILE__'        filetok
token   '__ATTRIBUTE__'   attributetok
token   '__BUILTIN__'     builtintok
token   'integer number'  integertok
token   'identifier'      identtok
token   'real number'     realtok
token   'string'          stringtok

special Ident             first { < identtok > } follow { }
special Integer           first { < integertok > } follow { }
special Real              first { < realtok > } follow { }
special string            first { < stringtok > } follow { }

BNF

-- the following are provided by the module m2lex and also handbuild procedures below
-- Ident := Letter { ( Letter | Digit ) } =:
-- Integer := Digit { Digit } | OctalDigit { OctalDigit } ( " B " | " C " ) |
--           Digit { HexDigit } " H " =:
-- Real := Digit { Digit } " . " { Digit } [ ScaleFactor ] =:
-- ScaleFactor := " E " [ ( " + " | " - " ) ] Digit { Digit } =:
-- HexDigit := Digit | " A " | " B " | " C " | " D " | " E " | " F " =:
-- Digit := OctalDigit | " 8 " | " 9 " =:
-- OctalDigit := "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" =:
-- String

FileUnit :=                                                                % PushAutoOff %
            ( DefinitionModule |
              ImplementationOrProgramModule )                              % PopAuto %
         =:

ProgramModule := "MODULE"                                                  % PushAutoOn %
                  Ident                                                    % P3StartBuildProgModule %
                                                                           % PushAutoOff %
                  [ Priority
                  ]                                             
                  ";"							   
                  { Import                                                 
                  }
                  Block                                                    % PushAutoOn %
                  Ident                                                    % EndBuildFile %
                                                                           % P3EndBuildProgModule %
                  "."                                                      % PopAuto ; PopAuto %
                  =:

ImplementationModule := "IMPLEMENTATION" "MODULE"                          % PushAutoOn %
                         Ident                                             % StartBuildModFile %
                                                                           % P3StartBuildImpModule %
                                                                           % PushAutoOff %
                         [ Priority
                         ] ";"                                  
                         { Import
                           }                                               
                         Block                                             % PushAutoOn %
                                 					   
                         Ident                                             % EndBuildFile %
                                                                           % P3EndBuildImpModule %
                         "."                                               % PopAuto ; PopAuto ; PopAuto %
                      =:

ImplementationOrProgramModule :=                                           % PushAutoOff %
                                 ( ImplementationModule | ProgramModule )  % PopAuto %
                              =:

Number := Integer | Real =:

Qualident :=                                                               % VAR name: Name;
                                                                                 Type, Sym: CARDINAL ; %
             Ident
                                                                           % IF IsAutoPushOn()
                                                                             THEN
                                                                                PopT(name) ;
                                                                                Sym := RequestSym(name) ;
                                                                                IF IsDefImp(Sym) OR IsModule(Sym)
                                                                                THEN
                                                                                   Expect(periodtok, stopset0, stopset1, stopset2 + SetOfStop2{identtok}) ;
                                                                                   StartScope(Sym) ;
                                                                                   Qualident(stopset0, stopset1, stopset2) ;
                                                                                   (* should we test for lack of ident? *)
                                                                                   PopTF(Sym, Type) ;
                                                                                   PushTF(Sym, Type) ;
                                                                                   PutIncluded(Sym) ;
                                                                                   EndScope
                                                                                ELSE
                                                                                   PushTF(Sym, GetType(Sym))
                                                                                END
                                                                             ELSE (* just parse qualident *) %
             { "." Ident }                                                 % END %
           =:

ConstantDeclaration :=                                                     % PushAutoOn %
                       ( Ident "="                                         % BuildConst %
                         ConstExpression )                                 % BuildAssignment %
                                                                           % PopAuto %
                     =:

ConstExpression :=                                                         % PushAutoOn %
                   SimpleConstExpr [ Relation SimpleConstExpr              % BuildRelOp %
                                   ]                                       % PopAuto %
                =:

Relation := "="                                                            % PushT(EqualTok) %
            | "#"                                                          % PushT(HashTok) %
            | "<>"                                                         % PushT(LessGreaterTok) %
            | "<"                                                          % PushT(LessTok) %
            | "<="                                                         % PushT(LessEqualTok) %
            | ">"                                                          % PushT(GreaterTok) %
            | ">="                                                         % PushT(GreaterEqualTok) %
            | "IN"                                                         % PushT(InTok) %
         =:

SimpleConstExpr := UnaryOrConstTerm { AddOperator ConstTerm                % BuildBinaryOp %
                                    } =:

UnaryOrConstTerm := "+"                                                    % PushT(PlusTok) %
                    ConstTerm                                              % BuildUnaryOp %
                    |
                    "-"                                                    % PushT(MinusTok) %
                    ConstTerm                                              % BuildUnaryOp %
                    |
                    ConstTerm =:

AddOperator :=   "+"                                                       % PushT(PlusTok) ;
                                                                             RecordOp %
               | "-"                                                       % PushT(MinusTok) ;
                                                                             RecordOp %
               | "OR"                                                      % PushT(OrTok) ;
                                                                             RecordOp %
            =:

ConstTerm := ConstFactor { MulOperator ConstFactor                         % BuildBinaryOp %
                         } =:

MulOperator := "*"                                                         % PushT(TimesTok) ;
                                                                             RecordOp %
               | "/"                                                       % PushT(DivTok) ;
                                                                             RecordOp %
               | "DIV"                                                     % PushT(DivTok) ;
                                                                             RecordOp %
               | "MOD"                                                     % PushT(ModTok) ;
                                                                             RecordOp %
               | "AND"                                                     % PushT(AndTok) ;
                                                                             RecordOp %
               | "&"                                                       % PushT(AmbersandTok) ;
                                                                             RecordOp %
            =:

ConstFactor := ConstQualidentOrSet | Number | ConstString |
               "(" ConstExpression ")" | "NOT" ConstFactor               % BuildNot %
               | ConstAttribute
             =:

-- to help satisfy LL1

ConstString :=
                string
             =:

ConstQualidentOrSet := Qualident [ SimpleSet ] |
                                                                           % BuildBitsetStart %
                       SimpleSet
                     =:

QualidentOrSet := SimpleSet                                                % BuildBitsetStart %
                  | Qualident [ SimpleSet ] =:

ConstAttribute := "__ATTRIBUTE__" "__BUILTIN__" "(" "("                        % PushAutoOn %
                  Ident                                                    % BuildBuiltinConst ;
                                                                             PopAuto %
                  ")" ")" =:

-- Set := [ Qualident ] "{" [ Element { "," Element } ] "}" =:

Element := ConstExpression ( ".." ConstExpression                          % BuildInclRange %
                             |                                             % BuildInclBit (* epsilon *) %
                           ) =:

TypeDeclaration := Ident "=" Type
                =:							   
									   
Type := 
                                                                           % PushAutoOff %
        ( SimpleType | ArrayType
          | RecordType          
          | SetType             
          | PointerType         
          | ProcedureType )                                                % PopAuto %
      =:								   
									   
SimpleType := Qualident | Enumeration | SubrangeType =:								   
									   
Enumeration := "("                                                         
                   ( IdentList                                             
                               )                                           
               ")"                                                         
            =:

IdentList := Ident                                                         % VAR
                                                                                on: BOOLEAN ;
                                                                                n : CARDINAL ; %
                                                                           % on := IsAutoPushOn() ;
                                                                             IF on
                                                                             THEN
                                                                                n := 1
                                                                             END %
             { "," Ident                                                   % IF on
                                                                             THEN
                                                                                INC(n)
                                                                             END %
             }                                                             % IF on
                                                                             THEN
                                                                                PushT(n)
                                                                             END %
             =:

SubrangeType := "[" ConstExpression  ".." ConstExpression "]"              % BuildSubrange ; %
              =:

ArrayType := "ARRAY"

              SimpleType
              { "," 
                SimpleType
              } "OF"
             Type
           =:

RecordType := "RECORD"
              FieldListSequence "END" =:


FieldListSequence := FieldListStatement { ";" FieldListStatement } =:

-- at present FieldListStatement is as follows:
FieldListStatement := [ FieldList ] =:
-- later replace it with FieldList to comply with PIM2

-- sadly the PIM rules are not LL1 as Ident and Qualident have the same first
-- symbols. We rewrite FieldList to inline qualident
-- was
-- FieldList := IdentList ":"                                              % BuildNulName %
--                           Type |
--             "CASE" [ Ident ":" ] Qualident "OF" Varient { "|" Varient }
--                    [ "ELSE" FieldListSequence ] "END" =:

FieldList := IdentList ":"
                           Type
             |
             "CASE" Ident [ ":" Qualident

                           | "."
                             Qualident
                          ] "OF"


              Varient
                      { "|"
                        Varient
                      }
              [ "ELSE"
                FieldListSequence
              ] "END"
           =:

Varient := SilentCaseLabelList ":" FieldListSequence =:

SilentCaseLabelList := SilentCaseLabels { "," SilentCaseLabels } =:

SilentCaseLabels := SilentConstExpression [ ".." SilentConstExpression ] =:

--
--  the following rules are a copy of the ConstExpression ebnf rules but without
--  any actions all prefixed with Silent.
--  At present they are only used by CaseLabels, if this continues to be true we
--  might consider restricting the SilentConstExpression. Eg it makes no sence to allow
--  String in these circumstances!
--

SilentConstExpression :=                                                   % PushAutoOff %
                         SilentSimpleConstExpr
                         [ SilentRelation SilentSimpleConstExpr ]          % PopAuto %
                      =:

SilentRelation := "=" | "#" | "<>" | "<" | "<=" | ">" | ">=" | "IN" =:

SilentSimpleConstExpr := SilentUnaryOrConstTerm { SilentAddOperator SilentConstTerm } =:

SilentUnaryOrConstTerm := "+" SilentConstTerm | "-" SilentConstTerm | SilentConstTerm =:

SilentAddOperator := "+" | "-" | "OR" =:

SilentConstTerm := SilentConstFactor { SilentMulOperator SilentConstFactor } =:

SilentMulOperator := "*" | "/" | "DIV" | "MOD" | "AND" | "&" =:

SilentConstFactor := SilentConstQualidentOrSet | Number | SilentConstString
               |
               "(" SilentConstExpression ")" | "NOT" SilentConstFactor =:

SilentConstString := string =:

SilentConstQualidentOrSet := SilentSimpleSet | Qualident [ SilentSimpleSet ] =:

SilentSimpleSet := "{"  [ SilentElement { "," SilentElement } ] "}" =:

SilentElement := SilentConstExpression [ ".." SilentConstExpression ] =:

-- end of the Silent constant rules

SetType := "SET" "OF" SimpleType =:

PointerType := "POINTER" "TO"
                              Type
             =:

ProcedureType := "PROCEDURE"
                 [ FormalTypeList ] =:

FormalTypeList := "(" ( ")" FormalReturn |
                        ProcedureParameters ")" FormalReturn ) =:

FormalReturn := [ ":" Qualident
                ] =:

ProcedureParameters := ProcedureParameter
                       { "," ProcedureParameter } =:

ProcedureParameter := "..." | "VAR" FormalType | FormalType =:

VariableDeclaration := IdentList ":"
                       Type
                    =:

Designator := Qualident                                                    % CheckWithReference %
                                                                           % CheckOuterScopeProcedureVariable %
              { SubDesignator } =:

SubDesignator := "."                                                       % VAR Sym, Type,
                                                                                 n        : CARDINAL ;
                                                                                 name     : Name ; %
                                                                           % PopTF(Sym, Type) ;
                                                                             PushTF(Sym, Type) ;
                                                                             IF Type=NulSym
                                                                             THEN
                                                                                IF IsModuleKnown(GetSymName(Sym))
                                                                                THEN
                                                                                   WriteFormat2('%a looks like a module which has not been globally imported (eg. suggest that you IMPORT %a ;)',
                                                                                   GetSymName(Sym), GetSymName(Sym))
                                                                                ELSE
                                                                                   WriteFormat1('%a is not a record variable', GetSymName(Sym))
                                                                                END
                                                                             ELSIF NOT IsRecord(Type)
                                                                             THEN
                                                                                WriteFormat1('%a is not a record type', GetSymName(Type))
                                                                             END ;
                                                                             StartScope(Type) %
                 Ident
                                                                           % PopT(name) ;
                                                                             Sym := GetLocalSym(Type, name) ;
                                                                             IF Sym=NulSym
                                                                             THEN
                                                                                WriteFormat2('field %a does not exist within record %a', name, GetSymName(Type))
                                                                             END ;
                                                                             Type := GetType(Sym) ;
                                                                             PushTF(Sym, Type) ;
                                                                             EndScope ;
                                                                             PushT(1) ;
                                                                             BuildDesignatorRecord %
                 | "[" ExpList                                             % BuildDesignatorArray %
                   "]"
                 | "^"                                                     % BuildDesignatorPointer %
            =:

ExpList :=                                                                 % VAR n: CARDINAL ; %
           Expression                                                      % BuildBooleanVariable %
                                                                           % n := 1 %
             { ","
               Expression                                                  % BuildBooleanVariable ;
                                                                             INC(n) %
             }
                                                                           % PushT(n) %
        =:

Expression :=                                                              % PushAutoOn %
              SimpleExpression [ Relation SimpleExpression                 % BuildRelOp %
                               ]                                           % PopAuto %
           =:

SimpleExpression := UnaryOrTerm { AddOperator Term                         % BuildBinaryOp %
                                } =:

UnaryOrTerm := "+"                                                         % PushT(PlusTok) %
                 Term                                                      % BuildUnaryOp %
               | "-"                                                       % PushT(MinusTok) %
                 Term                                                      % BuildUnaryOp %
               | Term =:

Term := Factor { MulOperator Factor                                        % BuildBinaryOp %
               } =:

Factor :=                                                                  % BuildLineNo %
          Number | string | SetOrDesignatorOrFunction |
          "(" Expression ")" | "NOT" ( Factor                              % BuildNot %
          | ConstAttribute
                                ) =:

-- again Set | Designator causes problems as both has a first symbol, ident or Qualident

SimpleSet := "{"                                                           % BuildEmptySet %
             [ Element
               { "," Element
               } ] "}"                                                     % BuildSetEnd %
          =:

SetOrDesignatorOrFunction := Qualident                                     % CheckWithReference %
                                                                           % CheckOuterScopeProcedureVariable %
                              [ SimpleSet |
                                SimpleDes [ ActualParameters               % BuildFunctionCall %
                                                             ]
                              ]                                |
                                                                           % BuildBitsetStart %
                               SimpleSet
                           =:

-- SimpleDes := { "." Ident | "[" ExpList "]" | "^" } =:
SimpleDes := { SubDesignator } =:

ActualParameters := "("                                                    % BuildSizeCheckStart %
                        ( ExpList |                                        % BuildNulParam %
                        ) ")" =:

Statement :=                                                               % PushAutoOn ; DumpStack ;
                                                                             BuildLineNo %
             [ AssignmentOrProcedureCall | IfStatement | CaseStatement |
               WhileStatement | RepeatStatement | LoopStatement |
               ForStatement | WithStatement | AsmStatement |
               "EXIT"                                                      % BuildExit %
               | "RETURN"                                                  % BuildLineNo %
                 ( Expression |                                            % BuildNulExpression (* in epsilon *) %
                               )                                           % BuildReturn %
             ]                                                             % PopAuto ; %
          =:

AssignmentOrProcedureCall :=                                               % BuildLineNo ; DumpStack %
                             Designator
                             ( ":=" Expression                             % BuildAssignment %
                                |                                          % BuildLineNo %
                                  ( ActualParameters |                     % BuildNulParam (* in epsilon *) %
                                  )                                        % BuildProcedureCall %
                             )                                             % DumpStack %
                           =:

-- these two break LL1 as both start with a Designator
-- ProcedureCall := Designator [ ActualParameters ] =:
-- Assignment := Designator ":=" Expression =:

StatementSequence :=                                                       % BuildLineNo %
                     Statement                                             % BuildLineNo %
                               { ";"                                       % BuildLineNo %
                                     Statement }                           % BuildLineNo %
                  =:

IfStatement :=                                                             % BuildLineNo %
               "IF"
                    Expression "THEN"                                      % BuildLineNo ;
                                                                             BuildThenIf %
                StatementSequence
              { "ELSIF"                                                    % BuildLineNo ;
                                                                             BuildElsif1 %
                        Expression "THEN"                                  % BuildLineNo ;
                                                                             BuildThenIf %
                                          StatementSequence                % BuildElsif2 %
              }
              [ "ELSE"                                                     % BuildLineNo ;
                                                                             BuildElse %
                      StatementSequence ] "END"                            % BuildLineNo ;
                                                                             BuildEndIf %
            =:

CaseStatement := "CASE"                                                    % BuildLineNo %
                        Expression                                         % BuildCaseStart %
                                   "OF" Case { "|" Case }
                 [ "ELSE"                                                  % BuildLineNo ;
                                                                             BuildCaseElse %
                          StatementSequence ] "END"                        % BuildLineNo ;
                                                                             BuildCaseEnd %
               =:

Case := CaseLabelList ":"                                                  % BuildCaseStartStatementSequence %
                          StatementSequence                                % BuildCaseEndStatementSequence %
      =:

CaseLabelList := CaseLabels { ","                                          % BuildCaseOr %
                                  CaseLabels } =:

CaseLabels := ConstExpression ( ".." ConstExpression                       % BuildCaseRange ;
                                                                             BuildCaseList %
                                |                                          % BuildCaseEquality ;  (* epsilon *)
                                                                             BuildCaseList %
                              ) =:

WhileStatement := "WHILE"                                                  % BuildLineNo ;
                                                                             BuildWhile ; DumpStack %
                  Expression "DO"                                          % BuildDoWhile %
                                  StatementSequence "END"                  % DumpStack ; BuildEndWhile %
                =:

RepeatStatement := "REPEAT"                                                % BuildLineNo ;
                                                                             BuildRepeat %
                            StatementSequence "UNTIL"                      % BuildLineNo %
                    Expression                                             % BuildUntil ;
                                                                             BuildLineNo %
                 =:

ForStatement := "FOR"                                                      % BuildLineNo %
                      Ident ":=" Expression "TO" Expression
                ( "BY" ConstExpression |                                   % BuildPseudoBy  (* epsilon *) %
                ) "DO"                                                     % BuildForToByDo %
                StatementSequence "END"                                    % BuildEndFor %
              =:

LoopStatement := "LOOP"                                                    % BuildLineNo ;
                                                                             BuildLoop %
                        StatementSequence "END"                            % BuildEndLoop %
               =:

WithStatement := "WITH"                                                    % DumpStack ; BuildLineNo %
                        Designator "DO"                                    % BuildLineNo ;
                                                                             StartBuildWith %
                        StatementSequence
                 "END"                                                     % BuildLineNo ;
                                                                             EndBuildWith ; DumpStack %
               =:

ProcedureDeclaration := ProcedureHeading ";" ProcedureBlock                % BuildProcedureEnd ;
                                                                             PushAutoOn %

                        Ident                                              % EndBuildProcedure ;
                                                                             PopAuto %
                      =:

ProcedureHeading := "PROCEDURE"                                            % PushAutoOn %
                     ( Ident
                                                                           % StartBuildProcedure ;
                                                                             PushAutoOff %
                       [ FormalParameters ]
                                                                           % BuildProcedureHeading ;
                                                                             PopAuto %
                     )                                                     % PopAuto %
                     =:

-- introduced procedure block so we can produce more informative
-- error messages

ProcedureBlock := { Declaration } "BEGIN"                                  % BuildProcedureStart ;
                                                                             BuildLineNo %
                                          StatementSequence "END"          % BuildLineNo %
                =:

Block := { Declaration } ( "BEGIN"                                         % StartBuildModFile ;
                                                                             StartBuildInit ;
                                                                             BuildLineNo %
                                   StatementSequence "END"                 % BuildLineNo ;
                                                                             EndBuildInit %
                         | "END"                                           % StartBuildModFile ;
                                                                             StartBuildInit ;
                                                                             BuildLineNo ;
                                                                             EndBuildInit %
                         )
       =:

Declaration := "CONST" { ConstantDeclaration ";" } |
               "TYPE" { TypeDeclaration ";" } |
               "VAR" { VariableDeclaration ";" } |
               ProcedureDeclaration ";" |
               ModuleDeclaration ";" =:

FormalParameters := "(" [ FPSection { ";" FPSection } ] ")"
                    [ ":" Qualident
                    ] =:

FPSection := NonVarFPSection | VarFPSection | "..." =:

VarFPSection := "VAR" IdentList ":" FormalType =:

NonVarFPSection := IdentList ":" FormalType =:

FormalType := [ "ARRAY" "OF" ] Qualident =:

ModuleDeclaration := "MODULE"                                              % PushAutoOn %
                     Ident                                                 % StartBuildInnerModule ;
                                                                             PushAutoOff %
                     [ Priority ] ";"
                     { Import
                        } [ Export
                            ]
                       Block                                               % PushAutoOn %
                       Ident                                               % EndBuildInnerModule %
                                                                           % PopAuto ; PopAuto ; PopAuto %
                     =:

Priority := "[" ConstExpression "]" =:

Export := "EXPORT" ( "QUALIFIED"
                                 IdentList |
                     "UNQUALIFIED"
                                 IdentList |
                     IdentList ) ";" =:

Import :=  "FROM" Ident "IMPORT" IdentList ";" |
           "IMPORT"
            IdentList ";" =:

DefinitionModule := "DEFINITION" "MODULE"                                  % PushAutoOn %
                    [ "FOR" string ]
                    Ident                                                  % StartBuildDefFile ;
                                                                             P3StartBuildDefModule ;
                                                                             PushAutoOff %
                    ";"
                    { Import
                             } [ Export
                                        ]
                    { Definition }
                                   "END"                                   % PushAutoOn %
                                         Ident                             % EndBuildFile ;
                                                                             P3EndBuildDefModule %
                                               "."                         % PopAuto ; PopAuto ; PopAuto %
                  =:

Definition := "CONST" { ConstantDeclaration ";" } |
              "TYPE"
                    { Ident ( ";"                 
                                  | "=" Type ";" )
                    }
              |
              "VAR" { VariableDeclaration ";" } |
              ProcedureHeading ";" =:

AsmStatement :=                                                            % VAR CurrentAsm: CARDINAL ; %
                'ASM'                                                      % IF Pass3
                                                                             THEN
                                                                                PushAutoOn ;
                                                                                PushT(MakeGnuAsm())
                                                                             END
                                                                           %
                [ 'VOLATILE'                                               % IF Pass3
                                                                             THEN
                                                                                PopT(CurrentAsm) ;
                                                                                PutGnuAsmVolatile(CurrentAsm) ;
                                                                                PushT(CurrentAsm)
                                                                             END
                                                                           %
                ] '(' AsmOperands                                          % IF Pass3
                                                                             THEN
                                                                                BuildInline ;
                                                                                PopAuto
                                                                             END
                                                                           %
                  ')' =:

AsmOperands :=                                                             % VAR CurrentAsm, outputs, inputs, trash: CARDINAL ;
                                                                                 str: CARDINAL ;
                                                                           %
               string                                                      % IF Pass3
                                                                             THEN
                                                                                PopT(str) ;
                                                                                PopT(CurrentAsm) ;
                                                                                (* adds the name/instruction for this asm *)
                                                                                PutGnuAsm(CurrentAsm, str) ;
                                                                                PushT(CurrentAsm)
                                                                             END
                                                                           %
               [ ':' AsmList                                               % IF Pass3
                                                                             THEN
                                                                                PopT(outputs) ;
                                                                                PopT(CurrentAsm) ;
                                                                                PutGnuAsmOutput(CurrentAsm, outputs) ;
                                                                                PushT(CurrentAsm)
                                                                             END
                                                                           %
                  [ ':' AsmList                                            % IF Pass3
                                                                             THEN
                                                                                PopT(inputs) ;
                                                                                PopT(CurrentAsm) ;
                                                                                PutGnuAsmInput(CurrentAsm, inputs) ;
                                                                                PushT(CurrentAsm)
                                                                             END
                                                                           %
                     [ ':' TrashList                                       % IF Pass3
                                                                             THEN
                                                                                PopT(trash) ;
                                                                                PopT(CurrentAsm) ;
                                                                                PutGnuAsmTrash(CurrentAsm, trash) ;
                                                                                PushT(CurrentAsm)
                                                                             END
                                                                           %
                        ] ] ]
            =:

AsmList     :=                                                             % IF Pass3
                                                                             THEN
                                                                                PushT(NulSym)
                                                                             END
                                                                           %
               [ AsmElement ] { ',' AsmElement } =:

AsmElement :=                                                              % VAR str,
                                                                                 expr, CurrentInterface: CARDINAL ; %
              string '(' Expression                                        % IF Pass3
                                                                             THEN
                                                                                PopT(expr) ;
                                                                                PopT(str) ;
                                                                                PopT(CurrentInterface) ;
                                                                                IF CurrentInterface=NulSym
                                                                                THEN
                                                                                   CurrentInterface := MakeRegInterface()
                                                                                END ;
                                                                                PutRegInterface(CurrentInterface, str, expr) ;
                                                                                PushT(CurrentInterface)
                                                                             END
                                                                           %
                      ')'
           =:

TrashList :=                                                               % VAR CurrentInterface: CARDINAL ;
                                                                                 str: CARDINAL ; %
             [ string                                                      % IF Pass3
                                                                             THEN
                                                                                PopT(str) ;
                                                                                CurrentInterface := MakeRegInterface() ;
                                                                                PutRegInterface(CurrentInterface, str, NulSym) ;
                                                                                PushT(CurrentInterface)
                                                                             END
                                                                           %
             ] { ',' string                                                % IF Pass3
                                                                             THEN
                                                                                PopT(str) ;
                                                                                PopT(CurrentInterface) ;
                                                                                PutRegInterface(CurrentInterface, str, NulSym) ;
                                                                                PushT(CurrentInterface)
                                                                             END
                                                                           %
                } =:

FNB
