DEFINITION MODULE gccgm2 ;

(*
    Title      : gccgm2
    Author     : Gaius Mulley
    System     : UNIX (gm2)
    Date       : Sat Jul 24 15:47:03 1999
    Description: provides a Modula-2 interface to the C file gm2.c
*)

FROM SYSTEM IMPORT ADDRESS ;

EXPORT QUALIFIED Tree,

                 BuildBinProcedure, BuildUnaryProcedure,
                 SetFileNameAndLineNo, EmitLineNote,
                 DeclareKnownType, DeclareKnownVariable, DeclareKnownConstant,
                 GetDefaultType, GetCopyOfType,
                 GetIntegerOne, GetIntegerType, GetIntegerZero,
                 GetWordOne, GetWordZero,
                 GetCharType, GetM2CharType, GetVoidType, GetCurrentFunction,
                 GetPointerType, GetPointerZero, GetPointerOne,
                 GetM2IntegerType, GetM2CardinalType,
                 GetByteType, GetCardinalType, GetBitsetType, GetBitnumType,
                 GetLongIntType, GetRealType, GetLongRealType, GetProcType,
                 GetM2ShortRealType, GetM2RealType, GetM2LongRealType, GetM2LongIntType,
                 GetM2LongCardType,
                 GetWordType,
                 GetISOLocType, GetISOByteType, GetISOWordType,
                 GetMinFrom, GetMaxFrom, GetSizeOf, GetErrorNode,
                 GetBitsPerWord, GetBitsPerUnit, GetBitsPerInt,
                 GetBitsPerBitset,

                 BuildStart, BuildEnd, BuildCallInnerInit,
                 BuildStartEnumeration, BuildEndEnumeration, BuildEnumerator,
                 BuildIntegerConstant, BuildStringConstant, BuildCharConstant,
                 BuildSubrangeType, BuildArrayIndexType,
                 BuildStartRecord, BuildStartVarientRecord, BuildEndRecord,
                 BuildFieldRecord, ChainOn, ChainOnParamValue, AddStringToTreeList,
                 BuildPointerType, BuildArrayType, BuildSetType,
                 BuildStartSetConstructor, BuildSetConstructorElement,
                 BuildEndSetConstructor,
                 BuildStartFunctionType, BuildEndFunctionType,
                 InitFunctionTypeParameters,
                 BuildParameterDeclaration,
                 BuildStartFunctionDeclaration, BuildEndFunctionDeclaration,
                 BuildStartFunctionCode, BuildEndFunctionCode, BuildReturnValueCode,
                 BuildAssignment,
                 BuildAdd, BuildSub, BuildMult, BuildDiv, BuildMod,
                 BuildLSL, BuildLSR, BuildLogicalShift,
                 BuildLRL, BuildLRR, BuildLogicalRotate,
                 BuildLogicalOr, BuildLogicalAnd,
                 BuildSymmetricDifference, BuildLogicalDifference,
                 BuildConvert, BuildCoerce,
                 BuildAddr, BuildNegate, BuildSetNegate, BuildSize,
                 BuildOffset, BuildTrunc,
                 BuildGoto, DeclareLabel,
                 BuildLessThan, BuildGreaterThan,
                 BuildLessThanOrEqual, BuildGreaterThanOrEqual,
                 BuildEqualTo, BuildNotEqualTo,
                 BuildIsSuperset, BuildIsNotSuperset,
                 BuildIsSubset, BuildIsNotSubset,
                 BuildIfConstInVar, BuildIfNotConstInVar,
                 BuildIfVarInVar, BuildIfNotVarInVar,
                 BuildIndirect,
                 DoJump,
                 BuildProcedureCall, BuildIndirectProcedureCall, BuildParam, BuildFunctValue,
                 BuildStartMainModule, BuildEndMainModule,
                 BuildAsm, BuildExpand, DebugTree,
                 BuildVariableArrayAndDeclare,
                 RealToTree,
                 RememberConstant, FoldAndStrip,
                 BuildBinaryForeachWordDo,
                 BuildUnaryForeachWordDo,
                 BuildIncludeVarVar, BuildExcludeVarVar,
                 BuildIncludeVarConst, BuildExcludeVarConst,
                 BuildIfNotIn, BuildIfIn,
                 BuildForeachWordInSetDoIfExpr,
                 BuildIfInRangeGoto, BuildIfNotInRangeGoto,
                 BuildBinarySetDo,
                 BuildPushFunctionContext, BuildPopFunctionContext,
                 BuildCap,

                 AreConstantsEqual, DetermineSign, CompareTrees,
                 AssignBooleanTrueFalse,
                 ConvertConstantAndCheck,
                 ToWord,
                 ExpandExpressionStatement,
                 InitGlobalContext ;


TYPE
   Tree                = ADDRESS ;
   BuildBinProcedure   = PROCEDURE (Tree, Tree, BOOLEAN) : Tree ;
   BuildUnaryProcedure = PROCEDURE (Tree, BOOLEAN) : Tree ;
   BuildExprProcedure  = PROCEDURE (Tree, Tree) : Tree ;


(*
   SetFileNameAndLineNo - assigns a filename and line number to the GCC
                          global variables. Remember that the string contents
                          addressed by fn must not be overwritten.

                          SetFileNameAndLineNo - should be used when declaring data types,
                          procedures, variables etc.
*)

PROCEDURE SetFileNameAndLineNo (fn: ADDRESS; line: CARDINAL) ;


(*
   EmitLineNote - emits line and file information to gcc whilst constructing code.
                  Should be used when generating code (after a call to SetFileNameAndLineNo).
*)

PROCEDURE EmitLineNote (fn: ADDRESS; line: CARDINAL) ;


(*
   The following functions allow access to some global variables,
   which are used in the declaration of base types.
*)

PROCEDURE DeclareKnownType       (name: ADDRESS; type: Tree) : Tree ;
PROCEDURE DeclareKnownConstant   (type: Tree  ; value: Tree) : Tree ;
PROCEDURE DeclareKnownVariable   (name: ADDRESS; type: Tree;
                                  isexported, isimported, istemporary, isglobal: BOOLEAN;
                                  scope: Tree) : Tree ;
PROCEDURE GetCopyOfType          (t : Tree) : Tree ;
PROCEDURE GetDefaultType         (name: ADDRESS; type: Tree) : Tree ;
PROCEDURE GetIntegerType         () : Tree ;
PROCEDURE GetCharType            () : Tree ;
PROCEDURE GetM2CharType          () : Tree ;
PROCEDURE GetM2IntegerType       () : Tree ;
PROCEDURE GetM2CardinalType      () : Tree ;
PROCEDURE GetByteType            () : Tree ;
PROCEDURE GetVoidType            () : Tree ;
PROCEDURE GetPointerType         () : Tree ;
PROCEDURE GetCardinalType        () : Tree ;
PROCEDURE GetBitsetType          () : Tree ;
PROCEDURE GetBitnumType          () : Tree ;
PROCEDURE GetRealType            () : Tree ;
PROCEDURE GetLongRealType        () : Tree ;
PROCEDURE GetLongIntType         () : Tree ;
PROCEDURE GetM2ShortRealType     () : Tree ;
PROCEDURE GetM2RealType          () : Tree ;
PROCEDURE GetM2LongRealType      () : Tree ;
PROCEDURE GetM2LongIntType       () : Tree ;
PROCEDURE GetM2LongCardType      () : Tree ;
PROCEDURE GetWordType            () : Tree ;
PROCEDURE GetProcType            () : Tree ;
PROCEDURE GetISOLocType          () : Tree ;
PROCEDURE GetISOByteType         () : Tree ;
PROCEDURE GetISOWordType         () : Tree ;

PROCEDURE GetIntegerZero         () : Tree ;
PROCEDURE GetIntegerOne          () : Tree ;
PROCEDURE GetWordZero            () : Tree ;
PROCEDURE GetWordOne             () : Tree ;
PROCEDURE GetPointerZero         () : Tree ;
PROCEDURE GetPointerOne          () : Tree ;
PROCEDURE GetCurrentFunction     () : Tree ;
PROCEDURE GetErrorNode           () : Tree ;


(*
   GetMinFrom - given a, type, return a constant representing the minimum
                legal value.
*)

PROCEDURE GetMinFrom (type: Tree) : Tree ;


(*
   GetMaxFrom - given a, type, return a constant representing the maximum
                legal value.
*)

PROCEDURE GetMaxFrom (type: Tree) : Tree ;


(*
   GetBitsPerWord - returns a CARDINAL indicating the number of bits per word.
*)

PROCEDURE GetBitsPerWord () : CARDINAL ;


(*
   GetBitsPerUnit - returns a CARDINAL indicating the number of bits per unit.
*)

PROCEDURE GetBitsPerUnit () : CARDINAL ;


(*
   GetBitsPerInt - returns a CARDINAL indicating the number of bits per INTEGER.
*)

PROCEDURE GetBitsPerInt () : CARDINAL ;


(*
   GetBitsPerBitset - returns a CARDINAL indicating the number of bits per BITSET.
*)

PROCEDURE GetBitsPerBitset () : CARDINAL ;


(*
   GetSizeOf - returns a Tree containing the sizeof(type).
*)

PROCEDURE GetSizeOf (type: Tree) : Tree ;


(*
   BuildBinaryForeachWordDo - provides the large set operators. Each word (or less)
                              of the set can be calculated by binop.
                              This procedure runs along each word of the large set
                              invoking the binop.
*)

PROCEDURE BuildBinaryForeachWordDo (type, op1, op2, op3: Tree;
                                    binop: BuildBinProcedure;
                                    is_op1lvalue, is_op2lvalue, is_op3lvalue: BOOLEAN) ;


(*
   BuildUnaryForeachWordDo - provides the large set operators. Each word (or less)
                             of the set can be calculated by unop.
                             This procedure runs along each word of the large set
                             invoking the unop.
*)

PROCEDURE BuildUnaryForeachWordDo (type, op1, op2: Tree;
                                   unop: BuildUnaryProcedure;
                                   is_op1lvalue, is_op2lvalue: BOOLEAN) ;


(*
   BuildExcludeVarConst - builds the EXCL(op1, 1<<op2) operation for a large/small set. Large
                          sets call this routine to exclude the bit in the particular field.
                          op2 is a constant. (which indicates the bit 0..BitsPerWord-1 to unset
                          in fieldno).
                          op1 is the set (possibly a large set)
*)

PROCEDURE BuildExcludeVarConst (type, op1, op3: Tree; is_lvalue: BOOLEAN; fieldno: CARDINAL) ;


(*
   BuildIncludeVarConst - builds the INCL(op1, 1<<op2) operation for a large/small set. Large
                          sets call this routine to include the bit in the particular field.
                          op2 is a constant. (which indicates the bit 0..BitsPerWord-1 to set
                          in fieldno).
                          op1 is the set (possibly a large set)
*)

PROCEDURE BuildIncludeVarConst (type, op1, op3: Tree; is_lvalue: BOOLEAN; fieldno: CARDINAL) ;


(*
   BuildIncludeVarVar - builds the INCL(varset, 1<<varel) operation for a small and large sets.
                        op2 is a variable.
*)

PROCEDURE BuildIncludeVarVar (type, varset, varel: Tree; is_lvalue: BOOLEAN; low: Tree) ;


(*
   BuildExcludeVarVar - builds the EXCL(varset, 1<<varel) operation for a small and large sets.
                        varel is a variable.
*)

PROCEDURE BuildExcludeVarVar (type, varset, varel: Tree; is_lvalue: BOOLEAN; low: Tree) ;


(*
   BuildIfConstInVar - generates: if constel in varset then goto label.
*)

PROCEDURE BuildIfConstInVar (type, varset, constel: Tree; is_lvalue: BOOLEAN; fieldno: CARDINAL;
                             label: ADDRESS) ;


(*
   BuildIfNotConstInVar - generates: if not (constel in varset) then goto label.
*)

PROCEDURE BuildIfNotConstInVar (type, varset, constel: Tree; is_lvalue: BOOLEAN; fieldno: CARDINAL;
                                label: ADDRESS) ;


(*
   BuildIfVarInVar - generates: if varel in varset then goto label
*)

PROCEDURE BuildIfVarInVar (type, varset, varel: Tree; is_lvalue: BOOLEAN;
                           low, high: Tree; label: ADDRESS) ;


(*
   BuildIfNotVarInVar - generates: if not (varel in varset) then goto label
*)

PROCEDURE BuildIfNotVarInVar (type, varset, varel: Tree; is_lvalue: BOOLEAN;
                              low, high: Tree; label: ADDRESS) ;


(*
   BuildIfInRangeGoto - if var is in the range low..high then goto label
*)

PROCEDURE BuildIfInRangeGoto (var, low, high: Tree; label: ADDRESS) ;


(*
   BuildIfNotInRangeGoto - if var is not in the range low..high then goto label
*)

PROCEDURE BuildIfNotInRangeGoto (var, low, high: Tree; label: ADDRESS) ;

(*
   BuildBinarySetDo - if the size of the set is <= TSIZE(WORD) then
                         op1 := binop(op2, op3)
                      else
                         call funcname(op1, op2, op3)
*)

PROCEDURE BuildBinarySetDo (settype,
                            op1, op2, op3: Tree;
                            binop: BuildBinProcedure;
                            is_op1lvalue,
                            is_op2lvalue,
                            is_op3lvalue: BOOLEAN;
                            nBits, unbounded,
                            varproc, leftproc, rightproc: Tree) ;


(*
   AreConstantsEqual - maps onto tree.c (tree_int_cst_equal). It returns
                       TRUE if the value of e1 is the same as e2.
*)

PROCEDURE AreConstantsEqual (e1, e2: Tree) : BOOLEAN ;


(*
   DetermineSign - returns -1 if e<0
                            0 if e==0
                            1 if e>0
 
                   an unsigned constant will never return -1
*)

PROCEDURE DetermineSign (e: Tree) : INTEGER ;


(*
   CompareTrees - returns -1 if e1 < e2, 0 if e1 == e2, and 1 if e1 > e2.
*)

PROCEDURE CompareTrees (e1, e2: Tree) : INTEGER ;


(*
   RealToTree - convert a real number into a Tree.
*)

PROCEDURE RealToTree (name: ADDRESS) : Tree ;


(*
   BuildStart - builds the module prologue. We tell gcc whether
                it is an inner module or not, which determines whether the
                initialization code is exported (not inner).
*)

PROCEDURE BuildStart (name: ADDRESS; line: CARDINAL; inner: BOOLEAN) : Tree ;


(*
   BuildStart - ends the module prologue.
*)

PROCEDURE BuildEnd (t: Tree) ;


(*
   BuildCallInnerInit - builds a call to a function, funct. This function
                        has no return type and no parameters.
*)

PROCEDURE BuildCallInnerInit (funct: Tree) ;


(*
   BuildStartMainModule - creates the global scope and expands all global
                          variables ready for main module compilation.
*)

PROCEDURE BuildStartMainModule ;


(*
   BuildEndMainModule - tidies up the end of the main module. It moves
                        back to global scope.
*)

PROCEDURE BuildEndMainModule ;


(*
   BuildStartEnumeration - create an enumerated type in gcc.
*)

PROCEDURE BuildStartEnumeration (name: ADDRESS) : Tree ;


(*
   BuildEndEnumeration - finish building an enumerated type in gcc.
                         The finished enumtype is returned.
*)

PROCEDURE BuildEndEnumeration (enumtype: Tree) : Tree ;


(*
   BuildEnumerator - builds an enumerator in the current enumerated type
                     and returns the enumerator.
*)

PROCEDURE BuildEnumerator (name: ADDRESS; value: Tree) : Tree ;


(*
   BuildIntegerConstant - creates an integer constant and returns it.
*)

PROCEDURE BuildIntegerConstant (value: INTEGER) : Tree ;


(*
   BuildStringConstant - creates a string constant given a, string, and, length.
*)

PROCEDURE BuildStringConstant (string: ADDRESS; length: CARDINAL) : Tree ;


(*
   BuildCharConstant - creates a character constant given a, string.
*)

PROCEDURE BuildCharConstant (string: ADDRESS) : Tree ;


(*
    floating point constant creation
*)

PROCEDURE BuildRealConstant     (value: LONGREAL) : Tree ;
PROCEDURE BuildLongRealConstant (value: LONGREAL) : Tree ;


(*
   ConvertConstantAndCheck - in Modula-2 sementics: return( VAL(type, expr) )
                             Only to be used for a constant expr,
                             overflow checking is performed. 
*)

PROCEDURE ConvertConstantAndCheck (type, expr: Tree) : Tree ;


(*
   ToWord - converts an expression (Integer or Ordinal type) into
            a WORD.
*)

PROCEDURE ToWord (expr: Tree) : Tree ;

(*
   AssignBooleanTrueFalse - assigns the tree nodes to the internal gcc types.
                            This allows gm2 to declare boolean as an enumerated type.
*)

PROCEDURE AssignBooleanTrueFalse (booleanid, trueid, falseid: Tree) ;


(*
   BuildSubrangeType - creates a subrange of, type, with, lowval, highval.
*)

PROCEDURE BuildSubrangeType (name: ADDRESS;
                             type, lowval, highval: Tree) : Tree ;


(*
   BuildArrayIndexType - creates an integer index which accesses an array.
                         low and high are the min, max elements of the array.
*)

PROCEDURE BuildArrayIndexType (low, high: Tree) : Tree ;


(*
   BuildVariableArrayAndDeclare - creates a variable length array.
                                  high is the maximum legal elements (which is a runtime variable).
                                  This creates and array index, array type and local variable.
*)

PROCEDURE BuildVariableArrayAndDeclare (elementtype, high: Tree; name: ADDRESS; scope: Tree) : Tree ;


(*
   BuildStartRecord - creates a record with, name.
*)

PROCEDURE BuildStartRecord (name: ADDRESS) : Tree ;


(*
   BuildEndRecord - finishes constructing a varient record or a record.
                    t should be the return value from BuildStartRecord and
                    fieldlist is created from BuildFieldRecord.
*)

PROCEDURE BuildEndRecord (t: Tree; fieldlist: Tree) : Tree ;


(*
   BuildStartVarientRecord - creates a varient record with, name.
                             Note that this is finished by calling BuildEndRecord.
*)

PROCEDURE BuildStartVarientRecord (name: ADDRESS) : Tree ;


(*
   BuildFieldRecord - builds a record field given a, name, (which maybe NIL) and
                      a type. It returns a new field. This field maybe chained on
                      to other field to build a fieldlist.
*)

PROCEDURE BuildFieldRecord (name: ADDRESS; type: Tree) : Tree ;


(*
   ChainOn - builds a list of t1, t2 and returns the new list.
*)

PROCEDURE ChainOn (t1, t2: Tree) : Tree ;


(*
   ChainOnParamValue - adds a list node {parm, value} into the tree list.
*)

PROCEDURE ChainOnParamValue (list, parm, value: Tree) : Tree ;


(*
   AddStringToTreeList - adds, string, to list.
*)

PROCEDURE AddStringToTreeList (list, string: Tree) : Tree ;


(*
   BuildPointerType - returns a new type which is declared as a pointer to totype.
*)

PROCEDURE BuildPointerType (totype: Tree) : Tree ;


(*
   BuildArrayType - creates an array which is indexed by IndexType and
                    contains elements, ElementType.
*)

PROCEDURE BuildArrayType (ElementType, IndexType: Tree) : Tree ;


(*
   BuildSetType - creates a SET OF [low..high] where low and high
                  both have type, type.
*)

PROCEDURE BuildSetType (name: ADDRESS; type, low, high: Tree) : Tree ;


(*
   BuildStartSetConstructor - starts to create a set constant.
                              Remember that type is really a record type.
*)

PROCEDURE BuildStartSetConstructor (type: Tree) ;


(*
   BuildSetConstructorElement - adds, value, to the constructor_element_list.
*)

PROCEDURE BuildSetConstructorElement (value: Tree) ;


(*
   BuildEndSetConstructor - finishes building a set constant.
*)

PROCEDURE BuildEndSetConstructor () : Tree ;


(*
   BuildStartFunctionType - starts the building of a function type.
*)

PROCEDURE BuildStartFunctionType (name: ADDRESS) : Tree ;


(*
   BuildEndFunctionType - build a function type, func, which would return a, value.
                          The arguments have been created by BuildParameterDeclaration.
*)

PROCEDURE BuildEndFunctionType (func, value: Tree) : Tree ;


(*
   InitFunctionTypeParameters - resets the current function type parameter list.
*)

PROCEDURE InitFunctionTypeParameters (usesVarArgs: BOOLEAN) ;


(*
   BuildParameterDeclaration - creates and returns one parameter from, name, and, type.
                               It appends this parameter to the internal param_type_list.
                               If name is nul then we assume we are creating a function
                               type declaration and we ignore names.
*)

PROCEDURE BuildParameterDeclaration (name: ADDRESS; type: Tree; isreference: BOOLEAN) : Tree ;


(*
   BuildStartFunctionDeclaration - initializes global variables ready for building
                                   a function declaration.
*)

PROCEDURE BuildStartFunctionDeclaration (usesVarArgs: BOOLEAN) ;


(*
   BuildEndFunctionDeclaration - build a function which will return a value of returntype.
                                 The arguments have been created by BuildParameterDeclaration.
*)

PROCEDURE BuildEndFunctionDeclaration (name: ADDRESS;
                                       returntype: Tree;
                                       isexternal, isnested: BOOLEAN) : Tree ;


(*
   BuildStartFunctionCode - generate function entry code.
*)

PROCEDURE BuildStartFunctionCode (fndecl: Tree; isexported: BOOLEAN) ;


(*
   BuildEndFunctionCode - generates the function epilogue.
*)

PROCEDURE BuildEndFunctionCode (fndecl: Tree) ;


(*
   BuildReturnValueCode - generates the code associated with: RETURN( value )
*)

PROCEDURE BuildReturnValueCode (fndecl, value: Tree) ;


(*
   BuildAssignment - generates code for, des := expr and returns, des.
*)

PROCEDURE BuildAssignment (des, expr: Tree) : Tree ;


(*
   BuildAdd - build an addition tree.
*)

PROCEDURE BuildAdd (op1, op2: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildSub - build a subtraction tree.
*)

PROCEDURE BuildSub (op1, op2: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildMult - build a multiplication tree.
*)

PROCEDURE BuildMult (op1, op2: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildDiv - build a division tree.
*)

PROCEDURE BuildDiv (op1, op2: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildMod - build a modulus tree.
*)

PROCEDURE BuildMod (op1, op2: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildLSL - build a << tree  ie  (op1 << op2).
*)

PROCEDURE BuildLSL (op1, op2: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildLSR - build a >> tree  ie  (op1 << op2).
*)

PROCEDURE BuildLSR (op1, op2: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildLRL - build a rotate tree  ie  (op1 rotated left by op2 bits).
*)

PROCEDURE BuildLRL (op1, op2: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildLRR - build a rotate tree  ie  (op1 rotated right by op2 bits).
*)

PROCEDURE BuildLRR (op1, op2: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildLogicalRotate - builds the ISO Modula-2 ROTATE operator
                        for a fundamental data type.
*)

PROCEDURE BuildLogicalRotate (op1, op2: Tree;
                              needconvert: BOOLEAN) : Tree ;


(*
   BuildLogicalShift - builds the ISO Modula-2 SHIFT operator
                       for a fundamental data type.
*)

PROCEDURE BuildLogicalShift (op1, op2: Tree;
                             needconvert: BOOLEAN) : Tree ;


(*
   BuildLogicalOr - build and return a logical or tree. ie (op1 || op2)
*)

PROCEDURE BuildLogicalOr (op1, op2: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildLogicalAnd - build and return a logical and tree. ie (op1 && op2)
*)

PROCEDURE BuildLogicalAnd (op1, op2: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildNegate - builds a negate expression and returns the tree.
*)

PROCEDURE BuildNegate (op1: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildSetNegate - builds a set negate expression and returns the tree.
*)

PROCEDURE BuildSetNegate (op1: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildSize - builds a SIZE function expression and returns the tree.
*)

PROCEDURE BuildSize (op1: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildTrunc - returns an integer expression from a REAL or LONGREAL op1.
*)

PROCEDURE BuildTrunc (op1: Tree) : Tree ;


(*
   BuildAddr - builds an expression which calculates the address of op1 and returns the tree.
*)

PROCEDURE BuildAddr (op1: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildOffset - builds an expression containing the number of bytes the field
                 is offset from the start of the record structure.
                 The expression is returned.
*)

PROCEDURE BuildOffset (field: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildSymmetricDifference - build and return a symmetric difference tree. (op1 xor op2)
*)

PROCEDURE BuildSymmetricDifference (op1, op2: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildLogicalDifference - build and return a logical difference tree.
                            (op1 and (not op2))
*)

PROCEDURE BuildLogicalDifference (op1, op2: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildConvert - build and return tree VAL(op1, op2)
                  where op1 is the type to which op2 is to be converted.
*)

PROCEDURE BuildConvert (op1, op2: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildCoerce - returns a tree containing the cast op1 := op2.
*)

PROCEDURE BuildCoerce (op1, op2, op3: Tree) : Tree ;


(*
   BuildGoto - builds a goto operation.
*)

PROCEDURE BuildGoto (name: ADDRESS) ;


(*
   DeclareLabel - create a label, name, and return the tree.
*)

PROCEDURE DeclareLabel (name: ADDRESS) : Tree ;


(*
   BuildLessThan - return a tree which computes <
*)

PROCEDURE BuildLessThan (op1, op2: Tree) : Tree ;


(*
   BuildGreaterThan - return a tree which computes >
*)

PROCEDURE BuildGreaterThan (op1, op2: Tree) : Tree ;


(*
   BuildLessThanOrEqual - return a tree which computes <=
*)

PROCEDURE BuildLessThanOrEqual (op1, op2: Tree) : Tree ;


(*
   BuildGreaterThanOrEqual - return a tree which computes >=
*)

PROCEDURE BuildGreaterThanOrEqual (op1, op2: Tree) : Tree ;


(*
   BuildEqualTo - return a tree which computes =
*)

PROCEDURE BuildEqualTo (op1, op2: Tree) : Tree ;


(*
   BuildNotEqualTo - return a tree which computes #
*)

PROCEDURE BuildNotEqualTo (op1, op2: Tree) : Tree ;


(*
   BuildIsSuperset - return a tree which computes:  op1 & op2 == op2
*)

PROCEDURE BuildIsSuperset (op1, op2: Tree) : Tree ;


(*
   BuildIsNotSuperset - return a tree which computes: op1 & op2 != op2
*)

PROCEDURE BuildIsNotSuperset (op1, op2: Tree) : Tree ;


(*
   BuildIsSubset - return a tree which computes:  op1 & op2 == op1
*)

PROCEDURE BuildIsSubset (op1, op2: Tree) : Tree ;


(*
   BuildIsNotSubset - return a tree which computes: op1 & op2 != op1
*)

PROCEDURE BuildIsNotSubset (op1, op2: Tree) : Tree ;


(*
   BuildIfIn - return a tree which computes ((op1 & op2) # 0)
*)

PROCEDURE BuildIfIn (op1, op2: Tree) : Tree ;


(*
   BuildIfNotIn - return a tree which computes ((op1 & op2) = 0)
*)

PROCEDURE BuildIfNotIn (op1, op2: Tree) : Tree ;


(*
   BuildForeachWordInSetDoIfExpr - foreach word in set, type, compute the expression, expr, and if true
                                   goto label.
*)

PROCEDURE BuildForeachWordInSetDoIfExpr (type, op1, op2: Tree;
				         is_op1lvalue, is_op2lvalue,
				         is_op1const, isop2const: BOOLEAN;
                                         expr: BuildExprProcedure; label: ADDRESS) ;


(*
   BuildIndirect - build: ( *target) given that the object to be copied is of, type.
*)

PROCEDURE BuildIndirect (target, type: Tree) : Tree ;


(*
   DoJump - jump to the appropriate label depending whether
            result of the expression is TRUE or FALSE.
*)

PROCEDURE DoJump (exp: Tree; falselabel, truelabel: ADDRESS) ;


(*
   BuildParam - build a list of parameters, ready for a subsequent procedure call.
*)

PROCEDURE BuildParam (param: Tree) ;


(*
   BuildProcedureCall - creates a procedure call from a procedure and
                        parameter list and the return type, rettype.
*)

PROCEDURE BuildProcedureCall (procedure, rettype: Tree) : Tree ;


(*
   BuildIndirectProcedureCall - creates a procedure call from a procedure and
                                parameter list and the return type, rettype.
*)

PROCEDURE BuildIndirectProcedureCall (procedure, rettype: Tree) : Tree ;


(*
   BuildFunctValue - generates code for value := funct(foobar);
*)

PROCEDURE BuildFunctValue (value: Tree) ;


(*
   BuildAsm - generates an inline assembler instruction.
*)

PROCEDURE BuildAsm (instr: Tree; IsVolatile: BOOLEAN; inputs, outputs, trash: Tree) ;


(*
   BuildExpand - a test procedure.
*)

PROCEDURE BuildExpand () : Tree ;


(*
   DebugTree - display the tree, t.
*)

PROCEDURE DebugTree (t: Tree) ;


(*
   ExpandExpressionStatement - maps onto expand_expr_stmt in stmt.c
*)

PROCEDURE ExpandExpressionStatement (t: Tree) ;


(*
   RememberConstant - adds a tree, t, onto the list of constants to be marked
                      whenever the ggc re-marks all used storage. Constants
                      live throughout the whole compilation - and they
                      can be used by many different functions if necessary.
                      It returns, t.
*)

PROCEDURE RememberConstant (t: Tree) : Tree ;


(*
   FoldAndStrip - folds a constant expression tree and strips
                  off any nops.
*)

PROCEDURE FoldAndStrip (t: Tree) : Tree ;


(*
   BuildPushFunctionContext - pushes the current function context.
                              Maps onto push_function_context in ../function.c
*)

PROCEDURE BuildPushFunctionContext ;


(*
   BuildPopFunctionContext - pops the current function context.
                             Maps onto pop_function_context in ../function.c
*)

PROCEDURE BuildPopFunctionContext ;


(*
   BuildCap - builds the Modula-2 function CAP(t) and returns
              the result in a gcc Tree.
*)

PROCEDURE BuildCap (t: Tree) : Tree ;


(*
   InitGlobalContext - initializes a dummy function for the global scope.
*)

PROCEDURE InitGlobalContext ;


END gccgm2.
