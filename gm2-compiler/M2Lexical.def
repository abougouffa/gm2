(* Copyright (C) 2001 Free Software Foundation, Inc. *)
(* This file is part of GNU Modula-2.

GNU Modula-2 is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2, or (at your option) any later
version.

GNU Modula-2 is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with gm2; see the file COPYING.  If not, write to the Free Software
Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. *)
DEFINITION MODULE M2Lexical ;

(*
   Author     : Gaius Mulley
   Title      : M2Lexical
   Date       : 20/5/87
   Description: Performs the interface between the syntax analysis and
                the source file.
   Last update: 30/11/2000
*)

FROM M2Reserved IMPORT toktype ;

EXPORT QUALIFIED GetToken,
                 PutToken,
                 PutTokenLineOffset,
                 InsertToken, InsertTokenAndRewind,
                 CurrentToken, currenttoken,
                 TokenType,
                 TypeOfToken,
                 OpenSource,
                 CloseSource,
                 TokenIs,
                 IsToken,
                 MultiLineQuoteOn, MultiLineQuoteOff,
                 TypeToCard,
                 CardToType,
                 WriteError,
                 WriteErrorFormat1,
                 WriteErrorFormat2,
                 LastError,
                 PedanticError,
                 InternalError,
                 FormatWarningMessage2,
                 NearToken, NearTokens,
                 GetPreviousTokenLineNo,
                 GetLineNo,
                 GetTokenNo,
                 GetTokenOffset,
                 TokenToLineNo,
                 FindFileNameFromToken,
                 GetFileName,
                 WriteToken,
                 WriteFormat1, WriteFormat2 ;


TYPE
   TypeOfToken = (ReservedToken, IntegerToken, RealToken, IdentToken) ;

VAR
   CurrentToken: CARDINAL ;        (* contains the NameKey token string  *)
   TokenType   : TypeOfToken ;
   currenttoken: toktype ;         (* contains the enumerated token type *)


(*
   OpenSource - Attempts to open the source file, a.
                The success of the operation is returned.
*)

PROCEDURE OpenSource (a: ARRAY OF CHAR; module: CARDINAL) : BOOLEAN ;


(*
   CloseSource - Closes the current open file.
*)

PROCEDURE CloseSource ;


(*
   TokenIs - if Name is equal to the CurrentToken the next Token is read
             and true is returned, otherwise false is returned.
*)
           
PROCEDURE TokenIs (Name: CARDINAL) : BOOLEAN ;


(*
   IsToken - returns the result of the comparison between CurrentToken
             and Name.
*)

PROCEDURE IsToken (Name: CARDINAL) : BOOLEAN ;


(*
   GetToken - gets the next token into CurrentToken.
*)

PROCEDURE GetToken ;


(*
   PutToken - pushes a symbol, Name, back onto the input.
              GetToken will set CurrentToken to, Name.
              Index remains unchanged.
*)

PROCEDURE PutToken (Name: CARDINAL; Type: TypeOfToken; token: toktype) ;


(*
   PutTokenLineOffset - pushes a symbol, Name, back onto the input.
                        GetToken will set CurrentToken to, Name.
                        The token current line number is set to Line and
                        character offset, Chr.
*)

PROCEDURE PutTokenLineOffset (Name: CARDINAL; Type: TypeOfToken;
                              Line: CARDINAL; Chr: CARDINAL) ;


(*
   InsertToken - inserts a symbol, Name, infront of the current token
                 ready for the next pass. An attempt at syntax error correction.
*)

PROCEDURE InsertToken (Name: CARDINAL; Type: TypeOfToken; token: toktype) ;


(*
   InsertTokenAndRewind - inserts a symbol, Name, infront of the current token
                          and then moves the token stream back onto the inserted token.
*)

PROCEDURE InsertTokenAndRewind (Name: CARDINAL; Type: TypeOfToken; token: toktype) ;


(*
   TypeToCard - Converts the Type to a CARDINAL.
                Care must be taken when using this procedure.
*)

PROCEDURE TypeToCard (Type: TypeOfToken) : CARDINAL ;


(*
   CardToType - Converts the CARDINAL to a TypeOfToken type.
*)

PROCEDURE CardToType (c: CARDINAL) : TypeOfToken ;


(*
   WriteError - displays the source line and points to the symbol in error.
                The message, a, is displayed.
*)

PROCEDURE WriteError (a: ARRAY OF CHAR) ;


(*
   WriteErrorFormat1 - displays the source line together with the encapsulated
                       format string.
*)

PROCEDURE WriteErrorFormat1 (a: ARRAY OF CHAR; n: CARDINAL) ;


(*
   WriteErrorFormat2 - displays the source line together with the encapsulated
                       format strings.
*)

PROCEDURE WriteErrorFormat2 (a: ARRAY OF CHAR; n1: CARDINAL; n2: CARDINAL) ;


(*
   LastError - writes an error message at the LastNearToken1 position,
               indicated by the last call to NearError.
*)

PROCEDURE LastError (a: ARRAY OF CHAR) ;


(*
   PedanticError - displays the source line and points to the symbol in error.
                   providing the Pedantic flag was set on the user command
                   line.
                   The message, a, is displayed.
*)

PROCEDURE PedanticError (a: ARRAY OF CHAR) ;


(*
   NearToken - informs the lexical analyser which token to examine
               when an error occurs and we are not in a pass.
               If the string, a, is not zero in length then write
               the error now.
*)

PROCEDURE NearToken (a: ARRAY OF CHAR; token: CARDINAL) ;


(*
   NearTokens - informs the lexical analyser which two tokens to examine
                when an error occurs and we are not in a pass.
                If the string, a, is not zero in length then write
                the error now.
*)

PROCEDURE NearTokens (a: ARRAY OF CHAR; token1, token2: CARDINAL) ;


(*
   GetPreviousTokenLineNo - returns the line number of the previous token.
*)

PROCEDURE GetPreviousTokenLineNo () : CARDINAL ;


(*
   GetLineNo - returns the current line number where the symbol occurs in
               the source file.
*)

PROCEDURE GetLineNo () : CARDINAL ;


(*
   GetTokenNo - returns the number of tokens read from
                the source file by the lexical analaysis.
*)

PROCEDURE GetTokenNo () : CARDINAL ;


(*
   GetTokenOffset - returns the character offset of the current token.
*)

PROCEDURE GetTokenOffset () : CARDINAL ;


(*
   TokenToLineNo - returns the line number of the current file for the
                   Token.
*)

PROCEDURE TokenToLineNo (Token: CARDINAL) : CARDINAL ;


(*
   FindFileNameFromToken - fills in the complete FileName for the appropriate
                           name given the token, Token.
*)

PROCEDURE FindFileNameFromToken (VAR FileName: ARRAY OF CHAR;
                                 Token: CARDINAL) ;


(*
   GetFileName - assigns, a, to the current file name.
*)

PROCEDURE GetFileName (VAR a: ARRAY OF CHAR) ;


(*
   FormatWarningMessage2 - displays message, a, with formating arguments, n1, n2, it displays
                           the line number according to the, AtTokenNo.
*)

PROCEDURE FormatWarningMessage2 (a: ARRAY OF CHAR; n1, n2: CARDINAL; AtTokenNo: CARDINAL) ;


(*
   InternalError - displays an internal error message together with the compiler source
                   file and line number.
*)

PROCEDURE InternalError (a: ARRAY OF CHAR; file: ARRAY OF CHAR; line: CARDINAL) ;


(*
   WriteToken - displays the token and its type. A debugging measure.
*)

PROCEDURE WriteToken (Token: CARDINAL; Type: TypeOfToken; Line: CARDINAL) ;


(*
   WriteFormat1 - displays the source module and line together
                  with the encapsulated format string.
*)

PROCEDURE WriteFormat1 (a: ARRAY OF CHAR; n: CARDINAL) ;


(*
   WriteFormat2 - displays the module and line together with the encapsulated
                  format strings.
*)

PROCEDURE WriteFormat2 (a: ARRAY OF CHAR; n1: CARDINAL; n2: CARDINAL) ;


(*
   MultiLineQuoteOn - turns on the ability to handle strings that span multiple
                      lines.
*)

PROCEDURE MultiLineQuoteOn ;


(*
   MultiLineQuoteOff - turns off the ability to handle strings that span multiple
                       lines. (The default).
*)

PROCEDURE MultiLineQuoteOff ;


END M2Lexical.
