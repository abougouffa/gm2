(* gccgm2.def provides a Modula-2 interface to the C file gm2.c.

Copyright (C) 2001-2019 Free Software Foundation, Inc.
Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.

This file is part of GNU Modula-2.

GNU Modula-2 is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GNU Modula-2 is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU Modula-2; see the file COPYING.  If not,
see <https://www.gnu.org/licenses/>.  *)

DEFINITION MODULE gccgm2 ;

(*
    Title      : gccgm2
    Author     : Gaius Mulley
    System     : UNIX (gm2)
    Date       : Sat Jul 24 15:47:03 1999
    Description: provides a Modula-2 interface to the C file gm2.c
*)

FROM SYSTEM IMPORT ADDRESS ;

EXPORT QUALIFIED Tree, Constructor,

                 BuildBinProcedure, BuildUnaryProcedure,
                 BuildSetProcedure,
                 SetFileNameAndLineNo, EmitLineNote,
                 DeclareKnownType, DeclareKnownVariable, DeclareKnownConstant,
                 GetDefaultType, GetCopyOfType,
                 GetIntegerOne, GetIntegerType, GetIntegerZero,
                 GetWordOne, GetWordZero,
                 GetCharType, GetM2CharType, GetVoidType, GetCurrentFunction,
                 GetPointerType, GetPointerZero, GetPointerOne,
                 GetM2IntegerType, GetM2CardinalType,
                 GetByteType, GetCardinalType, GetBitsetType, GetBitnumType,
                 GetLongIntType, GetShortIntType,
                 GetRealType, GetLongRealType, GetProcType,
                 GetM2ShortRealType, GetM2RealType, GetM2LongRealType,
                 GetM2LongIntType, GetM2ShortIntType,
                 GetM2LongCardType, GetM2ShortCardType,
                 GetWordType, GetM2ZType, GetM2RType,
                 GetISOLocType, GetISOByteType, GetISOWordType,
                 GetMinFrom, GetMaxFrom, GetSizeOf, GetSizeOfInBits,
                 GetErrorNode,
                 GetBitsPerWord, GetBitsPerUnit, GetBitsPerInt,
                 GetBitsPerBitset,
                 GetM2Integer8, GetM2Integer16, GetM2Integer32, GetM2Integer64,
                 GetM2Cardinal8, GetM2Cardinal16, GetM2Cardinal32, GetM2Cardinal64,
                 GetM2Word16, GetM2Word32, GetM2Word64,
                 GetM2Bitset8, GetM2Bitset16, GetM2Bitset32,
                 GetM2Real32, GetM2Real64, GetM2Real96, GetM2Real128,
                 GetM2Complex32, GetM2Complex64, GetM2Complex96, GetM2Complex128,
                 GetM2ComplexType, GetM2LongComplexType, GetM2ShortComplexType,
                 GetM2CType,

                 BuildStart, BuildEnd, BuildCallInner,
                 BuildStartEnumeration, BuildEndEnumeration, BuildEnumerator,
                 BuildIntegerConstant, BuildStringConstant, BuildCharConstant,
                 BuildConstLiteralNumber,
                 BuildSubrangeType, BuildArrayIndexType,
                 BuildStartRecord, BuildEndRecord,
                 BuildFieldRecord, ChainOn, ChainOnParamValue, AddStringToTreeList,
                 BuildConstPointerType, BuildPointerType,
                 BuildStartArrayType, BuildEndArrayType, PutArrayType,
                 GetArrayNoOfElements,
                 BuildStartVarient, BuildEndVarient,
                 BuildStartFieldVarient, BuildEndFieldVarient,

                 BuildSetType,
                 BuildStartSetConstructor, BuildSetConstructorElement,
                 BuildEndSetConstructor,
                 BuildStartRecordConstructor, BuildEndRecordConstructor,
                 BuildRecordConstructorElement,
                 BuildStartArrayConstructor, BuildEndArrayConstructor,
                 BuildArrayConstructorElement,
                 BuildStartFunctionType, BuildEndFunctionType,
                 InitFunctionTypeParameters,
                 BuildParameterDeclaration,
                 BuildStartFunctionDeclaration, BuildEndFunctionDeclaration,
                 BuildStartFunctionCode, BuildEndFunctionCode,
                 BuildReturnValueCode, BuildArrayStringConstructor,
                 BuildPackedFieldRecord, BuildSmallestTypeRange,
                 BuildCall2, BuildCall3,
                 BuildAssignmentTree,
                 BuildAdd, BuildSub, BuildMult,
                 BuildDivTrunc, BuildModTrunc,
                 BuildDivFloor, BuildModFloor,
                 BuildLSL, BuildLSR, BuildLogicalShift,
                 BuildLRL, BuildLRR, BuildLogicalRotate,
                 BuildRe, BuildIm, BuildCmplx,
                 BuildLogicalOrAddress,
                 BuildLogicalOr, BuildLogicalAnd,
                 BuildSymmetricDifference, BuildLogicalDifference,
                 BuildConvert, BuildCoerce,
                 BuildAddr, BuildNegate, BuildSetNegate,
                 BuildSize, BuildTBitSize,
                 BuildOffset, BuildOffset1, BuildTrunc,
                 BuildGoto, DeclareLabel,
                 BuildLessThan, BuildGreaterThan,
                 BuildLessThanOrEqual, BuildGreaterThanOrEqual,
                 BuildEqualTo, BuildNotEqualTo,
                 BuildIsSuperset, BuildIsNotSuperset,
                 BuildIsSubset, BuildIsNotSubset,
                 BuildIfConstInVar, BuildIfNotConstInVar,
                 BuildIfVarInVar, BuildIfNotVarInVar,
                 BuildIndirect, BuildArray, BuildComponentRef,
                 DoJump,
                 BuildProcedureCallTree, BuildIndirectProcedureCallTree, BuildParam, BuildFunctValue,
                 BuildStartMainModule, BuildEndMainModule,
                 BuildAsm, DebugTree, GetDeclContext,
                 BuildVariableArrayAndDeclare,
                 RealToTree,
                 RememberConstant,
                 RememberType,
                 RememberInitModuleFunction,
                 FoldAndStrip,
                 BuildBinaryForeachWordDo,
                 BuildUnaryForeachWordDo,
                 BuildIncludeVarVar, BuildExcludeVarVar,
                 BuildIncludeVarConst, BuildExcludeVarConst,
                 BuildIfNotIn, BuildIfIn,
                 BuildForeachWordInSetDoIfExpr,
                 BuildIfInRangeGoto, BuildIfNotInRangeGoto,
                 BuildBinarySetDo,
                 BuildPushFunctionContext, BuildPopFunctionContext,
                 BuildCap, BuildAbs, BuildTypeDeclaration,
                 BuildIfThenElseEnd, BuildIfThenDoEnd,
                 BuildStartType, BuildEndType,
                 IsTrue, IsFalse,

                 AreConstantsEqual, AreRealOrComplexConstantsEqual,
                 DetermineSign, CompareTrees,
                 GetBooleanType, GetBooleanFalse, GetBooleanTrue,
                 GetPackedBooleanType,
                 ConvertConstantAndCheck, ConvertString,
                 DetermineSizeOfConstant, StringLength,
                 ToWord,
                 AddStatement, GetTreeType,
                 BuildTryCatch, BuildThrow,
                 InitGlobalContext, FinishBackend, GarbageCollect,
                 TreeOverflow, RemoveOverflow,
                 SetLastFunction,
                 SetFlagUnitAtATime, MarkFunctionReferenced,
                 SetAlignment, BuildNumberOfArrayElements,
                 SetDeclPacked, SetTypePacked, SetRecordFieldOffset,
                 InitSystemTypes ;


TYPE
   Tree                = ADDRESS ;
   Constructor         = ADDRESS ;
   BuildBinProcedure   = PROCEDURE (Tree, Tree, BOOLEAN) : Tree ;
   BuildUnaryProcedure = PROCEDURE (Tree, BOOLEAN) : Tree ;
   BuildExprProcedure  = PROCEDURE (Tree, Tree) : Tree ;
   BuildSetProcedure   = PROCEDURE (Tree, Tree, Tree, Tree, BOOLEAN) : Tree ;


(*
   SetFileNameAndLineNo - assigns a filename and line number to the GCC
                          global variables. Remember that the string contents
                          addressed by fn must not be overwritten.

                          SetFileNameAndLineNo - should be used when declaring data types,
                          procedures, variables etc.
*)

PROCEDURE SetFileNameAndLineNo (fn: ADDRESS; line: CARDINAL) ;


(*
   EmitLineNote - emits line and file information to gcc whilst constructing code.
                  Should be used when generating code (after a call to SetFileNameAndLineNo).
*)

PROCEDURE EmitLineNote (fn: ADDRESS; line: CARDINAL) ;


(*
   The following functions allow access to some global variables,
   which are used in the declaration of base types.
*)

PROCEDURE DeclareKnownType       (name: ADDRESS; type: Tree) : Tree ;
PROCEDURE BuildStartType         (name: ADDRESS; type: Tree) : Tree ;
PROCEDURE BuildEndType           (type: Tree) : Tree ;
PROCEDURE DeclareKnownConstant   (type: Tree  ; value: Tree) : Tree ;
PROCEDURE DeclareKnownVariable   (name: ADDRESS; type: Tree;
                                  isexported, isimported, istemporary, isglobal: BOOLEAN;
                                  scope: Tree) : Tree ;
PROCEDURE GetCopyOfType          (t : Tree) : Tree ;
PROCEDURE GetDefaultType         (name: ADDRESS; type: Tree) : Tree ;
PROCEDURE GetIntegerType         () : Tree ;
PROCEDURE GetCharType            () : Tree ;
PROCEDURE GetM2CharType          () : Tree ;
PROCEDURE GetM2IntegerType       () : Tree ;
PROCEDURE GetM2CardinalType      () : Tree ;
PROCEDURE GetByteType            () : Tree ;
PROCEDURE GetVoidType            () : Tree ;
PROCEDURE GetPointerType         () : Tree ;
PROCEDURE GetCardinalType        () : Tree ;
PROCEDURE GetBitsetType          () : Tree ;
PROCEDURE GetBitnumType          () : Tree ;
PROCEDURE GetRealType            () : Tree ;
PROCEDURE GetLongRealType        () : Tree ;
PROCEDURE GetLongIntType         () : Tree ;
PROCEDURE GetShortIntType        () : Tree ;
PROCEDURE GetM2ShortRealType     () : Tree ;
PROCEDURE GetM2RealType          () : Tree ;
PROCEDURE GetM2LongRealType      () : Tree ;
PROCEDURE GetM2LongIntType       () : Tree ;
PROCEDURE GetM2LongCardType      () : Tree ;
PROCEDURE GetM2ShortIntType      () : Tree ;
PROCEDURE GetM2ShortCardType     () : Tree ;
PROCEDURE GetM2ZType             () : Tree ;
PROCEDURE GetM2RType             () : Tree ;
PROCEDURE GetWordType            () : Tree ;
PROCEDURE GetProcType            () : Tree ;
PROCEDURE GetISOLocType          () : Tree ;
PROCEDURE GetISOByteType         () : Tree ;
PROCEDURE GetISOWordType         () : Tree ;

PROCEDURE GetM2Integer8          () : Tree ;
PROCEDURE GetM2Integer16         () : Tree ;
PROCEDURE GetM2Integer32         () : Tree ;
PROCEDURE GetM2Integer64         () : Tree ;
PROCEDURE GetM2Cardinal8         () : Tree ;
PROCEDURE GetM2Cardinal16        () : Tree ;
PROCEDURE GetM2Cardinal32        () : Tree ;
PROCEDURE GetM2Cardinal64        () : Tree ;
PROCEDURE GetM2Bitset8           () : Tree ;
PROCEDURE GetM2Bitset16          () : Tree ;
PROCEDURE GetM2Bitset32          () : Tree ;
PROCEDURE GetM2Word16            () : Tree ;
PROCEDURE GetM2Word32            () : Tree ;
PROCEDURE GetM2Word64            () : Tree ;
PROCEDURE GetM2Real32            () : Tree ;
PROCEDURE GetM2Real64            () : Tree ;
PROCEDURE GetM2Real96            () : Tree ;
PROCEDURE GetM2Real128           () : Tree ;
PROCEDURE GetM2ComplexType       () : Tree ;
PROCEDURE GetM2LongComplexType   () : Tree ;
PROCEDURE GetM2ShortComplexType  () : Tree ;
PROCEDURE GetM2CType             () : Tree ;
PROCEDURE GetM2Complex32         () : Tree ;
PROCEDURE GetM2Complex64         () : Tree ;
PROCEDURE GetM2Complex96         () : Tree ;
PROCEDURE GetM2Complex128        () : Tree ;

PROCEDURE GetIntegerZero         () : Tree ;
PROCEDURE GetIntegerOne          () : Tree ;
PROCEDURE GetWordZero            () : Tree ;
PROCEDURE GetWordOne             () : Tree ;
PROCEDURE GetPointerZero         () : Tree ;
PROCEDURE GetPointerOne          () : Tree ;
PROCEDURE GetCurrentFunction     () : Tree ;
PROCEDURE GetErrorNode           () : Tree ;


(*
   GetMinFrom - given a, type, return a constant representing the minimum
                legal value.
*)

PROCEDURE GetMinFrom (type: Tree) : Tree ;


(*
   GetMaxFrom - given a, type, return a constant representing the maximum
                legal value.
*)

PROCEDURE GetMaxFrom (type: Tree) : Tree ;


(*
   GetBitsPerWord - returns a CARDINAL indicating the number of bits per word.
*)

PROCEDURE GetBitsPerWord () : CARDINAL ;


(*
   GetBitsPerUnit - returns a CARDINAL indicating the number of bits per unit.
*)

PROCEDURE GetBitsPerUnit () : CARDINAL ;


(*
   GetBitsPerInt - returns a CARDINAL indicating the number of bits per INTEGER.
*)

PROCEDURE GetBitsPerInt () : CARDINAL ;


(*
   GetBitsPerBitset - returns a CARDINAL indicating the number of bits per BITSET.
*)

PROCEDURE GetBitsPerBitset () : CARDINAL ;


(*
   GetSizeOf - returns a Tree containing the sizeof(type).
*)

PROCEDURE GetSizeOf (type: Tree) : Tree ;


(*
   GetSizeOfInBits - returns a Tree containing the number of bits used
                     to store, type.
*)

PROCEDURE GetSizeOfInBits (type: Tree) : Tree ;


(*
   BuildTBitSize - returns the minimum number of bits to represent, type.
*)

PROCEDURE BuildTBitSize (type: Tree) : Tree ;


(*
   BuildBinaryForeachWordDo - provides the large set operators. Each word (or less)
                              of the set can be calculated by binop.
                              This procedure runs along each word of the large set
                              invoking the binop.
*)

PROCEDURE BuildBinaryForeachWordDo (type, op1, op2, op3: Tree;
                                    binop: BuildBinProcedure;
                                    is_op1lvalue,
                                    is_op2lvalue,
                                    is_op3lvalue,
                                    is_op1_const,
                                    is_op2_const,
                                    is_op3_const: BOOLEAN) ;


(*
   BuildUnaryForeachWordDo - provides the large set operators.
                             Each word (or less)
                             of the set can be calculated by unop.
                             This procedure runs along each word of
                             the large set invoking the unop.
*)

PROCEDURE BuildUnaryForeachWordDo (type, op1, op2: Tree;
                                   unop: BuildUnaryProcedure;
                                   is_op1lvalue, is_op2lvalue: BOOLEAN;
                                   is_op1_const, is_op2_const: BOOLEAN) ;


(*
   BuildExcludeVarConst - builds the EXCL(op1, 1<<op2) operation for a large/small set. Large
                          sets call this routine to exclude the bit in the particular field.
                          op2 is a constant. (which indicates the bit 0..BitsPerWord-1 to unset
                          in fieldno).
                          op1 is the set (possibly a large set)
*)

PROCEDURE BuildExcludeVarConst (type, op1, op3: Tree; is_lvalue: BOOLEAN; fieldno: CARDINAL) ;


(*
   BuildIncludeVarConst - builds the INCL(op1, 1<<op2) operation for a large/small set. Large
                          sets call this routine to include the bit in the particular field.
                          op2 is a constant. (which indicates the bit 0..BitsPerWord-1 to set
                          in fieldno).
                          op1 is the set (possibly a large set)
*)

PROCEDURE BuildIncludeVarConst (type, op1, op3: Tree; is_lvalue: BOOLEAN; fieldno: CARDINAL) ;


(*
   BuildIncludeVarVar - builds the INCL(varset, 1<<varel) operation for a small and large sets.
                        op2 is a variable.
*)

PROCEDURE BuildIncludeVarVar (type, varset, varel: Tree; is_lvalue: BOOLEAN; low: Tree) ;


(*
   BuildExcludeVarVar - builds the EXCL(varset, 1<<varel) operation for a small and large sets.
                        varel is a variable.
*)

PROCEDURE BuildExcludeVarVar (type, varset, varel: Tree; is_lvalue: BOOLEAN; low: Tree) ;


(*
   BuildIfConstInVar - generates: if constel in varset then goto label.
*)

PROCEDURE BuildIfConstInVar (type, varset, constel: Tree; is_lvalue: BOOLEAN; fieldno: CARDINAL;
                             label: ADDRESS) ;


(*
   BuildIfNotConstInVar - generates: if not (constel in varset) then goto label.
*)

PROCEDURE BuildIfNotConstInVar (type, varset, constel: Tree; is_lvalue: BOOLEAN; fieldno: CARDINAL;
                                label: ADDRESS) ;


(*
   BuildIfVarInVar - generates: if varel in varset then goto label
*)

PROCEDURE BuildIfVarInVar (type, varset, varel: Tree; is_lvalue: BOOLEAN;
                           low, high: Tree; label: ADDRESS) ;


(*
   BuildIfNotVarInVar - generates: if not (varel in varset) then goto label
*)

PROCEDURE BuildIfNotVarInVar (type, varset, varel: Tree; is_lvalue: BOOLEAN;
                              low, high: Tree; label: ADDRESS) ;


(*
   BuildIfInRangeGoto - if var is in the range low..high then goto label
*)

PROCEDURE BuildIfInRangeGoto (var, low, high: Tree; label: ADDRESS) ;


(*
   BuildIfNotInRangeGoto - if var is not in the range low..high then goto label
*)

PROCEDURE BuildIfNotInRangeGoto (var, low, high: Tree; label: ADDRESS) ;

(*
   BuildBinarySetDo - if the size of the set is <= TSIZE(WORD) then
                         op1 := binop(op2, op3)
                      else
                         call funcname(op1, op2, op3)
*)

PROCEDURE BuildBinarySetDo (settype,
                            op1, op2, op3: Tree;
                            binop: BuildSetProcedure;
                            is_op1lvalue,
                            is_op2lvalue,
                            is_op3lvalue: BOOLEAN;
                            nBits, unbounded: Tree ;
                            varproc, leftproc, rightproc: Tree) ;


(*
   AreConstantsEqual - maps onto tree.c (tree_int_cst_equal). It returns
                       TRUE if the value of e1 is the same as e2.
*)

PROCEDURE AreConstantsEqual (e1, e2: Tree) : BOOLEAN ;


(*
   AreRealOrComplexConstantsEqual - returns TRUE if constants,
                                    e1 and e2 are equal according
                                    to IEEE rules.  This does not
                                    perform bit equivalence for
                                    example IEEE states that
                                    -0 == 0 and NaN != NaN.
*)

PROCEDURE AreRealOrComplexConstantsEqual (t1, t2: Tree) : BOOLEAN ;


(*
   DetermineSign - returns -1 if e<0
                            0 if e==0
                            1 if e>0
 
                   an unsigned constant will never return -1
*)

PROCEDURE DetermineSign (e: Tree) : INTEGER ;


(*
   CompareTrees - returns -1 if e1 < e2, 0 if e1 == e2, and 1 if e1 > e2.
*)

PROCEDURE CompareTrees (e1, e2: Tree) : INTEGER ;


(*
   RealToTree - convert a real number into a Tree.
*)

PROCEDURE RealToTree (name: ADDRESS) : Tree ;


(*
   BuildStart - builds the module prologue. We tell gcc whether
                it is an inner module or not, which determines whether the
                initialization code is exported (not inner).
*)

PROCEDURE BuildStart (name: ADDRESS; line: CARDINAL; inner: BOOLEAN) : Tree ;


(*
   BuildEnd - ends the module prologue.
*)

PROCEDURE BuildEnd (t: Tree; nested: BOOLEAN) ;


(*
   BuildCallInner - builds a call to an init or finalization
                    function, funct. This function
                    has no return type and no parameters.
*)

PROCEDURE BuildCallInner (funct: Tree) ;


(*
   BuildStartMainModule - creates the global scope and expands all global
                          variables ready for main module compilation.
*)

PROCEDURE BuildStartMainModule ;


(*
   BuildEndMainModule - tidies up the end of the main module. It moves
                        back to global scope.
*)

PROCEDURE BuildEndMainModule ;


(*
   BuildStartEnumeration - create an enumerated type in gcc.
*)

PROCEDURE BuildStartEnumeration (name: ADDRESS; ispacked: BOOLEAN) : Tree ;


(*
   BuildEndEnumeration - finish building an enumerated type in gcc.
                         enumvalues, is the chained list of enumerator
                         fields.
                         The finished enumtype is returned.
*)

PROCEDURE BuildEndEnumeration (enumtype: Tree; enumvalues: Tree) : Tree ;


(*
   BuildEnumerator - builds an enumerator in the current enumerated type
                     and returns the enumerator.
                     enumvalues is the current list of enumerator fields.
                     This should be initially set to NULL_TREE by the
                     caller and BuildEnumerator chains the enumerator
                     fields one by one to this list.
*)

PROCEDURE BuildEnumerator (name: ADDRESS;
                           value: Tree;
                           VAR enumvalues: Tree) : Tree ;


(*
   BuildIntegerConstant - creates an integer constant and returns it.
*)

PROCEDURE BuildIntegerConstant (value: INTEGER) : Tree ;


(*
   BuildStringConstant - creates a string constant given a, string,
                         and, length.
*)

PROCEDURE BuildStringConstant (string: ADDRESS; length: CARDINAL) : Tree ;


(*
   BuildCharConstant - creates a character constant given a, string.
*)

PROCEDURE BuildCharConstant (string: ADDRESS) : Tree ;


(*
   BuildConstLiteralNumber - converts a string, str, into a tree.
*)

PROCEDURE BuildConstLiteralNumber (str: ADDRESS; base: CARDINAL) : Tree ;


(*
    floating point constant creation
*)

PROCEDURE BuildRealConstant     (value: LONGREAL) : Tree ;
PROCEDURE BuildLongRealConstant (value: LONGREAL) : Tree ;


(*
   ConvertConstantAndCheck - in Modula-2 sementics: return( VAL(type, expr) )
                             Only to be used for a constant expr,
                             overflow checking is performed. 
*)

PROCEDURE ConvertConstantAndCheck (type, expr: Tree) : Tree ;


(*
   ConvertString - converts string, expr, into a string
                   of type, type.
*)

PROCEDURE ConvertString (type: Tree; expr: Tree) : Tree ;


(*
   DetermineSizeOfConstant - given, str, and, base, fill in
                             needsLong and needsUnsigned appropriately.
*)

PROCEDURE DetermineSizeOfConstant (str: ADDRESS; base: INTEGER;
                                   VAR needsLong, needsUnsigned: INTEGER) ;

(*
   StringLength - returns an unsigned int which is the length
                  of, string.
*)

PROCEDURE StringLength (string: Tree) : CARDINAL ;


(*
   ToWord - converts an expression (Integer or Ordinal type) into
            a WORD.
*)

PROCEDURE ToWord (expr: Tree) : Tree ;


(*
   GetBooleanType - returns the GCC boolean type, tree.
*)

PROCEDURE GetBooleanType () : Tree ;


(*
   GetBooleanFalse - returns the GCC tree representing false.
*)

PROCEDURE GetBooleanFalse () : Tree ;


(*
   GetBooleanTrue - returns the GCC tree representing true.
*)

PROCEDURE GetBooleanTrue () : Tree ;


(*
   GetPackedBooleanType - returns a boolean type which will occupy
                          a single bit.
*)

PROCEDURE GetPackedBooleanType () : Tree ;


(*
   BuildSubrangeType - creates a subrange of, type, with, lowval, highval.
*)

PROCEDURE BuildSubrangeType (name: ADDRESS;
                             type, lowval, highval: Tree) : Tree ;


(*
   BuildSmallestTypeRange - returns the smallest INTEGER_TYPE which is
                            sufficient to contain values: low..high.
*)

PROCEDURE BuildSmallestTypeRange (lowval, highval: Tree) : Tree ;


(*
   BuildArrayIndexType - creates an integer index which accesses an array.
                         low and high are the min, max elements of the array.
*)

PROCEDURE BuildArrayIndexType (low, high: Tree) : Tree ;


(*
   BuildVariableArrayAndDeclare - creates a variable length array.
                                  high is the maximum legal elements (which is a runtime variable).
                                  This creates and array index, array type and local variable.
*)

PROCEDURE BuildVariableArrayAndDeclare (elementtype, high: Tree; name: ADDRESS; scope: Tree) : Tree ;


(*
   GetArrayNoOfElements - returns the number of elements in arraytype.
*)

PROCEDURE GetArrayNoOfElements (arraytype: Tree) : Tree ;


(*
   gccgm2_BuildStartVarient - starts building the varient (or varient field).
*)

PROCEDURE BuildStartVarient (name: ADDRESS) : Tree ;


(*
   BuildEndVarient - finish the varientField by calling
                     decl_finish and also finish the type of
                     varientField (which is a union).
*)

PROCEDURE BuildEndVarient (varientField, varientList: Tree; isPacked: BOOLEAN) : Tree ;


(*
   BuildStartFieldVarient - builds a field varient record.
                            It creates a record field which
                            has a, name, and whose type is a
                            record.
*)

PROCEDURE BuildStartFieldVarient (name: ADDRESS) : Tree ;


(*
   BuildEndFieldVarient - finish the varientField by calling
                          decl_finish and also finish the type of
                          varientField (which is a record).
*)

PROCEDURE BuildEndFieldVarient (varientField, varientList: Tree; isPacked: BOOLEAN) : Tree ;


(*
   BuildStartRecord - creates a record with, name.
*)

PROCEDURE BuildStartRecord (name: ADDRESS) : Tree ;


(*
   BuildEndRecord - finishes constructing a varient record or a record.
                    t should be the return value from BuildStartRecord and
                    fieldlist is created from BuildFieldRecord.
*)

PROCEDURE BuildEndRecord (t: Tree; fieldlist: Tree; isPacked: BOOLEAN) : Tree ;


(*
   BuildFieldRecord - builds a record field given a, name, (which maybe NIL) and
                      a type. It returns a new field. This field maybe chained on
                      to other field to build a fieldlist.
*)

PROCEDURE BuildFieldRecord (name: ADDRESS; type: Tree) : Tree ;


(*
   ChainOn - builds a list of t1, t2 and returns the new list.
*)

PROCEDURE ChainOn (t1, t2: Tree) : Tree ;


(*
   ChainOnParamValue - adds a list node {{name, str}, value} into the tree list.
*)

PROCEDURE ChainOnParamValue (list, name, str, value: Tree) : Tree ;


(*
   AddStringToTreeList - adds, string, to list.
*)

PROCEDURE AddStringToTreeList (list, string: Tree) : Tree ;


(*
   BuildPointerType - returns a new type which is declared as a pointer to totype.
*)

PROCEDURE BuildPointerType (totype: Tree) : Tree ;


(*
   BuildConstPointerType - returns a new type which is declared as a pointer to totype.
*)

PROCEDURE BuildConstPointerType (totype: Tree) : Tree ;


(*
   BuildStartArrayType - creates an array with an indextype and elttype.  The front end
                         symbol, type, is also passed to allow the gccgm2 to return the
                         canonical edition of the array type even if the GCC elttype is
                         NULL_TREE.
*)

PROCEDURE BuildStartArrayType (indextype: Tree; elttype: Tree; type: CARDINAL) : Tree ;


(*
   BuildEndArrayType - creates an array which is indexed by IndexType and
                       contains elements, ElementType.
*)

PROCEDURE BuildEndArrayType (t: Tree; ElementType, IndexType: Tree; type: CARDINAL) : Tree ;


(*
   PutArrayType - assigns the tree, type, to the array as:
                  ARRAY [..] OF type
*)

PROCEDURE PutArrayType (array: Tree; type: Tree) ;


(*
   BuildSetType - creates a SET OF [low..high] where low and high
                  both have type, type.
*)

PROCEDURE BuildSetType (name: ADDRESS; type, low, high: Tree) : Tree ;


(*
   BuildStartSetConstructor - starts to create a set constant.
                              Remember that type is really a record type.
*)

PROCEDURE BuildStartSetConstructor (type: Tree) : Constructor ;


(*
   BuildSetConstructorElement - adds, value, to the constructor_element_list.
*)

PROCEDURE BuildSetConstructorElement (p: Constructor; value: Tree) ;


(*
   BuildEndSetConstructor - finishes building a set constant.
*)

PROCEDURE BuildEndSetConstructor (p: Constructor) : Tree ;


(*
   BuildStartRecordConstructor - initializes a record compound
                                 constructor frame.
*)

PROCEDURE BuildStartRecordConstructor (t: Tree) : Constructor ;


(*
   BuildEndRecordConstructor - returns a tree containing the record compound literal.
*)

PROCEDURE BuildEndRecordConstructor (p: Constructor) : Tree ;


(*
   BuildRecordConstructorElement - adds, value, to the constructor_element_list.
*)

PROCEDURE BuildRecordConstructorElement (p: Constructor; value: Tree) ;


(*
   BuildStartArrayConstructor - initializes an array compound
                                constructor frame.
*)

PROCEDURE BuildStartArrayConstructor (t: Tree) : Constructor ;


(*
   BuildEndArrayConstructor - returns a tree containing the array
                              compound literal.
*)

PROCEDURE BuildEndArrayConstructor (p: Constructor) : Tree ;


(*
   BuildArrayConstructorElement - adds, value, to the constructor_element_list.
*)

PROCEDURE BuildArrayConstructorElement (p: Constructor; value, indice: Tree) ;


(*
   BuildStartFunctionType - starts the building of a function type.
*)

PROCEDURE BuildStartFunctionType (name: ADDRESS) : Tree ;


(*
   BuildEndFunctionType - build a function type, func, which would return a, value.
                          The arguments have been created by BuildParameterDeclaration.
*)

PROCEDURE BuildEndFunctionType (func, value: Tree) : Tree ;


(*
   InitFunctionTypeParameters - resets the current function type parameter list.
*)

PROCEDURE InitFunctionTypeParameters (usesVarArgs: BOOLEAN) ;


(*
   BuildParameterDeclaration - creates and returns one parameter from, name, and, type.
                               It appends this parameter to the internal param_type_list.
                               If name is nul then we assume we are creating a function
                               type declaration and we ignore names.
*)

PROCEDURE BuildParameterDeclaration (name: ADDRESS; type: Tree;
                                     isreference: BOOLEAN) : Tree ;


(*
   BuildStartFunctionDeclaration - initializes global variables ready for building
                                   a function declaration.
*)

PROCEDURE BuildStartFunctionDeclaration (usesVarArgs: BOOLEAN) ;


(*
   BuildEndFunctionDeclaration - build a function which will return a value of returntype.
                                 The arguments have been created by BuildParameterDeclaration.
*)

PROCEDURE BuildEndFunctionDeclaration (name: ADDRESS;
                                       returntype: Tree;
                                       isexternal, isnested, ispublic: BOOLEAN) : Tree ;


(*
   BuildStartFunctionCode - generate function entry code.
*)

PROCEDURE BuildStartFunctionCode (fndecl: Tree; isexported, isinline: BOOLEAN) ;


(*
   BuildEndFunctionCode - generates the function epilogue.
*)

PROCEDURE BuildEndFunctionCode (fndecl: Tree; nested: BOOLEAN) ;


(*
   BuildArrayStringConstructor - generates an array constructor consisting
                                 of the first, n, characters, of, str.
*)

PROCEDURE BuildArrayStringConstructor (arrayType, str, length: Tree) : Tree ;


(*
   BuildReturnValueCode - generates the code associated with: RETURN( value )
*)

PROCEDURE BuildReturnValueCode (fndecl, value: Tree) ;


(*
   BuildAssignmentTree - generates code for, des := expr and returns, des.
*)

PROCEDURE BuildAssignmentTree (des, expr: Tree) : Tree ;


(*
   IsTrue - returns TRUE if, t, is known to be TRUE.
*)

PROCEDURE IsTrue (t: Tree) : BOOLEAN ;


(*
   IsFalse - returns FALSE if, t, is known to be FALSE.
*)

PROCEDURE IsFalse (t: Tree) : BOOLEAN ;


(*
   BuildAdd - build an addition tree.
*)

PROCEDURE BuildAdd (op1, op2: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildSub - build a subtraction tree.
*)

PROCEDURE BuildSub (op1, op2: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildMult - build a multiplication tree.
*)

PROCEDURE BuildMult (op1, op2: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildDivTrunc - build a division tree.
*)

PROCEDURE BuildDivTrunc (op1, op2: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildModTrunc - build a modulus tree.
*)

PROCEDURE BuildModTrunc (op1, op2: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildDivFloor - build a division tree.
*)

PROCEDURE BuildDivFloor (op1, op2: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildModFloor - build a modulus tree.
*)

PROCEDURE BuildModFloor (op1, op2: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildLSL - build a << tree  ie  (op1 << op2).
*)

PROCEDURE BuildLSL (op1, op2: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildLSR - build a >> tree  ie  (op1 << op2).
*)

PROCEDURE BuildLSR (op1, op2: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildLRL - build a rotate tree  ie  (op1 rotated left by op2 bits).
*)

PROCEDURE BuildLRL (op1, op2: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildLRR - build a rotate tree  ie  (op1 rotated right by op2 bits).
*)

PROCEDURE BuildLRR (op1, op2: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildLogicalRotate - builds the ISO Modula-2 ROTATE operator
                        for a fundamental data type.
*)

PROCEDURE BuildLogicalRotate (op1, op2, op3, nBits: Tree;
                              needconvert: BOOLEAN) : Tree ;


(*
   BuildLogicalShift - builds the ISO Modula-2 SHIFT operator
                       for a fundamental data type.
*)

PROCEDURE BuildLogicalShift (op1, op2, op3, nBits: Tree;
                             needconvert: BOOLEAN) : Tree ;


(*
   BuildLogicalOrAddress - build and return a logical or tree. ie (op1 || op2)
*)

PROCEDURE BuildLogicalOrAddress (op1, op2: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildLogicalOr - build and return a logical or tree. ie (op1 || op2)
*)

PROCEDURE BuildLogicalOr (op1, op2: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildLogicalAnd - build and return a logical and tree. ie (op1 && op2)
*)

PROCEDURE BuildLogicalAnd (op1, op2: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildNegate - builds a negate expression and returns the tree.
*)

PROCEDURE BuildNegate (op1: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildSetNegate - builds a set negate expression and returns the tree.
*)

PROCEDURE BuildSetNegate (op1: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildSize - builds a SIZE function expression and returns the tree.
*)

PROCEDURE BuildSize (op1: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildTrunc - returns an integer expression from a REAL or LONGREAL op1.
*)

PROCEDURE BuildTrunc (op1: Tree) : Tree ;


(*
   BuildAddr - builds an expression which calculates the address of op1 and returns the tree.
*)

PROCEDURE BuildAddr (op1: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildOffset - builds an expression containing the number of bytes the field
                 is offset from the start of the record structure.
                 The expression is returned.
*)

PROCEDURE BuildOffset (record, field: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildOffset1 - builds an expression containing the number of bytes the field
                  is offset from the start of the record structure.
                  This function is the same as the above, except that it
                  derives the record from the field and then calls BuildOffset.
                  The expression is returned.
*)

PROCEDURE BuildOffset1 (field: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildSymmetricDifference - build and return a symmetric difference tree. (op1 xor op2)
*)

PROCEDURE BuildSymmetricDifference (op1, op2: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildLogicalDifference - build and return a logical difference tree.
                            (op1 and (not op2))
*)

PROCEDURE BuildLogicalDifference (op1, op2: Tree; needconvert: BOOLEAN) : Tree ;


(*
   BuildConvert - build and return tree VAL(op1, op2)
                  where op1 is the type to which op2 is to be converted.
                  checkOverflow determines whether to suppress any overflow.
*)

PROCEDURE BuildConvert (op1, op2: Tree; checkOverflow: BOOLEAN) : Tree ;


(*
   BuildCoerce - returns a tree containing the cast op1 := op2.
*)

PROCEDURE BuildCoerce (op1, op2, op3: Tree) : Tree ;


(*
   BuildRe - builds an expression for the function RE.
*)

PROCEDURE BuildRe (op1: Tree) : Tree ;


(*
   BuildIm - builds an expression for the function IM.
*)

PROCEDURE BuildIm (op1: Tree) : Tree ;


(*
   BuildCmplx - builds an expression for the function CMPLX.
*)

PROCEDURE BuildCmplx (type, real, imag: Tree) : Tree ;


(*
   BuildGoto - builds a goto operation.
*)

PROCEDURE BuildGoto (name: ADDRESS) ;


(*
   DeclareLabel - create a label, name.
*)

PROCEDURE DeclareLabel (name: ADDRESS) ;


(*
   BuildLessThan - return a tree which computes <
*)

PROCEDURE BuildLessThan (op1, op2: Tree) : Tree ;


(*
   BuildGreaterThan - return a tree which computes >
*)

PROCEDURE BuildGreaterThan (op1, op2: Tree) : Tree ;


(*
   BuildLessThanOrEqual - return a tree which computes <=
*)

PROCEDURE BuildLessThanOrEqual (op1, op2: Tree) : Tree ;


(*
   BuildGreaterThanOrEqual - return a tree which computes >=
*)

PROCEDURE BuildGreaterThanOrEqual (op1, op2: Tree) : Tree ;


(*
   BuildEqualTo - return a tree which computes =
*)

PROCEDURE BuildEqualTo (op1, op2: Tree) : Tree ;


(*
   BuildNotEqualTo - return a tree which computes #
*)

PROCEDURE BuildNotEqualTo (op1, op2: Tree) : Tree ;


(*
   BuildIsSuperset - return a tree which computes:  op1 & op2 == op2
*)

PROCEDURE BuildIsSuperset (op1, op2: Tree) : Tree ;


(*
   BuildIsNotSuperset - return a tree which computes: op1 & op2 != op2
*)

PROCEDURE BuildIsNotSuperset (op1, op2: Tree) : Tree ;


(*
   BuildIsSubset - return a tree which computes:  op1 & op2 == op1
*)

PROCEDURE BuildIsSubset (op1, op2: Tree) : Tree ;


(*
   BuildIsNotSubset - return a tree which computes: op1 & op2 != op1
*)

PROCEDURE BuildIsNotSubset (op1, op2: Tree) : Tree ;


(*
   BuildIfIn - return a tree which computes ((op1 & op2) # 0)
*)

PROCEDURE BuildIfIn (op1, op2: Tree) : Tree ;


(*
   BuildIfNotIn - return a tree which computes ((op1 & op2) = 0)
*)

PROCEDURE BuildIfNotIn (op1, op2: Tree) : Tree ;


(*
   BuildForeachWordInSetDoIfExpr - foreach word in set, type, compute the expression, expr, and if true
                                   goto label.
*)

PROCEDURE BuildForeachWordInSetDoIfExpr (type, op1, op2: Tree;
				         is_op1lvalue, is_op2lvalue,
				         is_op1const, isop2const: BOOLEAN;
                                         expr: BuildExprProcedure; label: ADDRESS) ;


(*
   BuildArray - returns a tree which accesses array[index]
                given, lowIndice, and, elementSize.
*)

PROCEDURE BuildArray (type, array, index, lowIndice, elementSize: Tree) : Tree ;


(*
   BuildComponentRef - returns a tree representing (record.field).
*)

PROCEDURE BuildComponentRef (record, field: Tree) : Tree ;


(*
   BuildIndirect - build: ( *target) given that the object to be copied is of, type.
*)

PROCEDURE BuildIndirect (target, type: Tree) : Tree ;


(*
   DoJump - jump to the appropriate label depending whether
            result of the expression is TRUE or FALSE.
*)

PROCEDURE DoJump (exp: Tree; falselabel, truelabel: ADDRESS) ;


(*
   BuildParam - build a list of parameters, ready for a subsequent procedure call.
*)

PROCEDURE BuildParam (param: Tree) ;


(*
   BuildProcedureCallTree - creates a procedure call from a procedure and
                        parameter list and the return type, rettype.
*)

PROCEDURE BuildProcedureCallTree (procedure, rettype: Tree) : Tree ;


(*
   BuildIndirectProcedureCallTree - creates a procedure call from a procedure and
                                parameter list and the return type, rettype.
*)

PROCEDURE BuildIndirectProcedureCallTree (procedure, rettype: Tree) : Tree ;


(*
   BuildFunctValue - generates code for value := funct(foobar);
*)

PROCEDURE BuildFunctValue (value: Tree) ;


(*
   BuildCall2 - builds a tree representing:  function(arg1, arg2).
*)

PROCEDURE BuildCall2 (function: Tree; arg1, arg2: Tree) : Tree ;


(*
   BuildCall3 - builds a tree representing:  function(arg1, arg2, arg3).
*)

PROCEDURE BuildCall3 (function: Tree; arg1, arg2, arg3: Tree) : Tree ;



(*
   BuildIfThenDoEnd - returns a tree which will only execute
                      statement, thenblock, if, condition, is true.
*)

PROCEDURE BuildIfThenDoEnd (condition, thenblock: Tree) : Tree ;


(*
   BuildIfThenElseEnd - returns a tree which will execute
                        thenblock or elseblock depending upon,
                        condition.
*)

PROCEDURE BuildIfThenElseEnd (condition, thenblock, elseblock: Tree) : Tree ;


(*
   BuildAsm - generates an inline assembler instruction.
*)

PROCEDURE BuildAsm (instr: Tree; IsVolatile, IsSimple: BOOLEAN; inputs, outputs, trash: Tree) ;


(*
   DebugTree - display the tree, t.
*)

PROCEDURE DebugTree (t: Tree) ;


(*
   GetDeclContext - returns the DECL_CONTEXT of tree, t.
*)

PROCEDURE GetDeclContext (t: Tree) : Tree ;


(*
   AddStatement - maps onto add_stmt.
*)

PROCEDURE AddStatement (t: Tree) ;


(*
   RememberConstant - adds a tree, t, onto the list of constants to be marked
                      whenever the ggc re-marks all used storage. Constants
                      live throughout the whole compilation - and they
                      can be used by many different functions if necessary.
                      It returns, t.
*)

PROCEDURE RememberConstant (t: Tree) : Tree ;


(*
   RememberInitModuleFunction - remember the initialization function of a module
                                in the ggc marked list.
*)

PROCEDURE RememberInitModuleFunction (t: Tree) : Tree ;


(*
   RememberType - remember the type, t, in the ggc marked list.
*)

PROCEDURE RememberType (t: Tree) : Tree ;


(*
   FoldAndStrip - folds a constant expression tree and strips
                  off any nops.
*)

PROCEDURE FoldAndStrip (t: Tree) : Tree ;


(*
   BuildPushFunctionContext - pushes the current function context.
                              Maps onto push_function_context in ../function.c
*)

PROCEDURE BuildPushFunctionContext ;


(*
   BuildPopFunctionContext - pops the current function context.
                             Maps onto pop_function_context in ../function.c
*)

PROCEDURE BuildPopFunctionContext ;


(*
   BuildCap - builds the Modula-2 function CAP(t) and returns
              the result in a gcc Tree.
*)

PROCEDURE BuildCap (t: Tree) : Tree ;


(*
   BuildAbs - builds the Modula-2 function ABS(t) and returns
              the result in a gcc Tree.
*)

PROCEDURE BuildAbs (t: Tree) : Tree ;


(*
   BuildTypeDeclaration - adds the, type, to the current statement list
                          (if current statement list exists).
*)

PROCEDURE BuildTypeDeclaration (type: Tree) ;


(*
   GetTreeType - returns TREE_TYPE (t).
*)

PROCEDURE GetTreeType (t: Tree) : Tree ;


(*
   BuildTryCatch - builds and returns a tree which
                   represents a try_block and a
                   catch statement list.
*)

PROCEDURE BuildTryCatch (tryBlock, catchBlock: Tree) : Tree ;


(*
   BuildThrow - builds a throw expression and return the tree.
*)

PROCEDURE BuildThrow (exp: Tree) : Tree ;


(*
   InitGlobalContext - initializes a dummy function for the global scope.
*)

PROCEDURE InitGlobalContext ;


(*
   FinishBackend - flushes all outstanding functions held in the GCC backend
                   out to the assembly file.
*)

PROCEDURE FinishBackend ;


(*
   GarbageCollect - force gcc to garbage collect.
*)

PROCEDURE GarbageCollect ;


(*
   TreeOverflow - returns TRUE if the contant expression, t, has
                  caused an overflow. No error message or warning
                  is emitted and no modification is made to, t.
*)

PROCEDURE TreeOverflow (t: Tree) : BOOLEAN ;


(*
   RemoveOverflow - if tree, t, is a constant expression it removes
                    any overflow flag and returns, t.
*)

PROCEDURE RemoveOverflow (t: Tree) : Tree ;


(*
   SetFlagUnitAtATime - sets GCC flag_unit_at_a_time to b.
*)

PROCEDURE SetFlagUnitAtATime (b: BOOLEAN) ;


(*
   MarkFunctionReferenced - marks function tree, t, as referenced.
*)

PROCEDURE MarkFunctionReferenced (t: Tree) ;


(*
   SetLastFunction - assigns last_function to, t.
*)

PROCEDURE SetLastFunction (t: Tree) ;


(*
   SetAlignment - sets the alignment of a, type, to, align.
                  It duplicates the, type, and sets the alignment
                  to prevent alignment effecting behaviour elsewhere.
*)

PROCEDURE SetAlignment (type: Tree; align: Tree) : Tree ;


(*
   BuildNumberOfArrayElements - returns the number of elements in an
                                arrayType.
*)

PROCEDURE BuildNumberOfArrayElements (arrayType: Tree) : Tree ;


(*
   SetDeclPacked - sets the packed bit in TREE, node.  It returns the
                   node.
*)

PROCEDURE SetDeclPacked (node: Tree) : Tree ;


(*
   SetTypePacked - sets the packed bit in TREE, node.  It returns the
                   node.
*)

PROCEDURE SetTypePacked (node: Tree) : Tree ;


(*
   BuildPackedFieldRecord - builds a packed field record of,
                            name, and, fieldtype.
*)

PROCEDURE BuildPackedFieldRecord (name: ADDRESS; fieldtype: Tree) : Tree ;


(*
   SetRecordFieldOffset - returns field after the byteOffset and bitOffset
                          has been applied to it.
*)

PROCEDURE SetRecordFieldOffset (field, byteOffset, bitOffset, fieldType, nBits: Tree) : Tree ;


(*
   InitSystemTypes - initialise loc and word derivatives.
*)

PROCEDURE InitSystemTypes (loc: CARDINAL) ;


END gccgm2.
