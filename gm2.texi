\input texinfo 
@c -*-texinfo-*-

@code{makeinfo}
@code{texinfo-format-buffer}

@c
@c Design notes and documentation about GNU Modula-2
@c
@c
@c part 1 header
@c

@setfilename gm2.info
@settitle The GNU Modula-2 front end to GCC

@c
@c Part 2: Summary Description and Copyright
@c

@ifinfo
This is a short example of a complete Texinfo file.

Copyright @copyright{} 2000, 2001, 2002 Free Software Foundation, Inc.
@end ifinfo

@c Part 3: Titlepage and Copyright
@c The titlepage segment does not appear in the Info file. 
@titlepage
@sp 10
@comment The title is printed in a large font.
@center @titlefont{The GNU Modula-2 front end to GCC}

@c The following two commands start the copyright page.
@page
@setchapternewpage odd
@sp 2
@center Gaius Mulley
@sp 3
@center Last updated 29 April 2003
@sp 10
@c @center @image{gm2/images/gnu,,1.5in}
@vskip 0pt plus 1filll
Copyright @copyright{} 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
@end titlepage

@c Part 4: `Top' Node and Master Menu

@ifinfo
@node Top, Using, (dir), (dir)
@top Introduction
@end ifinfo

@menu
* Using::            Using GNU Modula-2.
* Internals::        GNU Modula-2 internals.
* Libraries::        PIM and ISO library definitions.
* Function Index::   Index for all library functions.
@end menu

@node Using, Internals, Top, Top
@chapter Using GNU Modula-2

@menu
* About::                 What this document explains.
* History::               How GNU Modula-2 came about.
* Compiler options::      GNU Modula-2 compiler options.
* Example usage::         Example compile and link.
* Elementary data types:: Data types supported by GNU Modula-2
* Extensions::            GNU Modula-2 language extensions.
* Interface to C::        Interfacing GNU Modula-2 to C.
* h2def::                 Semi-automatic translation of C header files.
* Assembly language::     Interface to assembly language.
* Built-ins::             Accessing GNU Modula-2 Built-ins.
@end menu

@node About, Compiler options, , Using
@section About

This file contains design notes accompanying the Modula-2
front end to gcc. The GNU Modula-2 compiler is based on
the language as defined in 'Programming in Modula-2'
2nd Edition, Springer Verlag, 1982, 1983 by Niklaus Wirth.
(PIM2).
Although it does include minor extensions.

The libraries are currently a mixture of ISO Modula-2 and
'Programming in Modula-2'. It is our aim to extend the
GNU Modula-2 to include PIM3 and PIM4 compatibility.

@node Compiler options, Example usage, About, Using
@section Compiler options

This section describe the compiler options specific to GNU Modula-2 for
generic flags details see
@xref{Invoking GCC, , ,gcc}.

@table @code

@item -Wmakeall
generate a temporary makefile and build all dependent modules and
link.

@item -Wbounds
generate code to check the bounds of subranges and array indexes.

@item -Wreturn
generate code to check that functions always exit with a @samp{RETURN} and do not
fall out at the end.

@item -v
display all calls to subsidiary programs, such as the C preprocessor,
the gm2 linker and compiler.

@item -Wstatistics
generates quadruple information: number of quadruples generated,
number of quadruples remaining after optimisation.

@item -Wstudents
checks for bad programming style. This option is aimed at
new users of Modula-2 in that it checks for situations which
might cause confusion and thus mistakes.
It checks whether variables of the same name are declared in
different scopes and whether variables look like keywords.
Experienced users might find this option too aggressive.

@item -Wpedantic
forces the compiler to reject nested @samp{WITH}
statements referencing the same record type.
Does not allow multiple imports of the same item from a module.
It also checks that: procedure variables are written to before being read;
variables are not only written to but read from; variables are declared and used.
If the compiler encounters a variable being read before written it will terminate
with a message.
It will check that @samp{FOR} loop indices are not used outside the end of this loop
without being reset.

@item -Wmakelist
this option is only applicable when linking a program module.
The compiler will generate a @file{modulename.lst} file which contains
a list indicating the initialisation order of all modules which are to be
linked. The actual link does not occur.
The gm2 linker scans all @code{IMPORT}s, generates a list of dependencies
and produces an ordered list for initialisation. It will probably get the
order wrong if your project has cyclic dependencies, but
the @file{.lst} file is plain text and can be modified if required.
Once the @file{.lst} file is created it can be used by the compiler
to link your project via the @samp{-Wuselist} option.
It has no effect if the @samp{-c} option is present.

@item -Wuselist
providing @samp{gm2} has been told to link the program module this
option uses the file @file{modulename.lst} for the initialisation
order of modules.

@item -Wcpp
do preprocess the source with @samp{cpp -traditional -lang-asm -C}
For further details about these options see
@xref{Invocation, , ,cpp}.
If @samp{-Wcpp} is supplied then all definition modules and implementation
modules which are parsed will be preprocessed by @samp{cpp}.

@item -Wiso
turn on ISO standard features. Currently this enables the ISO @code{SYSTEM}
module and alters the default library search path so that the ISO libraries
are searched before the PIM libraries.

@end table

@node Example usage, Elementary data types, Compiler options, Using
@section Example compile and link

This section describes how to compiler and link a simple hello world program.
It provides a few examples of using the different options mentioned in
@xref{Compiler options, , ,gm2}.
Assuming that you have a file called @file{hello.mod} in your current directory
which contains:

@example
MODULE hello ;

FROM StrIO IMPORT WriteString, WriteLn ;

BEGIN
   WriteString('hello world') ; WriteLn
END hello.
@end example

You should be able to compile it by:
@samp{gm2 -c -g -I. hello.mod}
and link via:
@samp{gm2 -g -I. hello.mod}.
The result should be an @samp{a.out} file created in your directory.
Hint, the
@samp{-v} displays the subprocesses initiated by
@samp{gm2}.
This can be useful when trouble shooting.

Alternatively it may be compiled by:

@samp{gm2 -g -I. -Wmakeall hello.mod}

@node Elementary data types, Extensions, Example usage, Using
@section Elementary data types

This section describes the elementary data types supported by GNU
Modula-2. It also describes the relationship between these data types
and the equivalent C data types.

The following data types are supported: @code{INTEGER}, @code{LONGINT},
@code{CARDINAL}, @code{BOOLEAN}, @code{REAL}, @code{LONGREAL}, @code{SHORTREAL},
and @code{CHAR}.

An equivalence table is given below:

@example
GNU Modula-2              GNU C
======================================
INTEGER                   int
LONGINT                   long int
CARDINAL                  unsigned int
BOOLEAN                   int
REAL                      double
LONGREAL                  long double
SHORTREAL                 float
CHAR                      char
@end example

@node Extensions, Interface to C, Elementary data types, Using
@section GNU Modula-2 language extensions

This section introduces the GNU Modula-2 language extensions.
The GNU Modula-2 compiler allows abstract data types to be
@code{any} type, not just restricted to a pointer type.

It also allows declarations in any order. Type, constant, procedure and
variable declarations can be in any order. Nested modules may also declare
types in any order, consider:

@example
MODULE colour ;

   PROCEDURE make (VAR c: colours) ;
   BEGIN
      c := yellow
   END make ;

   MODULE inner ;
   EXPORT colours ;

   TYPE
      colours = (red, blue, yellow, white) ;
   END inner ;

VAR
   g: colours
BEGIN
   make(g)
END colour.
@end example

The preprocessor @samp{cpp} can be invoked via the @samp{-Wcpp} command
line option. This in turn invokes @samp{cpp} with the following
arguments @samp{-traditional -lang-asm -C}.
These options preserve comments and all quotations.
@samp{gm2} treats a @samp{#} character in the first column
as a preprocessor directive.

@node Interface to C, h2def, Extensions, Using
@section Interfacing GNU Modula-2 to C

The GNU Modula-2 compiler tries to use the C calling convention wherever
possible however some parameters have no C equivalent and
thus a language specific method is used. For example unbounded
arrays are passed as a @code{struct void *address, unsigned int high}
and the contents of these arrays are copied by callee functions
when they are declared as non @code{VAR} parameters.
The @code{VAR} equivalent unbounded array parameters need no copy,
but still use the @code{struct} representation.

The recommended method of interfacing GNU Modula-2 to C is by telling
the definition module that the implementation is in the C language.
This is achieved by using the tokens @code{DEFINITION MODULE FOR "C"}.
Here is an example which can be found in the source tree
@file{gcc-version/gcc/gm2/examples/callingC/libprintf.def}

@example
DEFINITION MODULE FOR "C" libprintf ;

EXPORT UNQUALIFIED printf ;

PROCEDURE printf (a: ARRAY OF CHAR; ...) ;

END libprintf.
@end example

the @code{UNQUALIFIED} keyword in the definition module informs
GNU Modula-2 not to prefix the module name to exported references
in the object file.

The @code{printf} declaration states that the first parameter semantically
matches @code{ARRAY OF CHAR} but since the module is for the C language
it will be mapped onto @code{char *}. The token @code{...} indicates
a variable number of arguments (varargs) and all parameters passed
here are mapped onto their C equivalents. Arrays and constant strings
are passed as pointers.

The hello world program can be rewritten as:

@example
MODULE hello ;

FROM libprintf IMPORT printf ;

BEGIN
   printf("hello world\n")
END hello.
@end example

and it can be compiled by:

@samp{gm2 -Wmakeall -g -I. hello.mod -lc}

In reality the @samp{-lc} is redundant as libc is always included in the
linking process. It is shown here to emphasize that the C library or
object file containing @code{printf} must be present.

@node h2def, Assembly language, Interface to C, Using
@section Semi-automatic translation of C header files

The tool @samp{h2def} can be used to semi-automatically generate
@code{DEFINITION MODULE FOR "C"} modules. The tool takes as input a C
header file and generates as output a corresponding textual definition
module.  While the tool will not automatically translate complex C
header files it will generate definition modules for simple header
files.

For example consider the following header file (@code{header.h}):

@example
#define MYTYPE void *

extern MYTYPE h;

#define LIMIT  1000
#define FOOBAR (1+LIMIT)

int *p, ch;

extern MYTYPE func (void (*funcarray)(int, char));

struct mumble @{
  char *name;
  void *addr;
  struct mumble *next;
  void (*arrayfunc[5])(int, char);
@} *mylist;
@end example

Using the following command line @code{h2def header.h} will generate
the module below:

@example
DEFINITION MODULE FOR "C" header ;

VAR
   h: ADDRESS ;
   
CONST
   LIMIT = 1000 ;
   FOOBAR = (LIMIT) + (1) ;
     
VAR
   p: POINTER TO INTEGER ;
   ch: INTEGER ;
   
PROCEDURE func (funcarray: t1) : ADDRESS;

TYPE
   t1 = PROCEDURE (INTEGER, CHAR) ;
    
VAR
   mylist: POINTER TO mumble;
   
TYPE
   mumble = RECORD
               name: POINTER TO CHAR ;
               addr: ADDRESS ;
               next: POINTER TO mumble ;
               arrayfunc: ARRAY [0.. 5-1] OF PROCEDURE (INTEGER, CHAR) ;
            END ;

END header.
@end example

The main limitation of @code{h2def} is in the preprocessing handling.
It does not understand the C preprocessor token constructor directives
@code{#} and @code{##}. Also it will not combine successive string
tokens.

Support for the @code{#define} mechanism is limited. Initially the
macro is parsed to check whether it is a constant expression.  If it
fails it is reassigned as a macro definition.  A macro which contains
C statement code cannot be translated into a definition module. These
macros and all dependents are poisoned and are not translated.
At present it does not understand macros with arguments.

The @samp{-I} option to @code{h2def} allows include directories to be
specified and the @samp{-C} option states that a macro definition must
be computed at compile time.  For example consider the following
header file:

@example
#if !defined(FOOBAR)
# define FOOBAR
# define MAXIMUM 1000
#endif
@end example

which if processed by @code{h2def -CFOOBAR} yields the following code:

@example
DEFINITION MODULE FOR "C" ifdef ;

# if (!(defined(FOOBAR)))
CONST
   MAXIMUM = 1000 ;
# endif
     
END ifdef.
@end example

The @samp{-a} option provides a method whereby the C parameter
construct @code{sometype *foo} is translated in Modula-2 as
@code{foo: ARRAY OF sometype}.

Normally output for @code{h2def} will require some manual
intervention. Some header files need more help than others, for
example the GNU/Linux svga header file @code{vga.h} requires a little
help whereas the GNU pthread file @code{pthread.h} requires more.
Nevertheless the effort required is much less than writing the modules
by hand.

The @samp{-e} option will emit an error message if a C syntax error is
encountered. The @samp{-p} option generate a comment for every
occurance of an object which cannot be translated into Modula-2.

@node Assembly language, Built-ins, h2def, Using
@section Interface to assembly language

The interface for GNU Modula-2 to assembly language is almost identical to GNU C.
The only alterations are that the keywords asm and volatile are in capitals,
following the Modula-2 convention.

A simple, but highly non optimal, example is given below. Here we want to add the
two @code{CARDINAL}s @code{foo} and @code{bar} together and return the result.

@example
PROCEDURE Example (foo, bar: CARDINAL) : CARDINAL ;
VAR
   myout: CARDINAL ;
BEGIN
   ASM VOLATILE ("movl %1,%%eax; addl %2,%%eax; movl %%eax,%0"
      : "=g" (myout)           (* outputs *)
      : "g" (foo), "g" (bar)   (* inputs  *)
      : "eax") ;               (* we trash *)
   RETURN( myout )
END Example ;
@end example

For a full description of this interface we refer the reader to the GNU C manual.

@xref{Extended Asm, ,Extensions to the C Language Family,gcc}.

@node Built-ins, , Assembly language, Using
@section Accessing GNU Modula-2 Built-ins

This section describes the built-in constants and functions defined in
GNU Modula-2.  The following compiler constants can be accessed using
the @code{__ATTRIBUTE__} @code{__BUILTIN__} keywords. These are not
part of the Modula-2 language and they may differ depending upon the
target architecture but they provide a method whereby common
libraries can interface to a different underlying architecture.

The built-in constants are: @code{BITS_PER_UNIT}, @code{BITS_PER_WORD},
@code{BITS_PER_CHAR} and @code{UNITS_PER_WORD}. They are integrated into
GNU Modula-2 by an extension to the @code{ConstFactor} rule:

@example
ConstFactor := ConstQualidentOrSet | Number | ConstString |
               "(" ConstExpression ")" | "NOT" ConstFactor |
               ConstAttribute =:

ConstAttribute := "__ATTRIBUTE__" "__BUILTIN__" "(" "(" Ident ")" ")" =:
@end example

Here is an example taken from the ISO library @code{SYSTEM.def}:

@example
CONST
   BITSPERLOC    = __ATTRIBUTE__ __BUILTIN__ ((BITS_PER_UNIT)) ;
   LOCSPERWORD   = __ATTRIBUTE__ __BUILTIN__ ((UNITS_PER_WORD)) ;
@end example

Built-in functions are transparent to the end user. All built-in
functions are declared in @code{DEFINITION MODULE}s and are imported
as and when required.  Built-in functions are declared in definition
modules by using the @code{__BUILTIN__} keyword. Here is a section of
the ISO library @code{LongMath.def} which demonstrates this feature.

@example
PROCEDURE __BUILTIN__ sqrt (x: LONGREAL): LONGREAL;
  (* Returns the square root of x *)
@end example

This indicates that the function @code{sqrt} will be implemented using
the gcc built-in maths library. If gcc cannot utilise the built-in
function (for example if the programmer requested the address of
@code{sqrt}) then code is generated to call the alternative function
implemented in the @code{IMPLEMENTATION} @code{MODULE}.

Sometimes a function exported from the @code{DEFINITION} @code{MODULE}
will have a different name from the built-in function within gcc. In such
cases the mapping between the GNU Modula-2 function name and the gcc name
is expressed using the keywords @code{__ATTRIBUTE__} @code{__BUILTIN__}
@code{((Ident))}. For example the function @code{sqrt} in @code{LongMath.def}
maps onto the gcc built-in function @code{sqrtl} and this is expressed as:

@example
PROCEDURE __ATTRIBUTE__ __BUILTIN__ ((sqrtl)) sqrt
                                    (x: LONGREAL) : LONGREAL;
  (* Returns the positive square root of x *)
@end example

The following module @code{Builtins.def} enumerates the list of built-in functions
which can be accessed in GNU Modula-2. It also serves to define the parameter
and return value for each function:

@example
DEFINITION MODULE Builtins ;

FROM SYSTEM IMPORT ADDRESS ;

PROCEDURE __BUILTIN__ sinf (x: SHORTREAL) : SHORTREAL ;
PROCEDURE __BUILTIN__ sin (x: REAL) : REAL ;
PROCEDURE __BUILTIN__ sinl (x: LONGREAL) : LONGREAL ;

PROCEDURE __BUILTIN__ cosf (x: SHORTREAL) : SHORTREAL ;
PROCEDURE __BUILTIN__ cos (x: REAL) : REAL ;
PROCEDURE __BUILTIN__ cosl (x: LONGREAL) : LONGREAL ;

PROCEDURE __BUILTIN__ sqrtf (x: SHORTREAL) : SHORTREAL ;
PROCEDURE __BUILTIN__ sqrt (x: REAL) : REAL ;
PROCEDURE __BUILTIN__ sqrtl (x: LONGREAL) : LONGREAL ;

PROCEDURE __BUILTIN__ fabsf (x: SHORTREAL) : SHORTREAL ;
PROCEDURE __BUILTIN__ fabs (x: REAL) : REAL ;
PROCEDURE __BUILTIN__ fabsl (x: LONGREAL) : LONGREAL ;

PROCEDURE __BUILTIN__ alloca (i: CARDINAL) : ADDRESS ;
PROCEDURE __BUILTIN__ memcpy (dest, src: ADDRESS; n: CARDINAL) : ADDRESS ;
PROCEDURE __BUILTIN__ index (s: ADDRESS; c: INTEGER) : ADDRESS ;
PROCEDURE __BUILTIN__ rindex (s: ADDRESS; c: INTEGER) : ADDRESS ;
PROCEDURE __BUILTIN__ memcmp (s1, s2: ADDRESS; n: CARDINAL) : INTEGER ;
PROCEDURE __BUILTIN__ memset (s: ADDRESS; c: INTEGER; n: CARDINAL) : ADDRESS ;
PROCEDURE __BUILTIN__ strcat (dest, src: ADDRESS) : ADDRESS ;
PROCEDURE __BUILTIN__ strncat (dest, src: ADDRESS; n: CARDINAL) : ADDRESS ;
PROCEDURE __BUILTIN__ strcpy (dest, src: ADDRESS) : ADDRESS ;
PROCEDURE __BUILTIN__ strncpy (dest, src: ADDRESS; n: CARDINAL) : ADDRESS ;
PROCEDURE __BUILTIN__ strcmp (s1, s2: ADDRESS) : INTEGER ;
PROCEDURE __BUILTIN__ strncmp (s1, s2: ADDRESS; n: CARDINAL) : INTEGER ;
PROCEDURE __BUILTIN__ strlen (s: ADDRESS) : INTEGER ;
PROCEDURE __BUILTIN__ strstr (haystack, needle: ADDRESS) : ADDRESS ;
PROCEDURE __BUILTIN__ strpbrk (s, accept: ADDRESS) : ADDRESS ;
PROCEDURE __BUILTIN__ strspn (s, accept: ADDRESS) : CARDINAL ;
PROCEDURE __BUILTIN__ strcspn (s, accept: ADDRESS) : CARDINAL ;
PROCEDURE __BUILTIN__ strchr (s: ADDRESS; c: INTEGER) : ADDRESS ;
PROCEDURE __BUILTIN__ strrchr (s: ADDRESS; c: INTEGER) : ADDRESS ;

END Builtins.
@end example

Although this module exists and will result in the generation of
inline code if optimization flags are passed to GNU Modula-2, users
are advised to utilize the same functions from more generic libraries.
The built-in mechanism will be applied to these generic
libraries where appropriate. Note for the mathematical routines to
be inlined you need to specify the @samp{-ffast-math -O} options.

@node Internals, Libraries, Using, Top
@chapter GNU Modula-2 Internals

This document is a small step in the long journey of documenting the GNU
Modula-2 compiler and how it integrates with GCC.
The document is still in it's infancy.

@menu
* History::                 Where the sources came from.
* Overview::                Overview of the structure of GNU Modula-2.
* Integrating::             How the front end integrates with gcc.
* Building and installing:: How to build gm2.
* Future::                  A future wish list.
* Done list::               Progression of the GNU Modula-2 project.
* To do list::              Outstanding issues.
@end menu

@node History, Overview, , Internals
@section History

The Modula-2 compiler sources have come from the m2f compiler which
runs under GNU/Linux. The original m2f compiler was written in Modula-2
and was bootstrapped via a modified version of p2c 1.20. The m2f
compiler was a recursive descent which generated quadruples as
intermediate code. It also used C style calling convention wherever
possible and utilized a C structure for dynamic arrays.

@node Overview, Integrating, History, Internals
@section Overview

GNU Modula-2 uses flex and a machine generated recursive descent
parser. Most of the source code is written in Modula-2 and
bootstrapping is achieved via a modified version of p2c-1.20.
The modified p2c-1.20 is contained in the GNU Modula-2 source
tree as are a number of other tools necessary for bootstrapping.

@node Integrating, Building and installing, Overview, Internals
@section How the front end integrates with gcc

The M2Base and M2System
modules contain base types and system types respectively they
map onto GCC back-end data types.

@node Building and installing, Future, Integrating, Internals
@section Building

The GNU Modula-2 source tree should be unpacked in the GNU GCC
source tree directory @file{gcc-version/gcc}. Typically this
is achieved by the commands:

@example
cd gcc-version/gcc
tar zxf gm2-version.tar.gz
cd ../..
@end example

GNU Modula-2 can be built by typing:

@example
mkdir host-build
cd host-build
../gcc-version/configure
make
cd ..
@end example

It can be installed by:

@example
su
cd host-build
make install
cd ..
@end example

@node Future, Done list, Building and installing, Internals
@section A future wish list

In the future it might be sensible to rewrite M2Quads.mod to
directly call gcc routines, rather than generate quadruples.
However this is a large alteration and I'd firstly like to
see gm2 working with the method outlined above, which is
conceptually easier.

@node Done list, To do list, Future, Internals
@section Done list

What has been done:

@itemize @bullet

@item
provided access to a few compiler built-in constants
and twenty seven built-in C functions.

@item
definition modules no longer have to @samp{EXPORT QUALIFIED}
objects (as per PIM-3, PIM-4 and ISO).

@item
implemented ISO Modula-2 sets. Large sets are now allowed,
no limits imposed. The comparison operators
@samp{# = <= >= < >} all behave as per ISO standard.
The obvious use for large sets is
@samp{SET OF CHAR}. These work well with gdb once it has been
patched to understand Modula-2 sets.

@item
added @code{DEFINITION MODULE FOR "C"} method of linking
to C. Also added varargs handling in C definition modules.

@item
cpp can be run on definition and implementation modules.

@item
@samp{-Wmakell} generates a temporary @code{Makefile} and
will build all dependant modules.

@item
Compiler will bootstrap itself and three generations of the
compiler all produce the same code.

@item
the back end will generate code and assembly declarations for
modules containing global variables of all types. Procedure
prologue/epilogue is created.

@item
all loop constructs, if then else, case statements and expressions.

@item
nested module initialization.

@item
pointers, arrays, procedure calls, nested procedures.

@item
front end @samp{gm2} can now compile and link modules.

@item
the ability to insert gnu asm statements within GNU Modula-2.

@item
inbuilt functions, SIZE, ADR, TSIZE, HIGH etc

@item
block becomes and complex procedure parameters (unbounded arrays, strings).

@item
the front end now utilizes GCC tree constants and types and is no
longer tied to a 32 bit architecture, but reflects the 'configure'
target machine description.

@item
fixed all C compiler warnings when gcc compiles the p2c generated C
with -Wall.

@item
built a new parser which implements error recovery.

@item
added mechanism to invoke cpp to support conditional compilation if required.

@item
all @samp{Makefile}s are generated via @samp{./configure}

@end itemize

@node To do list, , Done list, Internals
@section To do list

What needs to be done:

@itemize @bullet

@item
implement ISO library (use FIO.mod as the underlying substructure).

@item
implement LONGCARD and include IO functions within FpuIO.

@item
implement many of the ISO built-in functions and procedures.

@item
rewrite documentation.

@item
profile compiler and improve compilation speed.
Compiling @file{P1SyntaxCheck.mod} takes far too long.

@item
the modula-2 front end needs to convert the quadruples into
trees and the convert these trees into gcc trees, rather than
simply translating each quadruple into a separate gcc tree.
The later works but better code could be generated by
building a large tree and passing this tree to gcc.
One way to implement this is by taking a copy of M2SubExp.mod and
basing the gcc calls on the tree structure that M2SubExp.mod builds.
My belief is that this should not take much time to complete and
should produce better code.

This requires separating the semantic checking routines away from M2Quads.mod.
Propose a new module M2Tree which contains the functionality of M2Quads/M2SubExp.
We should be able to remove M2Quads, M2SubExp, M2Optimize, M2GenGCC, M2EvalSym
once this is complete.

SymbolTable needs to be modified.

@item
investigate the use of collect2 during link/module initialization.

@item
integrate the small testsuite (gm2/m2/comp/autotest)
into dejagnu ?? and improve

@item
Coroutines - as mentioned by readers of comp.lang.modula2.

@item
improve documentation, specifically this document which should
also include a synopsis of 2nd Edition Modula-2.

@item
testing and fixing bugs

@end itemize

@node Libraries, Function Index, Internals, Top
@chapter PIM and ISO library definitions

This chapter contains PIM and ISO libraries. The ISO libraries are currently
work in progress, many are incomplete and even more have no implementation
module. The PIM libraries are very mature as the compiler uses them extensively.

@include gm2-libs.texi

@node Function Index, , Libraries, Top

@c @printindex cp
@printindex fn

@summarycontents
@contents
@bye
