\input texinfo 
@c -*-texinfo-*-

@code{makeinfo}
@code{texinfo-format-buffer}

@c
@c Design notes and documentation about GNU Modula-2
@c
@c
@c part 1 header
@c

@setfilename gm2.info
@settitle The GNU Modula-2 front end to GCC

@c
@c Part 2: Summary Description and Copyright
@c

@ifinfo
This is a short example of a complete Texinfo file.

Copyright @copyright{} 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
@end ifinfo

@c Part 3: Titlepage and Copyright
@c The titlepage segment does not appear in the Info file. 
@titlepage
@sp 10
@comment The title is printed in a large font.
@center @titlefont{The GNU Modula-2 front end to GCC}

@c The following two commands start the copyright page.
@page
@setchapternewpage odd
@sp 2
@center Gaius Mulley
@sp 3
@center Last updated 20 May 2003
@sp 10
@c @center @image{gm2/images/gnu,,1.5in}
@vskip 0pt plus 1filll
Copyright @copyright{} 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
@end titlepage

@c Part 4: `Top' Node and Master Menu

@ifinfo
@node Top, Using, (dir), (dir)
@top Introduction
@end ifinfo

@menu
* Using::            Using GNU Modula-2.
* Internals::        GNU Modula-2 internals.
* Libraries::        PIM and ISO library definitions.
* Function Index::   Index for all library functions.
@end menu

@node Using, Internals, Top, Top
@chapter Using GNU Modula-2

@menu
* About::                 What this document explains.
* History::               How GNU Modula-2 came about.
* Compiler options::      GNU Modula-2 compiler options.
* Example usage::         Example compile and link.
* Elementary data types:: Data types supported by GNU Modula-2.
* Standard procedures::   Permanently accessible base procedures.
* Extensions::            GNU Modula-2 language extensions.
* Interface to C::        Interfacing GNU Modula-2 to C.
* h2def::                 Semi-automatic translation of C header files.
* Assembly language::     Interface to assembly language.
* Built-ins::             Accessing GNU Modula-2 Built-ins.
@end menu

@node About, Compiler options, , Using
@section About

This document contains the user and design issues relevant to the
Modula-2 front end to gcc. The GNU Modula-2 compiler is based on the
language as defined in 'Programming in Modula-2' 2nd Edition, Springer
Verlag, 1982, 1983 by Niklaus Wirth (PIM2), 'Programming in
Modula-2', 3rd Corrected Edition, Springer Verlag, 1985 (PIM3) and
'Programming in Modula-2', 4th Edition, Springer Verlag, 1988 (PIM4).
It also includes ISO M2 features and GNU M2 extensions.

There are currently two sets of libraries. The 'Programming in Modula-2'
libraries are reasonably complete whereas the ISO libraries are still
in development. However both sets of definition modules are contained
within this document.

@node Compiler options, Example usage, About, Using
@section Compiler options

This section describe the compiler options specific to GNU Modula-2 for
generic flags details see
@xref{Invoking GCC, , ,gcc}.

@table @code

@item -Wmakeall
generate a temporary makefile and build all dependent modules and
link.

@item -Wbounds
generate code to check the bounds of subranges and array indexes.

@item -Wreturn
generate code to check that functions always exit with a @samp{RETURN} and do not
fall out at the end.

@item -v
display all calls to subsidiary programs, such as the C preprocessor,
the GNU Modula-2 linker and compiler.

@item -Wstatistics
generates quadruple information: number of quadruples generated,
number of quadruples remaining after optimisation.

@item -Wstudents
checks for bad programming style. This option is aimed at new users of
Modula-2 in that it checks for situations which might cause confusion
and thus mistakes.  It checks whether variables of the same name are
declared in different scopes and whether variables look like keywords.
Experienced users might find this option too aggressive.

@item -Wpedantic
forces the compiler to reject nested @samp{WITH} statements
referencing the same record type.  Does not allow multiple imports of
the same item from a module.  It also checks that: procedure variables
are written to before being read; variables are not only written to
but read from; variables are declared and used.  If the compiler
encounters a variable being read before written it will terminate with
a message.  It will check that @samp{FOR} loop indices are not used
outside the end of this loop without being reset.

@item -Wmakelist
this option is only applicable when linking a program module.  The
compiler will generate a @file{modulename.lst} file which contains a
list indicating the initialisation order of all modules which are to
be linked. The actual link does not occur.  The GNU Modula-2 linker
scans all @code{IMPORT}s, generates a list of dependencies and
produces an ordered list for initialisation. It will probably get the
order wrong if your project has cyclic dependencies, but the
@file{.lst} file is plain text and can be modified if required.  Once
the @file{.lst} file is created it can be used by the compiler to link
your project via the @samp{-Wuselist} option.  It has no effect if the
@samp{-c} option is present.

@item -Wuselist
providing @samp{gm2} has been told to link the program module this
option uses the file @file{modulename.lst} for the initialisation
order of modules.

@item -Wcpp
do preprocess the source with @samp{cpp -traditional -lang-asm -C} For
further details about these options see @xref{Invocation, , ,cpp}.  If
@samp{-Wcpp} is supplied then all definition modules and
implementation modules which are parsed will be preprocessed by
@samp{cpp}.

@item -Wiso
turn on ISO standard features. Currently this enables the ISO
@code{SYSTEM} module and alters the default library search path so
that the ISO libraries are searched before the PIM libraries.

@item -Wextended-opaque
allows opaque types to be implemented as any type. This
is a GNU Modula-2 extension and it requires that the implementation
module defining the opaque type is available so that it
can be resolved when compiling the module which imports the opaque type.
@end table

@node Example usage, Elementary data types, Compiler options, Using
@section Example compile and link

This section describes how to compiler and link a simple hello world
program.  It provides a few examples of using the different options
mentioned in @xref{Compiler options, , ,gm2}.  Assuming that you have
a file called @file{hello.mod} in your current directory which
contains:

@example
MODULE hello ;

FROM StrIO IMPORT WriteString, WriteLn ;

BEGIN
   WriteString('hello world') ; WriteLn
END hello.
@end example

You should be able to compile it by:
@samp{gm2 -c -g -I. hello.mod}
and link via:
@samp{gm2 -g -I. hello.mod}.
The result should be an @samp{a.out} file created in your directory.
Hint, the
@samp{-v} displays the subprocesses initiated by
@samp{gm2}.
This can be useful when trouble shooting.

Alternatively it may be compiled by:

@samp{gm2 -g -I. -Wmakeall hello.mod}

@node Elementary data types, Standard procedures, Example usage, Using
@section Elementary data types

This section describes the elementary data types supported by GNU
Modula-2. It also describes the relationship between these data types
and the equivalent C data types.

The following data types are supported: @code{INTEGER},
@code{LONGINT}, @code{CARDINAL}, @code{LONGCARD}, @code{BOOLEAN},
@code{REAL}, @code{LONGREAL}, @code{SHORTREAL}, and @code{CHAR}.

An equivalence table is given below:

@example
GNU Modula-2              GNU C
======================================
INTEGER                   int
LONGINT                   long int
CARDINAL                  unsigned int
BOOLEAN                   int
REAL                      double
LONGREAL                  long double
SHORTREAL                 float
CHAR                      char
@end example

@node Standard procedures, Extensions, Elementary data types, Using
@section Permanently accessible base procedures.

This section describes the procedures and functions which are
always visible.

@subsection Standard procedures and functions common to PIM and ISO

The following procedures are implemented and conform with Programming
in Modula-2 and ISO Modula-2: @code{NEW}, @code{DISPOSE}, @code{INC},
@code{DEC}, @code{INCL}, @code{EXCL} and @code{HALT}.  The standard
functions are: @code{HIGH}, @code{CAP}, @code{ABS}, @code{ODD},
@code{VAL}, @code{CHR}, @code{MIN}, @code{MAX}. All these functions
and procedures (except @code{HALT}, @code{NEW}, @code{DISPOSE} and,
under non constant conditions, @code{LENGTH}) generate in-line code
for efficiency.

@example

(*
   NEW - the procedure NEW is replaced by:
         ALLOCATE(p, TSIZE(p^)) ;
         The user is expected to import the procedure ALLOCATE
         (normally found in the module, Storage.)

         In:  a variable p: of any pointer type.
         Out: variable, p, is set to some allocated memory
              which is large enough to hold all the contents of p^.
*)

@findex NEW
PROCEDURE NEW (VAR p:<any pointer type>) ;
@end example

@example

(*
   DISPOSE - the procedure DISPOSE is replaced by:
             DEALLOCATE(p, TSIZE(p^)) ;
             The user is expected to import the procedure DEALLOCATE
             (normally found in the module, Storage.)

             In:  a variable p: of any pointer type which has been
                  initialized by a call to NEW.
             Out: the area of memory
                  holding p^ is returned to the system.
                  Note that the underlying procedure DEALLOCATE
                  procedure in module Storage will assign p to NIL.
*)

@findex DISPOSE
PROCEDURE DISPOSE (VAR p:<any pointer type>) ;
@end example

@example

(*
   INC - can take one or two parameters. If suppied with one
         parameter it adds 1 to the variable, v.
         If two parameters are supplied then the value, a, is
         added to, v.
*)

@findex INC
PROCEDURE INC (VAR v: <any base type>) ;
PROCEDURE INC (VAR v: <any base type>; a: <any base type>) ;
@end example

@example

(*
   DEC - can take one or two parameters. If suppied with one
         parameter it subtracts 1 from the variable, v.
         If two parameters are supplied then the value, a, is
         subtracted from, v.
*)

@findex DEC
PROCEDURE DEC (VAR v: <any base type>) ;
PROCEDURE DEC (VAR v: <any base type>; a: <any base type>) ;
@end example

@example

(*
   INCL - includes bit element, e, to a set type, s.
*)

@findex INCL
PROCEDURE INCL (VAR s: <any set type>; e: <element of set type s>) ;
@end example

@example

(*
   EXCL - excludes bit element, e, from a set type, s.
*)

@findex EXCL
PROCEDURE EXCL (VAR s: <any set type>; e: <element of set type s>) ;
@end example

@example

(*
   HALT - will call the HALT procedure inside the module M2RTS.
          Users can replace M2RTS.
*)

@findex HALT
PROCEDURE HALT ;

@end example

The following define the standard set of functions which conform with Programming
in Modula-2 and ISO Modula-2.

@example

(*
   HIGH - returns the last accessible indice of an parameter declared as
          ARRAY OF CHAR. Thus

          PROCEDURE foo (a: ARRAY OF CHAR) ;
          VAR
             c: CARDINAL ;
          BEGIN
             c := HIGH(a)
          END foo ;

          BEGIN
             foo('hello')
          END

          will cause the local variable, c, to contain the value 4
*)

@findex HIGH
PROCEDURE HIGH (a: ARRAY OF CHAR) : CARDINAL ;
@end example

@example

(*
   CAP - returns the capital of character, ch, providing
         ch lies within the range 'a'..'z'. Otherwise, ch,
         is returned unaltered.
*)

PROCEDURE CAP (ch: CHAR) : CHAR ;

@end example
@c @code{CAP}, @code{ABS}, @code{VAL},
@c @code{CHR}, @code{ODD}, @code{MIN}, @code{MAX}

@subsection ISO specific standard procedures and functions

The standard function @code{LENGTH} is specific to ISO Modula-2 and
is defined as:

@example

(*
   LENGTH - returns the length of string, a.
*)

@findex LENGTH
PROCEDURE LENGTH (a: ARRAY OF CHAR) : CARDINAL ;

@end example

This function is evaluated at compile time, providing that string
@code{a} is a constant. If @code{a} cannot be evaluated then a call is
made to @code{M2RTS.Length}.

@c complete other ISO functions

@node Extensions, Interface to C, Standard procedures, Using
@section GNU Modula-2 language extensions

This section introduces the GNU Modula-2 language extensions.
The GNU Modula-2 compiler allows abstract data types to be any type,
not just restricted to a pointer type providing the
@samp{-Wextended-opaque} option is supplied
@xref{Compiler options, , ,gm2}.

Declarations can be made in any order, whether they are
types, constants, procedures, nested modules or variables
(see @xref{Passes, , ,}.)

The preprocessor @samp{cpp} can be invoked via the @samp{-Wcpp}
command line option. This in turn invokes @samp{cpp} with the
following arguments @samp{-traditional -lang-asm -C}.  These options
preserve comments and all quotations.  @samp{gm2} treats a @samp{#}
character in the first column as a preprocessor directive.

For example here is a module which calls @code{InternalError}
twice via the macro @code{ERROR}.

@example
MODULE cpp ;

FROM SYSTEM IMPORT ADR ;
FROM libc IMPORT exit, printf ;

PROCEDURE InternalError (a, file: ARRAY OF CHAR;
                         line: CARDINAL) ;
VAR
   r: INTEGER ;
BEGIN
   r := printf("%s:%d:internal error, %s\n",
               ADR(file), line, ADR(a)) ;
   exit(1)
END InternalError ;

#define ERROR(X)  InternalError(X, __FILE__, __LINE__)

VAR
   i, j: CARDINAL ;
BEGIN
   i := 1 ;
   j := 1 ;
   IF i#j
   THEN
      ERROR('trivial assignment failed')
   END ;
   i := 2 DIV 2 ;
   IF i#j
   THEN
      ERROR('trivial division failed')
   END
END cpp.
@end example

GNU Modula-2 also allows programmers to interface to @code{C} and
assembly language.

@node Interface to C, h2def, Extensions, Using
@section Interfacing GNU Modula-2 to C

The GNU Modula-2 compiler tries to use the C calling convention wherever
possible however some parameters have no C equivalent and
thus a language specific method is used. For example unbounded
arrays are passed as a @code{struct void *address, unsigned int high}
and the contents of these arrays are copied by callee functions
when they are declared as non @code{VAR} parameters.
The @code{VAR} equivalent unbounded array parameters need no copy,
but still use the @code{struct} representation.

The recommended method of interfacing GNU Modula-2 to C is by telling
the definition module that the implementation is in the C language.
This is achieved by using the tokens @code{DEFINITION MODULE FOR "C"}.
Here is an example which can be found in the source tree
@file{gcc-version/gcc/gm2/examples/callingC/libprintf.def}

@example
DEFINITION MODULE FOR "C" libprintf ;

EXPORT UNQUALIFIED printf ;

PROCEDURE printf (a: ARRAY OF CHAR; ...) ;

END libprintf.
@end example

the @code{UNQUALIFIED} keyword in the definition module informs
GNU Modula-2 not to prefix the module name to exported references
in the object file.

The @code{printf} declaration states that the first parameter semantically
matches @code{ARRAY OF CHAR} but since the module is for the C language
it will be mapped onto @code{char *}. The token @code{...} indicates
a variable number of arguments (varargs) and all parameters passed
here are mapped onto their C equivalents. Arrays and constant strings
are passed as pointers.

The hello world program can be rewritten as:

@example
MODULE hello ;

FROM libprintf IMPORT printf ;

BEGIN
   printf("hello world\n")
END hello.
@end example

and it can be compiled by:

@samp{gm2 -Wmakeall -g -I. hello.mod -lc}

In reality the @samp{-lc} is redundant as libc is always included in the
linking process. It is shown here to emphasize that the C library or
object file containing @code{printf} must be present.

@node h2def, Assembly language, Interface to C, Using
@section Semi-automatic translation of C header files

The tool @samp{h2def} can be used to semi-automatically generate
@code{DEFINITION MODULE FOR "C"} modules. The tool takes as input a C
header file and generates as output a corresponding textual definition
module.  While the tool will not automatically translate complex C
header files it will generate definition modules for simple header
files.

For example consider the following header file (@code{header.h}):

@example
#define MYTYPE void *

extern MYTYPE h;

#define LIMIT  1000
#define FOOBAR (1+LIMIT)

int *p, ch;

extern MYTYPE func (void (*funcarray)(int, char));

struct mumble @{
  char *name;
  void *addr;
  struct mumble *next;
  void (*arrayfunc[5])(int, char);
@} *mylist;
@end example

Using the following command line @code{h2def header.h} will generate
the module below:

@example
DEFINITION MODULE FOR "C" header ;

VAR
   h: ADDRESS ;
   
CONST
   LIMIT = 1000 ;
   FOOBAR = (LIMIT) + (1) ;
     
VAR
   p: POINTER TO INTEGER ;
   ch: INTEGER ;
   
PROCEDURE func (funcarray: t1) : ADDRESS;

TYPE
   t1 = PROCEDURE (INTEGER, CHAR) ;
    
VAR
   mylist: POINTER TO mumble;
   
TYPE
   mumble = RECORD
               name: POINTER TO CHAR ;
               addr: ADDRESS ;
               next: POINTER TO mumble ;
               arrayfunc: ARRAY [0.. 5-1] OF PROCEDURE (INTEGER, CHAR) ;
            END ;

END header.
@end example

The main limitation of @code{h2def} is in the preprocessing handling.
It does not understand the C preprocessor token constructor directives
@code{#} and @code{##}. Also it will not combine successive string
tokens.

Support for the @code{#define} mechanism is limited. Initially the
macro is parsed to check whether it is a constant expression.  If it
fails it is reassigned as a macro definition.  A macro which contains
C statement code cannot be translated into a definition module. These
macros and all dependents are poisoned and are not translated.
At present it does not understand macros with arguments.

The @samp{-I} option to @code{h2def} allows include directories to be
specified and the @samp{-C} option states that a macro definition must
be computed at compile time.  For example consider the following
header file called @code{ifdef.h}:

@example
#if !defined(FOOBAR)
# define FOOBAR
# define MAXIMUM 1000
#endif
@end example

which if processed by @code{h2def -CFOOBAR ifdef.h} yields the following code:

@example
DEFINITION MODULE FOR "C" ifdef ;

# if (!(defined(FOOBAR)))
CONST
   MAXIMUM = 1000 ;
# endif
     
END ifdef.
@end example

The @samp{-a} option provides a method whereby the C parameter
construct @code{sometype *foo} is translated in Modula-2 as
@code{foo: ARRAY OF sometype}.

Normally output for @code{h2def} will require some manual
intervention. Some header files need more help than others, for
example the GNU/Linux svga header file @code{vga.h} requires a little
help whereas the GNU pthread file @code{pthread.h} requires more.
Nevertheless the effort required is much less than writing the modules
by hand.

The @samp{-e} option will emit an error message if a C syntax error is
encountered. The @samp{-p} option generate a comment for every
occurance of an object which cannot be translated into Modula-2.

@node Assembly language, Built-ins, h2def, Using
@section Interface to assembly language

The interface for GNU Modula-2 to assembly language is almost identical to GNU C.
The only alterations are that the keywords asm and volatile are in capitals,
following the Modula-2 convention.

A simple, but highly non optimal, example is given below. Here we want to add the
two @code{CARDINAL}s @code{foo} and @code{bar} together and return the result.

@example
PROCEDURE Example (foo, bar: CARDINAL) : CARDINAL ;
VAR
   myout: CARDINAL ;
BEGIN
   ASM VOLATILE ("movl %1,%%eax; addl %2,%%eax; movl %%eax,%0"
      : "=g" (myout)           (* outputs *)
      : "g" (foo), "g" (bar)   (* inputs  *)
      : "eax") ;               (* we trash *)
   RETURN( myout )
END Example ;
@end example

For a full description of this interface we refer the reader to the GNU C manual.

@xref{Extended Asm, ,Extensions to the C Language Family,gcc}.

@node Built-ins, , Assembly language, Using
@section Accessing GNU Modula-2 Built-ins

This section describes the built-in constants and functions defined in
GNU Modula-2.  The following compiler constants can be accessed using
the @code{__ATTRIBUTE__} @code{__BUILTIN__} keywords. These are not
part of the Modula-2 language and they may differ depending upon the
target architecture but they provide a method whereby common
libraries can interface to a different underlying architecture.

The built-in constants are: @code{BITS_PER_UNIT}, @code{BITS_PER_WORD},
@code{BITS_PER_CHAR} and @code{UNITS_PER_WORD}. They are integrated into
GNU Modula-2 by an extension to the @code{ConstFactor} rule:

@example
ConstFactor := ConstQualidentOrSet | Number | ConstString |
               "(" ConstExpression ")" | "NOT" ConstFactor |
               ConstAttribute =:

ConstAttribute := "__ATTRIBUTE__" "__BUILTIN__" "(" "(" Ident ")" ")" =:
@end example

Here is an example taken from the ISO library @code{SYSTEM.def}:

@example
CONST
   BITSPERLOC    = __ATTRIBUTE__ __BUILTIN__ ((BITS_PER_UNIT)) ;
   LOCSPERWORD   = __ATTRIBUTE__ __BUILTIN__ ((UNITS_PER_WORD)) ;
@end example

Built-in functions are transparent to the end user. All built-in
functions are declared in @code{DEFINITION MODULE}s and are imported
as and when required.  Built-in functions are declared in definition
modules by using the @code{__BUILTIN__} keyword. Here is a section of
the ISO library @code{LongMath.def} which demonstrates this feature.

@example
PROCEDURE __BUILTIN__ sqrt (x: LONGREAL): LONGREAL;
  (* Returns the square root of x *)
@end example

This indicates that the function @code{sqrt} will be implemented using
the gcc built-in maths library. If gcc cannot utilise the built-in
function (for example if the programmer requested the address of
@code{sqrt}) then code is generated to call the alternative function
implemented in the @code{IMPLEMENTATION} @code{MODULE}.

Sometimes a function exported from the @code{DEFINITION} @code{MODULE}
will have a different name from the built-in function within gcc. In such
cases the mapping between the GNU Modula-2 function name and the gcc name
is expressed using the keywords @code{__ATTRIBUTE__} @code{__BUILTIN__}
@code{((Ident))}. For example the function @code{sqrt} in @code{LongMath.def}
maps onto the gcc built-in function @code{sqrtl} and this is expressed as:

@example
PROCEDURE __ATTRIBUTE__ __BUILTIN__ ((sqrtl)) sqrt
                                    (x: LONGREAL) : LONGREAL;
  (* Returns the positive square root of x *)
@end example

The following module @code{Builtins.def} enumerates the list of built-in functions
which can be accessed in GNU Modula-2. It also serves to define the parameter
and return value for each function:

@example
 DEFINITION MODULE Builtins ;

FROM SYSTEM IMPORT ADDRESS ;

PROCEDURE __BUILTIN__ sinf (x: SHORTREAL) : SHORTREAL ;
PROCEDURE __BUILTIN__ sin (x: REAL) : REAL ;
PROCEDURE __BUILTIN__ sinl (x: LONGREAL) : LONGREAL ;

PROCEDURE __BUILTIN__ cosf (x: SHORTREAL) : SHORTREAL ;
PROCEDURE __BUILTIN__ cos (x: REAL) : REAL ;
PROCEDURE __BUILTIN__ cosl (x: LONGREAL) : LONGREAL ;

PROCEDURE __BUILTIN__ sqrtf (x: SHORTREAL) : SHORTREAL ;
PROCEDURE __BUILTIN__ sqrt (x: REAL) : REAL ;
PROCEDURE __BUILTIN__ sqrtl (x: LONGREAL) : LONGREAL ;

PROCEDURE __BUILTIN__ fabsf (x: SHORTREAL) : SHORTREAL ;
PROCEDURE __BUILTIN__ fabs (x: REAL) : REAL ;
PROCEDURE __BUILTIN__ fabsl (x: LONGREAL) : LONGREAL ;

PROCEDURE __BUILTIN__ alloca (i: CARDINAL) : ADDRESS ;
PROCEDURE __BUILTIN__ memcpy (dest, src: ADDRESS; n: CARDINAL) : ADDRESS ;
PROCEDURE __BUILTIN__ index (s: ADDRESS; c: INTEGER) : ADDRESS ;
PROCEDURE __BUILTIN__ rindex (s: ADDRESS; c: INTEGER) : ADDRESS ;
PROCEDURE __BUILTIN__ memcmp (s1, s2: ADDRESS; n: CARDINAL) : INTEGER ;
PROCEDURE __BUILTIN__ memset (s: ADDRESS; c: INTEGER; n: CARDINAL) : ADDRESS ;
PROCEDURE __BUILTIN__ strcat (dest, src: ADDRESS) : ADDRESS ;
PROCEDURE __BUILTIN__ strncat (dest, src: ADDRESS; n: CARDINAL) : ADDRESS ;
PROCEDURE __BUILTIN__ strcpy (dest, src: ADDRESS) : ADDRESS ;
PROCEDURE __BUILTIN__ strncpy (dest, src: ADDRESS; n: CARDINAL) : ADDRESS ;
PROCEDURE __BUILTIN__ strcmp (s1, s2: ADDRESS) : INTEGER ;
PROCEDURE __BUILTIN__ strncmp (s1, s2: ADDRESS; n: CARDINAL) : INTEGER ;
PROCEDURE __BUILTIN__ strlen (s: ADDRESS) : INTEGER ;
PROCEDURE __BUILTIN__ strstr (haystack, needle: ADDRESS) : ADDRESS ;
PROCEDURE __BUILTIN__ strpbrk (s, accept: ADDRESS) : ADDRESS ;
PROCEDURE __BUILTIN__ strspn (s, accept: ADDRESS) : CARDINAL ;
PROCEDURE __BUILTIN__ strcspn (s, accept: ADDRESS) : CARDINAL ;
PROCEDURE __BUILTIN__ strchr (s: ADDRESS; c: INTEGER) : ADDRESS ;
PROCEDURE __BUILTIN__ strrchr (s: ADDRESS; c: INTEGER) : ADDRESS ;

END Builtins.
@end example

Although this module exists and will result in the generation of
inline code if optimization flags are passed to GNU Modula-2, users
are advised to utilize the same functions from more generic libraries.
The built-in mechanism will be applied to these generic
libraries where appropriate. Note for the mathematical routines to
be inlined you need to specify the @samp{-ffast-math -O} options.

@node Internals, Libraries, Using, Top
@chapter GNU Modula-2 Internals

This document is a small step in the long journey of documenting the GNU
Modula-2 compiler and how it integrates with GCC.
The document is still in it's infancy.

@menu
* History::                 Where the sources came from.
* Overview::                Overview of the structure of GNU Modula-2.
* Integrating::             How the front end integrates with gcc.
* Building and installing:: How to build GNU Modula-2.
* Passes::                  What gets processed during each pass.
* Scope rules::             Clarification of some the scope rules.
* Future::                  A future wish list.
* Done list::               Progression of the GNU Modula-2 project.
* To do list::              Outstanding issues.
@end menu

@node History, Overview, , Internals
@section History

The Modula-2 compiler sources have come from the m2f compiler which
runs under GNU/Linux. The original m2f compiler was written in Modula-2
and was bootstrapped via a modified version of p2c 1.20. The m2f
compiler was a recursive descent which generated quadruples as
intermediate code. It also used C style calling convention wherever
possible and utilized a C structure for dynamic arrays.

@node Overview, Integrating, History, Internals
@section Overview

GNU Modula-2 uses flex and a machine generated recursive descent
parser. Most of the source code is written in Modula-2 and
bootstrapping is achieved via a modified version of p2c-1.20.
The modified p2c-1.20 is contained in the GNU Modula-2 source
tree as are a number of other tools necessary for bootstrapping.

The changes to p2c include:

@itemize @bullet
@item
allowing @code{DEFINITION MODULE FOR "C"}
@item
fixes to abstract data types.
@item
making p2c understand the 2nd Edition dialect of Modula-2.
@item
introducing the @code{UNQUALIFIED} keyword.
@item
allowing varargs (@code{...}) inside @code{DEFINITION MODULE FOR "C"} modules.
@item
fixing the parser to understand commented @code{FORWARD} prototypes,
which are ignored by GNU Modula-2.
@item
fixes to the @code{CASE} syntax for 2nd Edition Modula-2.
@item
fixes to a @code{FOR} loop counting down to zero using a @code{CARDINAL}.
@item
introducing an initialization section for each implementation module.
@end itemize

GNU Modula-2 comes with PIM and ISO style libraries. The compiler
is built using PIM libraries and the source of the compiler
complies with the PIM dialect together with a few @code{C}
library calling extensions.

The compiler is a four pass compiler. The first pass tokenizes
the source code, creates scope and enumeration type symbols.
All tokens are placed into a dynamic buffer and subsequent passes reread
tokens and build types, quadruples and resolve hidden types.
@xref{Passes, , ,}.

GNU Modula-2 uses a technique of double book keeping @footnote{See the
excellent tutorial by Joachim Nadler translated by Tim Josling}.
@xref{Back end Access to Symbol Table, , , gcc}.
The front end builds a complete symbol table and a list of quadruples.
Each symbol is translated into a @code{gcc} equivalent after which
each quadruple is translated into a @code{gcc} @code{tree}.

@node Integrating, Building and installing, Overview, Internals
@section How the front end integrates with gcc

The M2Base and M2System
modules contain base types and system types respectively they
map onto GCC back-end data types.

@node Building and installing, Passes, Integrating, Internals
@section Building

The GNU Modula-2 source tree should be unpacked in the GNU GCC
source tree directory @file{gcc-version/gcc}. Typically this
is achieved by the commands:

@example
cd gcc-version/gcc
tar zxf gm2-version.tar.gz
cd ../..
@end example

GNU Modula-2 can be built by typing:

@example
mkdir host-build
cd host-build
../gcc-version/configure
make
cd ..
@end example

It can be installed by:

@example
su
cd host-build
make install
cd ..
@end example

@node Passes, Scope rules, Building and installing, Internals
@section Passes

This section describes the general actions of each pass.  The key to
building up the symbol table correctly is to ensure that the symbols
are only created in the scope where they were declared.  This may seem
obvious (and easy) but it is complicated by two issues: firstly GNU
Modula-2 does not generate @code{.sym} files and so all imported
definition modules are parsed after the module is parsed; secondly the
import/export rules might mean that you can see and use a symbol
before it is declared in a completely different scope.

Here is a brief description of the lists of symbols maintained within
@code{DefImp} and @code{Module} symbols. It is these lists and actions
at each pass which manipulate these lists which solve the scoping and
visability of all symbols.

The @code{DefImp} symbol maintains the: @code{ExportQualified},
@code{ExportUnQualified}, @code{ExportRequest}, @code{IncludeList},
@code{ImportTree}, @code{ExportUndeclared},
@code{NeedToBeImplemented}, @code{LocalSymbols},
@code{EnumerationScopeList}, @code{Unresolved}, @code{ListOfVars},
@code{ListOfProcs} and @code{ListOfModules} lists.

The @code{Module} symbol maintains the: @code{LocalSymbols},
@code{ExportTree}, @code{IncludeList}, @code{ImportTree},
@code{ExportUndeclared}, @code{EnumerationScopeList},
@code{Unresolved}, @code{ListOfVars}, @code{ListOfProcs} and
@code{ListOfModules} lists.

Initially we discuss the lists which are common to both @code{DefImp}
and @code{Module} symbols, thereafter the lists peculiar to @code{DefImp}
and @code{Module} symbols are discussed.

The @code{ListOfVars}, @code{ListOfProcs} and @code{ListOfModules}
lists (common to both symbols) and simply contain a list of
variables, procedures and inner modules which are declared with this
definition/implementation or program module.

The @code{LocalSymbols} list (common to both symbols) contains a
complete list of symbols visible in this modules scope. The symbols in
this list may have been imported or exported from an inner module.

The @code{EnumerationScope} list (common to both symbols)
defines all visible enumeration symbols.
When this module is parsed these the contents of these enumeration
types are marked as visible. Internally to GNU Modula-2 these form a
pseudo scope (rather like a @code{WITH} statement which temporarily
makes the fields of the record visible).

The @code{ExportUndeclared} list (common to both symbols) contains a
list of all symbols marked as exported but as yet undeclared.

The @code{IncludeList} is (common to both symbols) contains a list of
all modules imported by the @code{IMPORT modulename ;} construct.

The @code{ImportTree} (common to both symbols) contains a tree of all
imported identifiers.

The @code{ExportQualified} and @code{ExportUnQualified} trees (only
present in the @code{DefImp} symbol) contain identifiers which are
marked as @code{EXPORT QUALIFIED} and @code{EXPORT UNQUALIFIED}
respectively.

The @code{NeedToBeImplemented} list (only present in the @code{DefImp}
symbol) and contains a list of all unresolved symbols which are exported.

@subsection Pass 1

During pass 1 each @code{DefImp} and @code{Module} symbol is
created. These are also placed into a list of outstanding sources to
be parsed.  The import and export lists are recorded and each object
imported is created in the module from whence it is exported and added
into the imported list of the current module. Any exported objects are
placed into the export list and marked as qualified or unqualified.

Inner module symbols are also created and their import and export
lists are also processed. An import list will result in a symbol being
fetched (or created if it does not exit) from the outer scope and
placed into the scope of the inner module. An export list results in
each symbol being fetched or created in the current inner scope and
added to the outer scope. If the symbol has not yet been declared then
it is added to the current modules @code{ExportUndeclared} list.

Procedure symbols are created (the parameters are parsed but no more
symbols are created). Enumerated types are created, hidden types in
the definition modules are marked as such. All the rest of the Modula-2
syntax is parsed but no symbols are created.

@subsection Pass 2

To do

@subsection Pass 3

To do

@subsection Pass H

To do

@subsection Declaration ordering

This section gives a few stress testing examples and walks though
the mechanics of the passes and how the lists of symbols are created.

The first example contains a nested module in which an enumeration
type is created and exported. A procedure declared before the nested
module uses the enumeration type.

@example
MODULE colour ;

   PROCEDURE make (VAR c: colours) ;
   BEGIN
      c := yellow
   END make ;

   MODULE inner ;
   EXPORT colours ;

   TYPE
      colours = (red, blue, yellow, white) ;
   END inner ;

VAR
   g: colours
BEGIN
   make(g)
END colour.
@end example

@node Scope rules, Future, Passes, Internals
@section Scope rules

This section describes my understanding of the Modula-2 scope rules
with respect to enumerated types.  If they are incorrect please
correct me by email @email{gaius@@glam.ac.uk}. They also serve to document
the behaviour of GNU Modula-2 in these cirumstances.

In GNU Modula-2 the syntax for a type declaration is defined as:

@example
TypeDeclaration := Ident "=" Type =:							   

Type :=  SimpleType | ArrayType
          | RecordType          
          | SetType             
          | PointerType         
          | ProcedureType
      =:								   
									   
SimpleType := Qualident | Enumeration | SubrangeType =:								   
@end example

If the @code{TypeDeclaration} rule is satisfied by
@code{SimpleType} and @code{Qualident} ie:

@example
TYPE
   foo = bar ;
@end example

then @code{foo} is said to be equivalent to @code{bar}. Thus
variables, parameters and record fields declared with either type will
be compatible with each other.

If, however, the @code{TypeDeclaration} rule is satisfied by any
alternative clause @code{ArrayType}, @code{RecordType},
@code{SetType}, @code{PointerType}, @code{ProcedureType},
@code{Enumeration} or @code{SubrangeType} then in these cases a new
type is created which is distinct from all other types.  It will be
incompatible with all other user defined types.

It also has furthur consequences in that if bar was defined as an
enumerated type and foo is imported by another module then the
enumerated values are also visible in this module.

Consider the following modules:

@example
DEFINITION MODULE impc ;

TYPE
   C = (red, blue, green) ;

END impc.
@end example

@example
DEFINITION MODULE impb ;

IMPORT impc ;

TYPE
   C = impc.C ;

END impb.
@end example

@example
MODULE impa ;

FROM impb IMPORT C ;

VAR
   a: C ;
BEGIN
   a := red
END impa.
@end example

Here we see that the type @code{C} defined in module @code{impb} is
equivalent to the type @code{C} in module @code{impc}. Module
@code{impa} imports the type @code{C} from module @code{impb}
and at that point the enumeration values @code{red, blue, green}
(declared in module @code{impc}) are also visible.

At the time of writing I cannot find clarification on this issue in
the PIM-[234] books.  However according to the Interim Version of 4th
Working Draft Modula-2 Standard in sections 6.1.6.4. and 6.1.6.5. The
annotation states that:

``The set of identifiers that are explicitly imported must not be
redeclared in the block that imports those identifiers. The implicitly
imported identifiers are given by the closures of all the explicitly
imported identifiers.''

and closure is defined as:

``The closure of an identifier defines the set of identifiers that is
implicitly imported or exported if that identifier is imported or
exported.''

``The closure of an identifier shall be a set consisting of that
identifier, together with the closure of the type if that identifier
is associated with a type.''

``The closure of an identifier is a singleton set containing that
identifier, for an identifier denoting an enumerated type the closure
set includes the enumerated constants of the type as well as the
identifier denoting the type itself.''

``Thus an identifier denoting with an enumerated type is imported
(exported), then the occurance of that identifier in that import list
(export list) is an abbreviation for the occurrence of that
identifier, together with all of the identifiers associated with the
constant values of the enumerated type.''

Which seems to imply that the following module should not compile:

@example
MODULE impd ;

IMPORT impb ;

VAR
   a: impb.C ;
BEGIN
   a := impb.red  (* red should not be resolved *)
END impd.
@end example

Whereas if the module were altered to:

@example
MODULE impd ;

FROM impb IMPORT C ;

VAR
   a: C ;
BEGIN
   a := red
END impd.
@end example

then @code{red} is resolved and the module is legal.

@node Future, Done list, Scope rules, Internals
@section A future wish list

In the future it might be sensible to rewrite M2Quads.mod to
directly call gcc routines, rather than generate quadruples.
However this is a large alteration and I'd firstly like to
see GNU Modula-2 working with the method outlined above, which is
conceptually easier.

@node Done list, To do list, Future, Internals
@section Done list

What has been done:

@itemize @bullet

@item
provided access to a few compiler built-in constants
and twenty seven built-in C functions.

@item
definition modules no longer have to @samp{EXPORT QUALIFIED}
objects (as per PIM-3, PIM-4 and ISO).

@item
implemented ISO Modula-2 sets. Large sets are now allowed,
no limits imposed. The comparison operators
@samp{# = <= >= < >} all behave as per ISO standard.
The obvious use for large sets is
@samp{SET OF CHAR}. These work well with gdb once it has been
patched to understand Modula-2 sets.

@item
added @code{DEFINITION MODULE FOR "C"} method of linking
to C. Also added varargs handling in C definition modules.

@item
cpp can be run on definition and implementation modules.

@item
@samp{-Wmakell} generates a temporary @code{Makefile} and
will build all dependant modules.

@item
Compiler will bootstrap itself and three generations of the
compiler all produce the same code.

@item
the back end will generate code and assembly declarations for
modules containing global variables of all types. Procedure
prologue/epilogue is created.

@item
all loop constructs, if then else, case statements and expressions.

@item
nested module initialization.

@item
pointers, arrays, procedure calls, nested procedures.

@item
front end @samp{gm2} can now compile and link modules.

@item
the ability to insert gnu asm statements within GNU Modula-2.

@item
inbuilt functions, SIZE, ADR, TSIZE, HIGH etc

@item
block becomes and complex procedure parameters (unbounded arrays, strings).

@item
the front end now utilizes GCC tree constants and types and is no
longer tied to a 32 bit architecture, but reflects the 'configure'
target machine description.

@item
fixed all C compiler warnings when gcc compiles the p2c generated C
with -Wall.

@item
built a new parser which implements error recovery.

@item
added mechanism to invoke cpp to support conditional compilation if required.

@item
all @samp{Makefile}s are generated via @samp{./configure}

@end itemize

@node To do list, , Done list, Internals
@section To do list

What needs to be done:

@itemize @bullet

@item
implement ISO library (use FIO.mod as the underlying substructure).

@item
implement LONGCARD and include IO functions within FpuIO.

@item
implement many of the ISO built-in functions and procedures.

@item
rewrite documentation.

@item
the modula-2 front end needs to convert the quadruples into
trees and the convert these trees into gcc trees, rather than
simply translating each quadruple into a separate gcc tree.
The later works but better code could be generated by
building a large tree and passing this tree to gcc.
One way to implement this is by taking a copy of M2SubExp.mod and
basing the gcc calls on the tree structure that M2SubExp.mod builds.
My belief is that this should not take much time to complete and
should produce better code.

This requires separating the semantic checking routines away from M2Quads.mod.
Propose a new module M2Tree which contains the functionality of M2Quads/M2SubExp.
We should be able to remove M2Quads, M2SubExp, M2Optimize, M2GenGCC, M2EvalSym
once this is complete.

SymbolTable needs to be modified.

@item
investigate the use of collect2 during link/module initialization.

@item
integrate the small testsuite (gm2/m2/comp/autotest)
into dejagnu ?? and improve

@item
Coroutines - as mentioned by readers of comp.lang.modula2.

@item
improve documentation, specifically this document which should
also include a synopsis of 2nd Edition Modula-2.

@item
testing and fixing bugs

@end itemize

@node Libraries, Function Index, Internals, Top
@chapter PIM and ISO library definitions

This chapter contains PIM and ISO libraries. The ISO libraries are currently
work in progress, many are incomplete and even more have no implementation
module. The PIM libraries are very mature as the compiler uses them extensively.

@include gm2-libs.texi

@node Function Index, , Libraries, Top

@c @printindex cp
@printindex fn

@summarycontents
@contents
@bye
