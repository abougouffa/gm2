\input texinfo 
@c -*-texinfo-*-

@c

@code{makeinfo}
@code{texinfo-format-buffer}

@c
@c Design notes and documentation about GNU Modula-2
@c
@c
@c part 1 header
@c

@setfilename gm2.info

@include version.texi
@set version-GDB     6.6
@set version-python  2.5

@settitle The GNU Modula-2 front end to GCC (gm2-@value{version-GM2})

@c Part 2: Titlepage and Copyright

@c The titlepage segment does not appear in the Info file. 
@titlepage
@sp 10
@comment The title is printed in a large font.
@center @titlefont{The GNU Modula-2 front end to GCC}
@sp 10
@center @titlefont{gm2-@value{version-GM2}}
@c
@page
@setchapternewpage odd
@sp 2
@center Gaius Mulley
@sp 3
@center Last updated @value{version-update}
@sp 10
@c
@center @image{gm2/images/gnu,,1.5in}
@sp 6
@quotation
``And then one day you find ten years have got behind you'', Pink Floyd
@end quotation
@c
@vskip 0pt plus 1filll
Copyright @copyright{} 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
2008, 2009, 2010 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with the Front-Cover texts being `A GNU Manual,''
and with the Back-Cover Texts as in (a) below.  A copy of the
license is included in the section entitled `GNU Free Documentation
License.''

(a) The FSF's Back-Cover Text is: `You have freedom to copy and modify
this GNU Manual, like GNU software.  Copies published by the Free
Software Foundation raise funds for GNU development.''
@end titlepage

@c Part 4: `Top' Node and Master Menu

@ifinfo
@node Top, Using, (dir), (dir)
@top Introduction
@end ifinfo

@menu
* Using::            Using GNU Modula-2.
* Obtaining::        Obtaining GNU Modula-2.
* Licence::          Licence of GNU Modula-2.
* GNU Project::      The GNU Project and GNU/Linux.
* Contributing::     Contributing to GNU Modula-2.
* Internals::        GNU Modula-2 internals.
* EBNF::             EBNF of GNU Modula-2
* Libraries::        PIM and ISO library definitions.
* Function Index::   Index for all library functions.
@end menu

@node Using, Obtaining, Top, Top
@chapter Using GNU Modula-2

@menu
* What is GNU Modula-2::  Brief description of GNU Modula-2.
* Why use GNU Modula-2::  Advantages of GNU Modula-2.
* Release map::           Future releases of GNU Modula-2.
* Compiler options::      GNU Modula-2 compiler options.
* Example usage::         Example compile and link.
* Environment variables:: GNU Modula-2 related environment variables.
* Elementary data types:: Data types supported by GNU Modula-2.
* Standard procedures::   Permanently accessible base procedures.
* Dialect::               GNU Modula-2 supported dialects.
* Exceptions::            Exception implementation
* Extensions::            GNU Modula-2 language extensions.
* Type compatibility::    Data type compatibility.
* Unbounded by reference::Explanation of a language optimization.
* Building a shared library:: How to build a shared library.
* Interface for Python::  How to produce swig interface files.
* Producing a Python module::  How to produce a Python module.
* Interface to C::        Interfacing GNU Modula-2 to C.
* Assembly language::     Interface to assembly language.
* Alignment::             Data type alignment.
* Built-ins::             Accessing GNU Modula-2 Built-ins.
* The PIM system module:: SYSTEM data types and procedures.
* The ISO system module:: SYSTEM data types, procedures and run time.
@end menu

This document contains the user and design issues relevant to the
Modula-2 front end to gcc.  Throughout this document the GNU Modula-2
front end is often referred to as @samp{gm2-@value{version-GM2}} or
@samp{gm2} for short.  This corresponds to GCC version
@value{version-GCC} and GNU Modula-2 version @value{version-GM2}.

@node What is GNU Modula-2, Why use GNU Modula-2, , Using
@section What is GNU Modula-2

GNU Modula-2 is a front end @uref{http://gcc.gnu.org/frontends.html}
for GCC. GCC is a retargetable C compiler which has been ported to a large
number of architectures and operating systems. GNU Modula-2 utilizes the
back end of GCC and replaces the C language front end with a Modula-2
front end. Consequently GNU Modula-2 has been built on i[3456]86 GNU/Linux,
i[3456]86 BSD, Opteron LP64 GNU/Linux and sparc GNU/Linux systems.
It has also been built as a cross compiler for MinGW, StrongARM GNU/Linux
and ATMega8 microprocessor.

The GNU Modula-2 compiler is compliant with four dialects of Modula-2.
The language as defined in 'Programming in Modula-2' 2nd Edition,
Springer Verlag, 1982, 1983 by Niklaus Wirth (PIM2), 'Programming in
Modula-2', 3rd Corrected Edition, Springer Verlag, 1985 (PIM3) and
'Programming in Modula-2', 4th Edition, Springer Verlag, 1988 (PIM4)
@uref{http://freepages.modula2.org/report4/modula-2.html} and the ISO
Modula-2 language as defined in ISO/IEC Information technology -
programming languages - part 1: Modula-2 Language, ISO/IEC 10514-1
(1996) (ISO).

There are currently three sets of libraries. The 'Programming in
Modula-2' libraries, the 'University of ULM libraries' and the ISO
libraries. The ISO libraries are still being written, however all
definition modules for the three library sets are contained within
this document.

@node Why use GNU Modula-2, Release map, What is GNU Modula-2, Using
@section Why use GNU Modula-2

This section is not designed to generate a language war, but rather
map out some of the advantages of using GNU Modula-2 rather than
translate Modula-2 sources into another language.

It is expected that the primary purpose of GNU Modula-2 will be to
compile legacy code. Currently there are only a few commercial
Modula-2 compilers being actively maintained. Code which was written
ten or fifteen years ago may still be compiled by older commercial
(possibly unmaintained) compilers. While the 32 bit x86 remains these
compilers presumably can be run in compatibility mode (some compilers
only produced 16 bit code). Time is running out as the computing
industry is switching to 64 microprocessors.  While x86 emulation or
16 bit backwards compatibility is always possible it has some serious
drawbacks. In order for the older source to run natively the source
code will either have to be translated into another high level
language or alternatively a Modula-2 compiler which can target these
new generation of microprocessors will have to be acquired. GNU
Modula-2 builds and passes all its regression tests on Debian Pure 64
(LP64 architecture), 64 bit Solaris, 32 bit x86 GNU/Linux (Suse,
Debian, stable and unstable) and 32 bit x86 FreeBSD.  GNU Modula-2 has
also been configured as a cross compiler for embedded microprocessors
such as the ATMega8 and StrongArm.

GNU Modula-2 also has the advantage of being closely tied to GCC.  Not
only does this produce excellent code and excellent architectural and
operating system coverage but it also utilises many of the GCC
features. For example GNU Modula-2 can invoke the C preprocessor to
manage conditional compilation; in-lining of @code{SYSTEM} procedures,
intrinsic functions, memory copying routines are also exploited;
access to assembly language using GCC syntax is also provided.  GNU
Modula-2 also support sets of any ordinal type (memory permitting).
The compiler can also easily generate shared library modules and it
has an automatic method of producing a swig interface file from a
definition module.  This means that after a few command line
invocations the compiler can generate Python, Perl or TCL shared
library modules providing they use simple data types.

GNU Modula-2 was based on a Modula-2 front end which performed a
substantial amount of static analysis of the source code (see
@samp{-Wpedantic}, @samp{-Wpedantic-param-names}, @samp{-Wstudents}
and @samp{-Wpedentic-cast}.

Finally runtime checking has been implemented and can check to ensure
that ranges of subranges are not exceeded, array indices are within
range, functions execute a @code{RETURN} statement, a pointer does not
dereference a @code{NIL} pointer value and that the expression within
a @code{CASE} statement is correctly matched.

@node Release map, Compiler options, Why use GNU Modula-2, Using
@section Release map

This section attempts to give an idea of which releases points are
likely in the future. Clearly this is a fairly fluid release map but
hopefully it is more helpful than omitting it altogether. Please note
that this is not set in stone and if you wish to see something
different please email @email{gaius@@gnu.org} with your ideas. Also
please note that the actual release numbers do not have any
correlation to the estimated time of release. For example please do
not misunderstand that GM2-1.0 will take twice as long as GM2-0.5 to
appear. It is worthing noting that some of the later points in the
release life have already been addressed (in part) but are not yet
complete.

@table @code

@item 0.50
compatible with gcc-3.3.6. GNU Modula-2 is stable and passes all
regression tests on LP64 Opteron and 32 bit x86 GNU/Linux.  The
compiler is PIM-234 compatible (use @samp{-fpim2}, @samp{-fpim3} and
@samp{-fpim4} to force mutually exclusive PIM features).

It is also able to compile the University of Ulm libraries which are
now distributed as part of GNU Modula-2.  To reference these libraries
use the @samp{-flibs=ulm} compiler switch.

@item 0.60
many Logitech compatible libraries will be provided, which will
be available when invoked by @samp{-fpim}.

@item 0.70
ISO exception handling working.  Core exception handling ISO modules
completed.  Basic ISO IO libraries implemented.  Multi-dimensional
dynamic arrays complete.  COMPLEX types implemented.

@item 0.80
a full set of ISO libraries will have been implemented.
This release point marks the bug fixing of libraries and porting
and fixing bugs.

@item 0.90
This release marks the porting and bug fixing and rapid releasing
count down towards..

@item 1.0
GNU Modula-2 will be fully ISO compliant.
@end table

There will be releases inbetween those outlined above and these
releases may occur when GNU Modula-2 builds using a different GCC
source tree.  It is a goal that backward compatibility to gcc-3.3.6
will be provided as far as it is possible.  Releases will also occur
if a key component of ISO Modula-2 is implemented (for example
exception handling, complex types or @samp{FINALLY} is implemented).

@node Compiler options, Example usage, Release map, Using
@section Compiler options

This section describes the compiler options specific to GNU Modula-2
for generic flags details see @xref{Invoking GCC, , ,gcc}.

@table @code

@item -d
a GCC option @xref{Invoking GCC, , ,gcc}.  It allows users
to specify how the rtl passes should dump their internal state.

@item -g
create debugging information so that debuggers such as @file{gdb}
can inspect and control executables.

@item -I
used to specify the search path for definition and implementation
modules.  An example is:  @code{gm2 -g -c -I.:../../libs foo.mod}.
If this option is not specified then the default path is added
which consists of the current directory followed by the appropriate
language dialect library directories.

@item -fobject-path=
used to specify the path for objects during the linking stage.  An
example is: @code{gm2 -g -fobject-path=.:../../libs/O2 -I.:../../libs
foo.mod}.  The combination of @code{-I} and @code{-fobject-path=}
allows projects to keep various styles of objects separate from their
source counterparts.  For example it would be possible to compile
implementation modules with different levels of optimization and
with/without debugging and keep them in separate directories.  If the
@code{-fobject-path=} option is not specified then it is set
internally by using the path as specified by the @code{-I} option.  If
the @code{-I} was also not specified then it uses the current
directory.  In all cases the appropriate language dialect library
directories are appended to the end of the path.

@item -fdump-system-exports
display all inbuilt system items.
This is an internal command line option.

@item -fswig
generate a swig interface file.

@item -fshared
generate a shared library from the module.

@item -fmakeinit
generate the start up C++ code for the module, a file
@file{_m2_modulename.cpp} is created.  This is an internal command
line option.

@item -fmakeall
generate a temporary makefile and build all dependent modules and
link.

@item -fclean
removes all objects before building the application.  This option
should be used with @code{-fmakeall}.

@item -fruntime-modules=
specify, using a comma separated list, the runtime modules and their
order.  These modules will initialized first before any other modules
in the application dependancy.  By default the runtime modules list is
set to @code{Storage,SYSTEM,M2RTS,RTExceptions,IOLink}.  Note that
these modules will only be linked into your executable if they are
required.  So adding a long list of dependant modules will not effect
the size of the executable it merely states the initialisation order
should they be required.

@item -fnil
generate code to detect accessing data through a
@code{NIL} value pointer.

@item -fno-nil
do not generate code to detect accessing data through a
@code{NIL} value pointer.

@item -fwholediv
generate code to detect whole number division by zero or modulus by zero.

@item -fno-wholediv
do not generate code to detect whole number division by zero or
modulus by zero.

@c @item -fwholevalue
@c generate code to detect whole number overflow and underflow.

@c @item -fno-wholevalue
@c do not generate code to detect whole number overflow and underflow.

@c @item -frealdiv
@c generate code to detect real number division by zero.

@c @item -fno-realdiv
@c do not generate code to detect real number division by zero.

@c @item -frealvalue
@c generate code to detect @code{NaN}s real number overflow and underflow.

@c @item -fno-realvalue
@c do not generate code to detect @code{NaN}s real number overflow and underflow.

@item -findex
generate code to check whether array index values are out of bounds.

@item -fno-index
do not generate code to check whether array index values are out of
bounds.

@item -frange
generate code to check the assignment range, return value range
set range and constructor range.

@item -fno-range
do not generate code to check the assignment range, return value range
set range and constructor range.

@item -freturn
generate code to check that functions always exit with a @code{RETURN}
and do not fall out at the end.

@item -fcase
turns on compile time checking to check whether a @code{CASE}
statement requires an @code{ELSE} clause when on was not specified.

@item -fsoft-check-all
turns on all runtime checks.  This is the same as invoking
GNU Modula-2 using the command options
@code{-fnil} @code{-frange} @code{-findex}
@c @code{-fwholevalue}  --fixme-- add this when working
@code{-fwholediv} @code{-fcase} @code{-freturn} @code{-fcase}.

@item -fno-exceptions
turns off all generation of exception handling code and no references
are made to the runtime exception libraries.

@item -v
display all calls to subsidiary programs, such as the C preprocessor,
the GNU Modula-2 linker and compiler.

@item -fstatistics
generates quadruple information: number of quadruples generated,
number of quadruples remaining after optimisation.

@item -fmakelist
this option is only applicable when linking a program module.  The
compiler will generate a @file{modulename.lst} file which contains a
list indicating the initialisation order of all modules which are to
be linked. The actual link does not occur.  The GNU Modula-2 linker
scans all @code{IMPORT}s, generates a list of dependencies and
produces an ordered list for initialisation. It will probably get the
order wrong if your project has cyclic dependencies, but the
@file{.lst} file is plain text and can be modified if required.  Once
the @file{.lst} file is created it can be used by the compiler to link
your project via the @samp{-fuselist} option.  It has no effect if the
@samp{-c} option is present.

@item -fuselist
providing @samp{gm2} has been told to link the program module this
option uses the file @file{modulename.lst} for the initialisation
order of modules.

@item -fcpp
preprocess the source with @samp{cpp -lang-asm -traditional-cpp}
For further details about these options see @xref{Invocation, , ,cpp}.
If @samp{-fcpp} is supplied then all definition modules and
implementation modules which are parsed will be preprocessed by
@samp{cpp}.

@item -fiso
turn on ISO standard features. Currently this enables the ISO
@code{SYSTEM} module and alters the default library search path so
that the ISO libraries are searched before the PIM libraries.  It also
effects the behaviour of @code{DIV} and @code{MOD} operators.
See @xref{Dialect, , ,gm2}.

@item -fpim
turn on PIM standard features. Currently this enables the PIM
@code{SYSTEM} module and determines which identifiers are pervasive
(declared in the base module). If no other @samp{-fpim[234]} switch is
used then division and modulus operators behave as defined in PIM4.
See @xref{Dialect, , ,gm2}.

@item -fpim2
turn on PIM-2 standard features. Currently this removes @code{SIZE}
from being a pervasive identifier (declared in the base module).  It
places @code{SIZE} in the @code{SYSTEM} module.  It also effects the
behaviour of @code{DIV} and @code{MOD} operators.
See @xref{Dialect, , ,gm2}.

@item -fpim3
turn on PIM-3 standard features. Currently this only effects the
behaviour of @code{DIV} and @code{MOD} operators.
See @xref{Dialect, , ,gm2}.

@item -fpim4
turn on PIM-4 standard features. Currently this only effects the
behaviour of @code{DIV} and @code{MOD} operators.
See @xref{Dialect, , ,gm2}.

@item -fpositive-mod-floor-div
forces the @code{DIV} and @code{MOD} operators to behave as defined by PIM4.
All modulus results are positive and the results from the division are
rounded to the floor.
See @xref{Dialect, , ,gm2}.

@item -flibs=ulm
modifies the default library search path so that the University of Ulm
libraries are searched before the other PIM libraries.

@item -flibs=pim
modifies the default library search path so that the PIM libraries
are searched before any others (the default).

@item -flibs=min
modifies the default library search path so that the absolute minimum
of Modula-2 runtime libraries are loaded (a stripped down M2RTS, SYSTEM
and libc).

@item -flibs=iso
modifies the default library search path so that the ISO libraries are
searched before any others (not needed if @samp{-fiso} was specified).

@item -flibs=logitech
modifies the default library search path so that the Logitech compatible
libraries are searched before the base PIM libraries.

@item -flibs=pim-coroutine
modifies the default libraries search path so that the PIM @code{SYSTEM}
module providing coroutine support is searched before the base PIM libraries.
This directory also includes many coroutine related libraries.

@item -fextended-opaque
allows opaque types to be implemented as any type. This is a GNU
Modula-2 extension and it requires that the implementation module
defining the opaque type is available so that it can be resolved when
compiling the module which imports the opaque type.

@item -fsources
displays the path to the source of each module.  This option
can be used at compile time to check the correct definition module
is being used.

@item -fmodules
displays the path to each modules object file.  This option
is used at link time to check the correct object file is being
linked.

@item -fdef=
recognise the specified suffix as a definition module filename.
The default implmentation and module filename suffix is @file{.def}.
If this option is used GNU Modula-2 will still fall back to this
default if a requested definition module is not found.

@item -fmod=
recognise the specified suffix as implementation and module filenames.
The default implmentation and module filename suffix is @file{.mod}.
If this option is used GNU Modula-2 will still fall back to this
default if it needs to read an implmentation module and the specified
suffixed filename does not exist.
Both this option and @code{-fdef=} also work with the @code{-fmakeall}
option.

@item -fxcode
issues all errors and warnings in the @file{Xcode} format.

@item -funbounded-by-reference
enable optimization of unbounded parameters by attempting to pass non
@code{VAR} unbounded parameters by reference.  This optimization
avoids the implicit copy inside the callee procedure. GNU Modula-2
will only allow unbounded parameters to be passed by reference if,
inside the callee procedure, they are not written to, no address is
calculated on the array and it is not passed as a @code{VAR}
parameter.  Note that it is possible to write code to break this
optimization, therefore this option should be used carefully.
For example it would be possible to take the address of an array, pass
the address and the array to a procedure, read from the array in
the procedure and write to the location using the address parameter.

Due to the dangerous nature of this option it is not enabled
when the -O option is specified.

@item -Wverbose-unbounded
inform the user which non @code{VAR} unbounded parameters will be
passed by reference.  This only produces output if the option
@samp{-funbounded-by-reference} is also supplied on the command line.

@item -Wstudents
checks for bad programming style. This option is aimed at new users of
Modula-2 in that it checks for situations which might cause confusion
and thus mistakes.  It checks whether variables of the same name are
declared in different scopes and whether variables look like keywords.
Experienced users might find this option too aggressive.

@item -Wpedantic
forces the compiler to reject nested @code{WITH} statements
referencing the same record type.  Does not allow multiple imports of
the same item from a module.  It also checks that: procedure variables
are written to before being read; variables are not only written to
but read from; variables are declared and used.  If the compiler
encounters a variable being read before written it will terminate with
a message.  It will check that @code{FOR} loop indices are not used
outside the end of this loop without being reset.

@item -Wpedantic-param-names
procedure parameter names are checked in the definition module 
against their implementation module counterpart. This is not
necessary in ISO or PIM versions of Modula-2, but it can be
extremely useful, as long as code is intentionally
written in this way.

@item -Wpedantic-cast
warns if the ISO system function is used and if the size of
the variable is different from that of the type. This is legal
in ISO Modula-2, however it can be dangerous. Some users may prefer
to use @code{VAL} instead in these situations and use @code{CAST}
exclusively for changes in type on objects which have the same size.

@end table

@node Example usage, Environment variables, Compiler options, Using
@section Example compile and link

This section describes how to compile and link a simple hello world
program.  It provides a few examples of using the different options
mentioned in @xref{Compiler options, , ,gm2}.  Assuming that you have
a file called @file{hello.mod} in your current directory which
contains:

@example
MODULE hello ;

FROM StrIO IMPORT WriteString, WriteLn ;

BEGIN
   WriteString('hello world') ; WriteLn
END hello.
@end example

You should be able to compile it by: @samp{gm2 -c -g -I. hello.mod}
and link via: @samp{gm2 -g -I. hello.mod}.  The result should be an
@samp{a.out} file created in your directory.

Alternatively it may be compiled by:

@samp{gm2 -g -I. -fmakeall hello.mod}
@footnote{To see all the compile actions taken by @samp{gm2} users can also
add the @samp{-v} flag at the command line, for example:

@samp{gm2 -v -g -I. -fmakeall hello.mod}

This displays the subprocesses initiated by @samp{gm2} which can be useful
when trouble shooting.}

@node Environment variables, Elementary data types, Example usage, Using
@section GNU Modula-2 related environment variables

This section descibes the environment variables used by GNU Modula-2 and
how they can be used to switch between releases of the compiler.  Other
environment variables can be set to modify the default library path.
Initially we will consider environment variables most likely used by
the end user.  These two environment variables are @code{GM2IPATH}
and @code{GM2OPATH}.

For example suppose a compile and link on the command line looks like
this:

@example
$ gm2 -g -c -I. -I../project:../project/unix foo.mod
$ gm2 -g -I. -I../project:../project/unix \
  -fobject-path=../project/obj:../project/unix/obj -I. foo.mod
@end example

they can be simplified by utilising two environment variables to do
exactly the same compile and link.

@example
$ export GM2IPATH=../project:../project/unix
$ export GM2OPATH=../project/obj:../project/unix/obj
$ gm2 -g -c -I. foo.mod
$ gm2 -g -I. foo.mod
@end example

It is important to note that the two environment variables
@code{GM2IPATH} and @code{GM2OPATH} have a lower priority than any
@code{-I} or @code{-fobject-path=} command line option.  The search
order for compiling and linking is: command line switches followed by
environment variable paths followed by default runtime libraries or
Modula-2 dialect libraries.  If in doubt include the @code{-v} option
to see the search path used between the compiler subcomponents.

Lastly there is the @code{GM2_ROOT} environment variable which
determines where the compiler subcomponents reside in the
filesystem.  This environment variable overrides the compiler time
configure option @code{--prefix=}.  For example suppose the compiler
was built to reside in @file{/usr/local} and the system administrator
decided to move the entire compiler tree to
@file{/architecture/i386/usr}.  Once the tree is moved then a system
wide environment variable (@code{GM2_ROOT}) could be set to:

@example
$ export GM2_ROOT=/architecture/i386/usr
@end example

The system administrator needs to ensure that the front end binary
@file{gm2} can be seen by the users path.  At that point a user can
invoke @code{gm2 -g -c -I. hello.mod} from the command line and all
subcomponents will be picked up from @file{/architecture/i386/usr}.
This allows users to try out different GNU Modula-2 releases and also
allows system administrators to install compiler binaries at different
locations to where they were initially configured to reside.

The environment variable @code{GM2_ROOT} has no effect if either the
@code{LIBRARY_PATH} or @code{COMPILE_PATH} is set.  The last two
environment variables are used by @code{gcc}.  However if by mistake
@code{GM2_ROOT} and either @code{LIBRARY_PATH} or @code{COMPILE_PATH}
is set then an error message is issued.

@node Elementary data types, Standard procedures, Environment variables, Using
@section Elementary data types

This section describes the elementary data types supported by GNU
Modula-2. It also describes the relationship between these data types
and the equivalent C data types.

The following data types are supported: @code{INTEGER},
@code{LONGINT}, @code{SHORTINT}, @code{CARDINAL}, @code{LONGCARD},
@code{SHORTCARD}, @code{BOOLEAN}, @code{REAL}, @code{LONGREAL},
@code{SHORTREAL}, @code{COMPLEX}, @code{LONGCOMPLEX},
@code{SHORTCOMPLEX} and @code{CHAR}.

An equivalence table is given below:

@example
GNU Modula-2              GNU C
======================================
INTEGER                   int
LONGINT                   long long int
SHORTINT                  short int
CARDINAL                  unsigned int
LONGCARD                  long long unsigned int
SHORTCARD                 short unsigned int
BOOLEAN                   int
REAL                      double
LONGREAL                  long double
SHORTREAL                 float
CHAR                      char
SHORTCOMPLEX              complex float
COMPLEX                   complex double
LONGCOMPLEX               complex long double
@end example

Note that GNU Modula-2 also supports fixed sized data types which are
exported from the @code{SYSTEM} module.
@xref{The PIM system module, , ,gm2}.
@xref{The ISO system module, , ,gm2}.

@node Standard procedures, Dialect, Elementary data types, Using
@section Permanently accessible base procedures.

This section describes the procedures and functions which are
always visible.

@subsection Standard procedures and functions common to PIM and ISO

The following procedures are implemented and conform with Programming
in Modula-2 and ISO Modula-2: @code{NEW}, @code{DISPOSE}, @code{INC},
@code{DEC}, @code{INCL}, @code{EXCL} and @code{HALT}.  The standard
functions are: @code{ABS}, @code{CAP}, @code{CHR}, @code{FLOAT},
@code{HIGH}, @code{LFLOAT}, @code{LTRUNC}, @code{MIN}, @code{MAX},
@code{ODD}, @code{SFLOAT}, @code{STRUNC} @code{TRUNC} and
@code{VAL}. All these functions and procedures (except @code{HALT},
@code{NEW}, @code{DISPOSE} and, under non constant conditions,
@code{LENGTH}) generate in-line code for efficiency.

@example

(*
   ABS - returns the positive value of, i.
*)

@findex ABS
PROCEDURE ABS (i: <any signed type>) : <any signed type> ;

@end example

@example

(*
   CAP - returns the capital of character, ch, providing
         ch lies within the range 'a'..'z'. Otherwise, ch,
         is returned unaltered.
*)

@findex CAP
PROCEDURE CAP (ch: CHAR) : CHAR ;

@end example

@example

(*
   CHR - converts a value of a <whole number type> into a CHAR.
         CHR(x) is shorthand for VAL(CHAR, x).
*)

@findex CHR
PROCEDURE CHR (x: <whole number type>) : CHAR ;

@end example

@example

(*
   DISPOSE - the procedure DISPOSE is replaced by:
             DEALLOCATE(p, TSIZE(p^)) ;
             The user is expected to import the procedure DEALLOCATE
             (normally found in the module, Storage.)

             In:  a variable p: of any pointer type which has been
                  initialized by a call to NEW.
             Out: the area of memory
                  holding p^ is returned to the system.
                  Note that the underlying procedure DEALLOCATE
                  procedure in module Storage will assign p to NIL.
*)

@findex DISPOSE
PROCEDURE DISPOSE (VAR p:<any pointer type>) ;
@end example

@example

(*
   DEC - can either take one or two parameters.  If supplied
         with one parameter then on the completion of the call to
         DEC, v will have its predecessor value.  If two
         parameters are supplied then the value, v, will have its
         n'th predecessor.  For these reasons the value of n
         must be >=0.
*)

@findex DEC
PROCEDURE DEC (VAR v: <any base type>; [n: <any base type> = 1]) ;
@end example

@example

(*
   EXCL - excludes bit element, e, from a set type, s.
*)

@findex EXCL
PROCEDURE EXCL (VAR s: <any set type>; e: <element of set type s>) ;
@end example

@example

(*
   FLOAT - will return a REAL number whose value is the same as, o.
*)

@findex FLOAT
PROCEDURE FLOAT (o: <any whole number type>) : REAL ;
@end example

@example

(*
   FLOATS - will return a SHORTREAL number whose value is the same as, o.
*)

@findex FLOATS
PROCEDURE FLOATS (o: <any whole number type>) : REAL ;
@end example

@example

(*
   FLOATL - will return a LONGREAL number whose value is the same as, o.
*)

@findex FLOATL
PROCEDURE FLOATL (o: <any whole number type>) : REAL ;
@end example

@example

(*
   HALT - will call the HALT procedure inside the module M2RTS.
          Users can replace M2RTS.
*)

@findex HALT
PROCEDURE HALT ;
@end example

@example

(*
   HIGH - returns the last accessible index of an parameter declared as
          ARRAY OF CHAR. Thus

          PROCEDURE foo (a: ARRAY OF CHAR) ;
          VAR
             c: CARDINAL ;
          BEGIN
             c := HIGH(a)
          END foo ;

          BEGIN
             foo('hello')
          END

          will cause the local variable, c, to contain the value 4
*)

@findex HIGH
PROCEDURE HIGH (a: ARRAY OF CHAR) : CARDINAL ;
@end example

@example

(*
   INC - can either take one or two parameters.  If supplied
         with one parameter then on the completion of the call to
         INC, v will have its successor value.  If two
         parameters are supplied then the value, v, will have its
         n'th successor.  For these reasons the value of n
         must be >=0.
*)

@findex INC
PROCEDURE INC (VAR v: <any base type>; [n: <any base type> = 1]) ;
@end example

@example

(*
   INCL - includes bit element, e, to a set type, s.
*)

@findex INCL
PROCEDURE INCL (VAR s: <any set type>; e: <element of set type s>) ;
@end example

@example

(*
   LFLOAT - will return a LONGREAL number whose value is the same as, o.
*)

@findex LFLOAT
PROCEDURE LFLOAT (o: <any whole number type>) : LONGREAL ;
@end example

@example

(*
   LTRUNC - will return a LONG<type> number whose value is the same as, o.
            PIM2, PIM3 and ISO Modula-2 will return a LONGCARD
            whereas PIM4 returns LONGINT.
*)

@findex LTRUNC
PROCEDURE LTRUNC (o: <any floating point type>) : LONG<type> ;
@end example

@example

(*
   MIN - returns the lowest legal value of an ordinal type.
*)

@findex MIN
PROCEDURE MIN (t: <ordinal type>) : <ordinal type> ;

@end example

@example

(*
   MAX - returns the largest legal value of an ordinal type.
*)

@findex MAX
PROCEDURE MAX (t: <ordinal type>) : <ordinal type> ;

@end example

@example

(*
   NEW - the procedure NEW is replaced by:
         ALLOCATE(p, TSIZE(p^)) ;
         The user is expected to import the procedure ALLOCATE
         (normally found in the module, Storage.)

         In:  a variable p: of any pointer type.
         Out: variable, p, is set to some allocated memory
              which is large enough to hold all the contents of p^.
*)

@findex NEW
PROCEDURE NEW (VAR p:<any pointer type>) ;
@end example

@example

(*
   ODD - returns TRUE if the value is not divisible by 2.
*)

@findex ODD
PROCEDURE ODD (x: <whole number type>) : BOOLEAN ;

@end example

@example

(*
   SFLOAT - will return a SHORTREAL number whose value is the same as, o.
*)

@findex SFLOAT
PROCEDURE SFLOAT (o: <any whole number type>) : SHORTREAL ;
@end example

@example

(*
   STRUNC - will return a SHORT<type> number whose value is the same as, o.
            PIM2, PIM3 and ISO Modula-2 will return a SHORTCARD
            whereas PIM4 returns SHORTINT.
*)

@findex STRUNC
PROCEDURE STRUNC (o: <any floating point type>) : SHORT<type> ;
@end example

@example

(*
   TRUNC - will return a <type> number whose value is the same as, o.
           PIM2, PIM3 and ISO Modula-2 will return a CARDINAL
           whereas PIM4 returns INTEGER.
*)

@findex TRUNC
PROCEDURE TRUNC (o: <any floating point type>) : <type> ;
@end example

@example

(*
   TRUNCS - will return a <type> number whose value is the same as, o.
            PIM2, PIM3 and ISO Modula-2 will return a SHORTCARD
            whereas PIM4 returns SHORTINT.
*)

@findex TRUNCS
PROCEDURE TRUNCS (o: <any floating point type>) : <type> ;
@end example

@example

(*
   TRUNCL - will return a <type> number whose value is the same as, o.
            PIM2, PIM3 and ISO Modula-2 will return a LONGCARD
            whereas PIM4 returns LONGINT.
*)

@findex TRUNCL
PROCEDURE TRUNCL (o: <any floating point type>) : <type> ;
@end example

@example

(*
   VAL - converts data, i, of <any simple data type 2> to
         <any simple data type 1> and returns this value.
         No range checking is performed during this conversion.
*)

@findex VAL
PROCEDURE VAL (<any simple data type 1>,
               i: <any simple data type 2>) : <any simple data type 1> ;

@end example

@subsection ISO specific standard procedures and functions

The standard function @code{LENGTH} is specific to ISO Modula-2 and
is defined as:

@example

(*
   IM - returns the imaginary component of a complex type.
        The return value will the same type as the imaginary field
        within the complex type.
*)

@findex IM
PROCEDURE IM (c: <any complex type>) : <floating point type> ;
@end example

@example

(*
   INT - returns an INTEGER value which has the same value as, v.
         This function is equivalent to: VAL(INTEGER, v).
*)

@findex INT
PROCEDURE INT (v: <any ordinal type>) : INTEGER ;
@end example

@example

(*
   LENGTH - returns the length of string, a.
*)

@findex LENGTH
PROCEDURE LENGTH (a: ARRAY OF CHAR) : CARDINAL ;
@end example

This function is evaluated at compile time, providing that string
@code{a} is a constant. If @code{a} cannot be evaluated then a call is
made to @code{M2RTS.Length}.

@example

(*
   ODD - returns a BOOLEAN indicating whether the whole number
         value, v, is odd.
*)

@findex ODD
PROCEDURE ODD (v: <any whole number type>) : BOOLEAN ;
@end example

@example

(*
   RE - returns the real component of a complex type.
        The return value will the same type as the real field
        within the complex type.
*)

@findex RE
PROCEDURE RE (c: <any complex type>) : <floating point type> ;
@end example

@node Dialect, Exceptions, Standard procedures, Using
@section GNU Modula-2 supported dialects

This section describes the dialects understood by GNU Modula-2.
It also describes the differences between the dialects and
any command line switches which determine dialect behaviour.

The GNU Modula-2 compiler is compliant with four dialects of Modula-2.
The language as defined in 'Programming in Modula-2' 2nd Edition,
Springer Verlag, 1982, 1983 by Niklaus Wirth (PIM2), 'Programming in
Modula-2', 3rd Corrected Edition, Springer Verlag, 1985 (PIM3) and
'Programming in Modula-2', 4th Edition, Springer Verlag, 1988 (PIM4)
@uref{http://freepages.modula2.org/report4/modula-2.html} and the ISO
Modula-2 language as defined in ISO/IEC Information technology -
programming languages - part 1: Modula-2 Language, ISO/IEC 10514-1
(1996) (ISO).

The command line switches @samp{-fpim2}, @samp{-fpim3},
@samp{-fpim4} and @samp{-fiso} can be used to force mutually
exclusive features. However by default the compiler will not
agressively fail if a non mutually exclusive feature is used
from another dialect. For example it is possible to specify
@samp{-fpim2} and still utilise @samp{DEFINITION} @samp{MODULES}
which have no export list.

Some dialect differences will force a compile time error, for example
in PIM2 the user must @code{IMPORT} @code{SIZE} from the module
@code{SYSTEM}, whereas in PIM3 and PIM4 @code{SIZE} is a pervasive
function. Thus compiling PIM4 source code with the @samp{-fpim2}
switch will cause a compile time error. This can be fixed quickly
with an additional @code{IMPORT} or alternatively by compiling with
the @samp{-fpim4} switch.

However there are some very important differences between the dialects
which are mutually exclusive and therefore it is vital that users
choose the dialects with care when these language features are used.

@subsection Integer division, remainder and modulus

The most dangerous set of mutually exclusive features found in the
four dialects supported by GNU Modula-2 are the @code{INTEGER}
division, remainder and modulus arithmetic operators.  It is important
to note that the same source code can be compiled to give different
runtime results depending upon these switches! The reference manual
for the various dialects of Modula-2 are quite clear about this
behaviour and sadly there are three distinct definitions.

The table below illustrates the problem when a negative operand is
used.

@example
                  Pim2/3          Pim4                ISO
               -----------    -----------    ----------------------
lval    rval   DIV     MOD    DIV     MOD    DIV    MOD    /    REM
 31      10      3       1      3       1      3      1     3     1
-31      10     -3      -1     -4       9     -4      9    -3    -1
 31     -10     -3       1     -3       1     Exception    -3     1
-31     -10      3      -1      4       9     Exception     3    -1
@end example

See also P24 of PIM2, P27 of PIM3, P29 of PIM4 and P201 of the ISO
Standard.  At present all dialect division, remainder and modulus are
implemented as above, apart from the exception calling in the ISO
dialect. Instead of exception handling the results are the same as the
PIM4 dialect. This is a temporary implementation situation.

@node Exceptions, Extensions, Dialect, Using
@section Exception implementation

This section describes how exceptions are implemented in GNU Modula-2
and how command line switches affect their behaviour.  The option
@samp{-fsoft-check-all} enables all software checking of nil
dereferences, division by zero etc.  Additional code is produced to
check these conditions and exception handlers are invoked if the
conditions prevail.

Without @samp{-fsoft-check-all} these exceptions will be caught by
hardware (assuming the hardware support) and a signal handler is
invoked.  The signal handler will in turn @code{THROW} an exception
which will be caught by the appropriate Modula-2 handler.  However the
action of throwing an exception from within a signal handler is
implementation defined (according to the C++ documentation).  For
example on the x86_64 architecture this works whereas on the i686
architecture it does not.  Therefore to ensure portability it is
recommended to use @samp{-fsoft-check-all}.

@node Extensions, Type compatibility, Exceptions, Using
@section GNU Modula-2 language extensions

This section introduces the GNU Modula-2 language extensions.
The GNU Modula-2 compiler allows abstract data types to be any type,
not just restricted to a pointer type providing the
@samp{-fextended-opaque} option is supplied
@xref{Compiler options, , ,gm2}.

Declarations can be made in any order, whether they are
types, constants, procedures, nested modules or variables.
@c (see @xref{Passes, , ,}.)

GNU Modula-2 also allows programmers to interface to @code{C} and
assembly language.

GNU Modula-2 provides support for the special tokens @code{__LINE__},
@code{__FILE__}, @code{__FUNCTION__} and @code{__DATE__}. Support for
these tokens will occur even if the @samp{-fcpp} option is not
supplied. A table of these identifiers and their data type and values
is given below:

@example
Scope       GNU Modula-2 token      Data type and example value

anywhere    __LINE__                Constant Literal compatible
                                    with CARDINAL, INTEGER and WORD.
                                    Example 1234

anywhere    __FILE__                Constant string compatible
                                    with parameter ARRAY OF CHAR or
                                    an ARRAY whose SIZE is >= string
                                    length. Example
                                    "hello.mod"

procedure   __FUNCTION__            Constant string compatible
                                    with parameter ARRAY OF CHAR or
                                    an ARRAY whose SIZE is >= string
                                    length. Example
                                    "calc"

module      __FUNCTION__            Example
                                    "module hello initialization"

anywhere    __DATE__                Constant string compatible
                                    with parameter ARRAY OF CHAR or
                                    an ARRAY whose SIZE is >= string
                                    length. Example
                                    "Thu Apr 29 10:07:16 BST 2004"

anywhere   __COLUMN__               Gives a contant literal number
                                    determining the column of the
                                    first token on the line.

@end example

The preprocessor @samp{cpp} can be invoked via the @samp{-fcpp}
command line option. This in turn invokes @samp{cpp} with the
following arguments @samp{-traditional -lang-asm}.  These options
preserve comments and all quotations.  @samp{gm2} treats a @samp{#}
character in the first column as a preprocessor directive.

For example here is a module which calls @code{FatalError}
via the macro @code{ERROR}.

@example
MODULE cpp ;

FROM SYSTEM IMPORT ADR, SIZE ;
FROM libc IMPORT exit, printf, malloc ;

PROCEDURE FatalError (a, file: ARRAY OF CHAR;
                         line: CARDINAL;
                         func: ARRAY OF CHAR) ;
BEGIN
   printf("%s:%d:fatal error, %s, in %s\n",
           ADR(file), line, ADR(a), ADR(func)) ;
   exit(1)
END FatalError ;

#define ERROR(X)  FatalError(X, __FILE__, __LINE__, __FUNCTION__)

VAR
   pc: POINTER TO CARDINAL;
BEGIN
   pc := malloc(SIZE(CARDINAL)) ;
   IF pc=NIL
   THEN
      ERROR('out of memory')
   END
END cpp.
@end example

@subsection Optional procedure parameter

GNU Modula-2 allows the last parameter to a procedure or function
parameter to be optional. For example in the ISO library
@file{COROUTINES.def} the procedure @code{NEWCOROUTINE} is defined as
having an optional fifth argument (@code{initProtection}) which, if
absent, is automatically replaced by @code{NIL}.

@example
@findex NEWCOROUTINE
PROCEDURE NEWCOROUTINE (procBody: PROC; workspace: SYSTEM.ADDRESS;
                        size: CARDINAL; VAR cr: COROUTINE;
                        [initProtection: PROTECTION = NIL]);

  (* Creates a new coroutine whose body is given by procBody,
     and returns the identity of the coroutine in cr.
     workspace is a pointer to the work space allocated to
     the coroutine; size specifies the size of this workspace
     in terms of SYSTEM.LOC.

     The optional fifth argument may contain a single parameter
     which specifies the initial protection level of the coroutine.
  *)
@end example

The implementation module @file{COROUTINES.mod} implements this
procedure using the following syntax:

@example
PROCEDURE NEWCOROUTINE (procBody: PROC; workspace: SYSTEM.ADDRESS;
                        size: CARDINAL; VAR cr: COROUTINE;
                        [initProtection: PROTECTION]);
BEGIN
   
END NEWCOROUTINE ;
@end example

Note that it is illegal for this declaration to contain an initialiser
value for @code{initProtection}. However it is necessary to surround
this parameter with the brackets @code{[} and @code{]}. This serves to
remind the programmer that the last parameter was declared as optional
in the definition module.

Local procedures can be declared to have an optional final parameter
in which case the initializer is mandatory in the implementation or
program module.

GNU Modula-2 also provides additional fixed sized data types which
are all exported from the @code{SYSTEM} module.
@xref{The PIM system module, , ,gm2}.
@xref{The ISO system module, , ,gm2}.

@node Type compatibility, Unbounded by reference, Extensions, Using
@section Type compatibility

This section discuss the issues surrounding assignment, expression
and parameter compatibility, their effect of the additional
fixed sized datatypes and also their effect of runtime checking.
The data types supported by the compiler are:

@example
GNU Modula-2              scope      switches
=============================================
INTEGER                   pervasive
LONGINT                   pervasive
SHORTINT                  pervasive
CARDINAL                  pervasive
LONGCARD                  pervasive
SHORTCARD                 pervasive
BOOLEAN                   pervasive
REAL                      pervasive
LONGREAL                  pervasive
SHORTREAL                 pervasive
CHAR                      pervasive
SHORTCOMPLEX              pervasive
COMPLEX                   pervasive
LONGCOMPLEX               pervasive

BITSET                    SYSTEM
LOC                       SYSTEM     -fiso
BYTE                      SYSTEM
WORD                      SYSTEM
ADDRESS                   SYSTEM

The following extensions are supported for
most architectures (please check SYSTEM.def).
=============================================
INTEGER8                  SYSTEM
INTEGER16                 SYSTEM
INTEGER32                 SYSTEM
INTEGER64                 SYSTEM
CARDINAL8                 SYSTEM
CARDINAL16                SYSTEM
CARDINAL32                SYSTEM
CARDINAL64                SYSTEM
BITSET8                   SYSTEM
BITSET16                  SYSTEM
BITSET32                  SYSTEM
WORD16                    SYSTEM
WORD32                    SYSTEM
WORD64                    SYSTEM
REAL32                    SYSTEM
REAL64                    SYSTEM
REAL96                    SYSTEM
REAL128                   SYSTEM
COMPLEX32                 SYSTEM
COMPLEX64                 SYSTEM
COMPLEX96                 SYSTEM
COMPLEX128                SYSTEM
@end example

The compiler categorises compatibility between all these types
into three components: assignment, parameter and expression.

@subsection Assignment compatibility

This section discusses the assignment issues surrounding assignment
compatibility of fundamental types.  Obviously compatibility exists
between the same sized types.  Same type family of different sizes are
also compatible as long as the @code{MAX(}type@code{)} and
@code{MIN(}type@code{)} is known.  So for example this includes the
@code{INTEGER} family, @code{CARDINAL} family and the @code{REAL}
family.  The reason for this is that when the assignment is performed
the compiler will check to see that the expression (on the right of
the @code{:=}) lies within the range of the designator type (on the
left hand side of the @code{:=}).  Thus these ordinal types can be
assignment compatible.  However it does mean that @code{WORD32} is not
compatible with @code{WORD16} as @code{WORD32} does not have a minimum
or maximum value and therefore cannot be checked.  The compiler does
not know which of the two bytes from @code{WORD32} should be copied
into @code{WORD16} and which two should be ignored.  Currently the
types @code{BITSET8}, @code{BITSET16} and @code{BITSET32} are
assignment incompatible.  However this restriction maybe lifted when
further runtime checking is achieved.

Modula-2 does allow @code{INTEGER} to be assignment compatible with
@code{WORD} as they are the same size.  Likewise GNU Modula-2 allows
@code{INTEGER16} to be compatible with @code{WORD16} and the same for
the other fixed sized types and their sized equivalent in either
@code{WORD}n, @code{BYTE} or @code{LOC} types.  However it prohibits
assignment between @code{WORD} and @code{WORD32} even though on many
systems these sizes will be the same.  The reasoning behind this rule
is that the extended fixed sized types are meant to be used by
applications requiring fixed sized data types and it is more portable
to forbid the bluring of the boundaries between fixed sized and
machine dependant sized types.

Intemediate code runtime checking is always generated by the front
end.  However this intemediate code is only translated into actual
code if the appropriate command line switches are specified.  This
allows the compiler to perform limited range checking at compile time.
In the future it will allow the extensive GCC optimisations to
propagate constant values through to the range checks which if they
are found to exceed the type range will result in a compile time
error message.

@subsection Expression compatibility

According to the various Modula-2 standards @code{INTEGER} and
@code{CARDINAL} types are not expression compatible
(@uref{http://freepages.modula2.org/report4/modula-2.html} and ISO
Modula-2).  This is rule is also extended across the fixed sized
data types.

@subsection Parameter compatibility

Parameter compatibility is divided into two areas, pass by value and
pass by reference (@code{VAR}).  In the case of pass by value the
rules are exactly the same as assignment.  However in the second case,
pass by reference, the actual parameter and formal parameter must be
the same size and family.  Furthermore @code{INTEGER} and
@code{CARDINAL}s are not treated as compatible in the pass by
reference case.

The types @code{BYTE}, @code{LOC} and @code{WORD} and sized
their derivitives are assignment and parameter compatible with any
data type of the same size.

@node Unbounded by reference, Building a shared library, Type compatibility, Using
@section Unbounded by reference

This section documents a GNU Modula-2 compiler switch which implements
a language optimisation surrounding the implementation of unbounded
arrays.  In GNU Modula-2 the unbounded array is implemented by
utilising an internal structure @code{struct @{dataType *address,
unsigned int high@}}.  So given the Modula-2 procedure declaration:

@example
PROCEDURE foo (VAR a: ARRAY OF dataType) ;
BEGIN
   IF a[2]= (* etc *)
END foo ;
@end example

it is translated into GCC @code{tree}s, which can be represented
in their C form thus:

@example
void foo (struct @{dataType *address, unsigned int high@} a)
@{
   if (a.address[2] == /* etc */
@}
@end example

Whereas if the procedure @code{foo} was declared as:

@example
PROCEDURE foo (a: ARRAY OF dataType) ;
BEGIN
   IF a[2]= (* etc *)
END foo ;
@end example

then it is implemented by being translated into the following
GCC @code{tree}s, which can be represented in their C form thus:

@example
void foo (struct @{dataType *address, unsigned int high@} a)
@{
   dataType *copyContents = (dataType *)alloca (a.high+1);
   memcpy(copyContents, a.address, a.high+1);
   a.address = copyContents;

   if (a.address[2] == /* etc */
@}
@end example

This implementation works, but it makes a copy of each non VAR
unbounded array when a procedure is entered.  If the unbounded array
is not changed during procedure @code{foo} then this implementation
will be very inefficient.  In effect Modula-2 lacks the @code{REF}
keyword of Ada.  Consequently the programmer maybe tempted to
sacrifice semantic clarity for greater efficiency by declaring the
parameter using the @code{VAR} keyword in place of @code{REF}.

The @code{-funbounded-by-reference} switch instructs the compiler to
check and see if the programmer is modifying the content of any
unbounded array.  If it is modified then a copy will be made upon
entry into the procedure.  Conversely if the content is only read and
never modified then this non @code{VAR} unbounded array is a candidate
for being passed by reference.  It is only a candidate as it is still
possible that passing this parameter by reference could alter the
meaning of the source code.  For example consider the following case:

@example
PROCEDURE StrConCat (VAR a: ARRAY OF CHAR; b, c: ARRAY OF CHAR) ;
BEGIN
   (* code which performs string a := b + c *)
END StrConCat ;

PROCEDURE foo ;
VAR
   a: ARRAY [0..3] OF CHAR ;
BEGIN
   a := 'q' ;
   StrConCat(a, a, a)
END foo ;
@end example

In the code above we see that the same parameter, @code{a}, is being
passed three times to @code{StrConCat}.  Clearly even though parameters
@code{b} and @code{c} are never modified it would be incorrect to
implement them as pass by reference.  Therefore the compiler checks to
see if any non @code{VAR} parameter is type compatible with any
@code{VAR} parameter and if so it generates runtime procedure entry
checks to determine whether the contents of parameters @code{b} or
@code{c} matches the contents of @code{a}.  If a match is detected
then a copy is made and the @code{address} in the unbounded
@code{struct}ure is modified.

The compiler will check the address range of each candidate against
the address range of any @code{VAR} parameter, providing they are type
compatible.  For example consider:

@example
PROCEDURE foo (a: ARRAY OF BYTE; VAR f: REAL) ;
BEGIN
   f := 3.14 ;
   IF a[0]=BYTE(0)
   THEN
      (* etc *)
   END
END foo ;

PROCEDURE bar ;
BEGIN
   r := 2.0 ;
   foo(r, r)
END bar ;
@end example

Here we see that although parameter, @code{a}, is a candidate for the
passing by reference, it would be incorrect to use this
transformation.  Thus the compiler detects that parameters, @code{a}
and @code{f} are type compatible and will produce runtime checking
code to test whether the address range of their respective contents
intersect.

@node Building a shared library, Interface for Python, Unbounded by reference, Using

@section Building a shared library

This section describes building a tiny shared library implemented
entirely in Modula-2.  Suppose a project consists of two definition
modules and two implementation modules and a program module
@file{a.def}, @file{a.mod}, @file{b.def}, @file{b.mod} and @file{c.mod}.
The first step is to compile the modules using position independent code.
This can be achieved by the following three commands:

@example
gm2 -fiso -g -c -fPIC a.mod
gm2 -fiso -g -c -fPIC b.mod
gm2 -fiso -g -c -fPIC c.mod
@end example

The second step is to perform the link.  In a simple project such as this
you can use the single command:

@example
gm2 -fiso -shared -fshared -fPIC -g c.mod -o c.so
@end example

At this point the shared library @file{c.so} will have been created.
All procedures which are exported from the definition modules are
also visible to the user of the shared library.

The @code{BEGIN} @code{END} code at module scope in @file{a.mod},
@file{b.mod}, @file{c.mod} and all dependent library modules will be
initialized when the shared library is loaded.  Likewise the
@code{FINISH} @code{END} code at all module scopes is executed when
the library is unloaded.  Both the initialization and termination is
implemented transparently using the GNU/Linux mechanism:

@example
void __attribute__ ((constructor)) initcode (void);
void __attribute__ ((destructor)) fincode (void);
@end example

The linking command above utilizes a number of subcomponents which
determine the runtime initialization order, create the C++ initialization
and finalization function and links all required modules together.
You can inspect and modify the initialization and finalization order
by using the following commands:

@example
gm2 -c -fmakelist -fiso -fPIC -g c.mod
@end example

The command above will create a file @file{c.lst} which is a plain ascii
file which contains the modules in initialization order.  The @code{#}
is a comment which continues to the next newline.  It is worth noting that
the first five or so modules which are listed before the commented lines
are the critical runtime modules which have a default order.  You can
override these using the command line option @code{-fruntime-modules=}.
However you should only do this if you are building an application for an
embedded system or your own set of Modula-2 low level libraries.

You can modify the order of the modules in this file, although it is wise
to leave the initial five modules alone.  It is much more useful to order
your own modules which will be near the end of the file.  Once you are happy
with the order you can conclude the link with the command:

@example
gm2 -fuselist -fiso -fPIC -g c.mod -o c.so
@end example

which creates @file{c.so} and @file{c_m2.cpp}.  The initialization and
finalization code is contained within @file{c_m2.cpp} which is
compiled and linked with all the modules required to satisfy all the
program module @file{c.mod} dependencies.

@node Interface for Python, Producing a Python module, Building a shared library, Using
@section How to produce swig interface files

This section describes how your Modula-2 implementation modules can be
called from Python (and other scripting languages such as TCL and
Perl).  GNU Modula-2 can be instructed to create a swig interface when
it is compiling an implementation module.  Swig then uses the
interface file to generate all the necessary wrapping to that the
desired scripting language may access your implementation module.

Here is an example of how you might call upon the services of the
Modula-2 library module @code{NumberIO} from Python.
This example can be found in the directory
@file{gm2/examples/swig/full-strlib} and can be run using the commands:

@example
$ cd gcc-@value{version-GCC}/gcc/gm2/examples/swig/full-strlib
$ make numberio
@end example

If you wanted to do this step by step without the @file{Makefile} then
firstly you should compile the @code{NumberIO} module as a shared
library.  This can be achieved by using the following commands:

@example
$ cd gcc-@value{version-GCC}/gcc/gm2/examples/swig/full-strlib
$ gm2 -fshared -I. -c -fPIC -g -fswig -I../../../gm2-libs \
    ../../../gm2-libs/NumberIO.mod
@end example

The example assumes that the source code for @file{NumberIO.mod} can
be found in directory @file{../../../gm2-libs}.  The first command
produces two files: @file{NumberIO.i} and @file{NumberIO.o}.  The file
@file{NumberIO.o} is a position independant code object file whereas
the file @file{NumberIO.i} is a swig interface file and contains a
swig interpretation of the @file{NumberIO.def}.  GNU Modula-2 uses the
same mechanism for handling exceptions as GNU C++.  The file
@file{NumberIO.i} contains exception handling information therefore we
need to ask @code{swig} to generate C++ wrappers for
@file{NumberIO.mod}.  This is achieved by:

@example
$ swig -c++ -python NumberIO.i
$ gcc -c -fPIC NumberIO_wrap.cxx -I/usr/include/python2.4
@end example

The swig command line generates the necessary Python and C++ interface
files using the interface file.  The C++ interface file is also
compiled into position independant code.  Finally the module
@code{NumberIO} is linked with all its dependants and
@file{NumberIO_wrap.o}.

@example
$ gm2 -shared -fshared -fPIC -g \
     ../../../gm2-libs/NumberIO.mod NumberIO_wrap.o -o _NumberIO.so
@end example

Now it is possible to run the following Python script
(called @file{testnum.py}):

@example
import NumberIO

print "1234 x 2 =", NumberIO.NumberIO_StrToInt("1234")*2
@end example

like this:

@example
$ python testnum.py
1234 x 2 = 2468
@end example

@subsection Limitations of automatic generated of Swig files

This section discusses the limitations of automatically generating
swig files.  From the previous example we see that the module
@code{NumberIO} had a swig interface file @file{NumberIO.i}
automatically generated by the compiler.  If we consider three of the
procedure definitions in @file{NumberIO.def} we can see the
success and limitations of the automatic interface generation.

@example
PROCEDURE StrToHex (a: ARRAY OF CHAR; VAR x: CARDINAL) ;
PROCEDURE StrToInt (a: ARRAY OF CHAR; VAR x: INTEGER) ;
PROCEDURE ReadInt (VAR x: CARDINAL) ;
@end example

Below are the swig interface prototypes:

@example
extern void NumberIO_StrToHex (char *_m2_address_a,
                               int _m2_high_a, unsigned int *OUTPUT);
/*  parameters: x is known to be an OUTPUT */
extern void NumberIO_StrToInt (char *_m2_address_a,
                               int _m2_high_a, int *OUTPUT);
/*  parameters: x is guessed to be an OUTPUT */
extern void NumberIO_ReadInt (int *x);
/*  parameters: x is unknown */
@end example

In the case of @code{StrToHex} it can be seen that the compiler
detects that the last parameter is an output.  It explicitly tells
swig this by using the parameter name @code{OUTPUT} and in the
following comment it informs the user that it knows this to be an
output parameter.  In the second procedure @code{StrToInt} it marks
the final parameter as an output, but it tells the user that this is
only a guess.  Finally in @code{ReadInt} it informs the user that
it does not know whether the parameter, @code{x}, is an output, input
or an inout parameter.

The compiler decides whether to mark a parameter as either:
@code{INPUT}, @code{OUTPUT} or @code{INOUT} if it is read before
written or visa versa in the first basic block.  At this point
it will write output that the parameter is known.  If it is not
read or written in the first basic block then subsequent basic blocks
are searched and the result is commented as a guess.  Finally if
no read or write occurs then the parameter is commented as unknown.
However, clearly it is possible to fool this mechanism.  Nevertheless
automatic generation of implementation module into swig interface files
was thought sufficiently useful despite these limitations.

In conclusion it would be wise to check all parameters in any
automatically generated swig interface file.  Furthermore you can
force the automatic mechanism to generate correct interface files by
reading or writing to the @code{VAR} parameter in the first basic
block of a procedure.

@section How to produce a Python module
@node Producing a Python module, Interface to C, Interface for Python, Using

This section descibes how it is possible to produce a Python module
from your Modula-2 code.  There are a number of advantages to this
approach, it ensures your code reaches a wider audience, maybe it is
easier to initialize your application in Python, maybe users of your
code are familiar with Python and can use it to configure your
application.

The examples given here can be found in the source tree
@file{gcc-@var{version}/gcc/gm2/examples/gravity/}.  The example used
here is a pedagogical two dimensional gravity next event simulation.
The Python module needs to have a clear API, this also needs to be
placed in a single definition module.  In the gravity simulation
example this is found in the file:
@file{gcc-@var{version}/gcc/gm2/examples/gravity/twoDsim.def}.
Furthermore the API should only use fundamental pervasive data types
and strings.  Below is @file{twoDsim.def}:

@example
DEFINITION MODULE twoDsim ;

EXPORT UNQUALIFIED gravity, box, poly3, poly5, poly6, mass,
                   fix, circle, pivot, velocity, accel, fps,
                   replayRate, simulateFor, addDebugging ;
(*
   gravity - turn on gravity at: g m^2
*)

PROCEDURE gravity (g: REAL) ;


(*
   box - place a box in the world at (x0,y0),(x0+i,y0+j)
*)

PROCEDURE box (x0, y0, i, j: REAL) : CARDINAL ;


(*
   poly3 - place a triangle in the world at:
           (x0,y0),(x1,y1),(x2,y2)
*)

PROCEDURE poly3 (x0, y0, x1, y1, x2, y2: REAL) : CARDINAL ;


(*
   poly5 - place a pentagon in the world at:
           (x0,y0),(x1,y1),(x2,y2),(x3,y3),(x4,y4)
*)

PROCEDURE poly5 (x0, y0, x1, y1, x2, y2, x3, y3, x4, y4: REAL) : CARDINAL ;


(*
   poly6 - place a hexagon in the world at:
           (x0,y0),(x1,y1),(x2,y2),(x3,y3),(x4,y4),(x5,y5)
*)

PROCEDURE poly6 (x0, y0, x1, y1, x2, y2, x3, y3, x4, y4, x5, y5: REAL) : CARDINAL ;


(*
   mass - specify the mass of an object and return the, id.
*)

PROCEDURE mass (id: CARDINAL; m: REAL) : CARDINAL ;


(*
   fix - fix the object to the world.
*)

PROCEDURE fix (id: CARDINAL) : CARDINAL ;


(*
   circle - adds a circle to the world.  Center
            defined by: x0, y0 radius, r.
*)

PROCEDURE circle (x0, y0, r: REAL) : CARDINAL ;


(*
   pivot - pivot an object at position, (x0,y0).
*)

PROCEDURE pivot (x0, y0: REAL; id1: CARDINAL) : CARDINAL ;


(*
   velocity - give an object, id, a velocity, vx, vy.
*)

PROCEDURE velocity (id: CARDINAL; vx, vy: REAL) : CARDINAL ;


(*
   accel - give an object, id, an acceleration, ax, ay.
*)

PROCEDURE accel (id: CARDINAL; ax, ay: REAL) : CARDINAL ;


(*
   fps - set frames per second.
*)

PROCEDURE fps (f: REAL) ;


(*
   replayRate - set frames per second during replay.
*)

PROCEDURE replayRate (f: REAL) ;


(*
   simulateFor - render for, t, seconds.
*)

PROCEDURE simulateFor (t: REAL) ;


(*
   addDebugging - add a debugging event at time, t, which colours objects,
                  a, and, b, blue.
*)

PROCEDURE addDebugging (t: REAL; a, b: CARDINAL) ;


END twoDsim.
@end example

By using the keyword @code{UNQUALIFIED} we ensure that the
compiler will provide externally accessible functions
@code{gravity}, @code{box}, @code{poly3}, @code{poly5}, @code{poly6},
@code{mass}, @code{fix}, @code{circle}, @code{pivot}, @code{velocity},
@code{accel}, @code{fps}, @code{replayRate}, @code{simulateFor},
@code{addDebugging} rather than name mangled alternatives.
Hence in our Python application we could write:

@example
#!/usr/bin/python

from twoDsim import *

b = box(0.0, 0.0, 1.0, 1.0)
b = fix(b)
c1 = circle(0.7, 0.7, 0.05)
c1 = mass(c1, 0.01)
c2 = circle(0.7, 0.1, 0.05)
c2 = mass(c2, 0.01)
c2 = fix(c2)
gravity(-9.81)
fps(24.0*4.0)
replayRate(24.0)
print "creating frames"
try:
    simulateFor(1.0)
    print "all done"
except:
    print "exception raised"
@end example

which accesses the various functions defined and implemented by the
module @code{twoDsim}.  The Modula-2 source code is compiled via:

@example
$ gm2 -g -fPIC -fiso -c deviceGnuPic.mod
$ gm2 -g -fPIC -fiso -c roots.mod
$ gm2 -g -fPIC -fiso -c -fswig twoDsim.mod
@end example

Notice that the last command both compiled and produced a swig
interface file @file{swig.i}.  We now use @code{swig} and @code{gcc}
to produce and compile the interface wrappers:

@example
$ swig -c++ -python twoDsim.i
$ gcc -c -fPIC twoDsim_wrap.cxx -I/usr/include/python@value{version-python}
@end example

Finally the application is linked into a shared library:

@example
$ gm2 -fiso -fPIC -fshared -shared twoDsim.mod twoDsim_wrap.o -o _twoDsim.so
@end example

The library name must start with a @code{_} to comply with the Python
naming scheme.

@section Interfacing GNU Modula-2 to C
@node Interface to C, Assembly language, Producing a Python module, Using

The GNU Modula-2 compiler tries to use the C calling convention
wherever possible however some parameters have no C equivalent and
thus a language specific method is used.  For example unbounded arrays
are passed as a @code{struct @{void *address, unsigned int high@}} and
the contents of these arrays are copied by callee functions when they
are declared as non @code{VAR} parameters.  The @code{VAR} equivalent
unbounded array parameters need no copy, but still use the
@code{struct} representation.

The recommended method of interfacing GNU Modula-2 to C is by telling
the definition module that the implementation is in the C language.
This is achieved by using the tokens @code{DEFINITION MODULE FOR "C"}.
Here is an example which can be found in the source tree
@file{gcc-@var{version}/gcc/gm2/examples/callingC/libprintf.def}

@example
DEFINITION MODULE FOR "C" libprintf ;

EXPORT UNQUALIFIED printf ;

PROCEDURE printf (a: ARRAY OF CHAR; ...) : [ INTEGER ] ;

END libprintf.
@end example

the @code{UNQUALIFIED} keyword in the definition module informs
GNU Modula-2 not to prefix the module name to exported references
in the object file.

The @code{printf} declaration states that the first parameter
semantically matches @code{ARRAY OF CHAR} but since the module is for
the C language it will be mapped onto @code{char *}. The token
@code{...} indicates a variable number of arguments (varargs) and all
parameters passed here are mapped onto their C equivalents. Arrays and
constant strings are passed as pointers.  Lastly the @code{[ INTEGER ]}
states that the caller can ignore the function return result if desired.

The hello world program can be rewritten as:

@example
MODULE hello ;

FROM libprintf IMPORT printf ;

BEGIN
   printf("hello world\n")
END hello.
@end example

and it can be compiled by:

@samp{gm2 -fmakeall -g -I. hello.mod -lc}

In reality the @samp{-lc} is redundant as libc is always included in the
linking process. It is shown here to emphasize that the C library or
object file containing @code{printf} must be present.

If a procedure function is declared using varargs then some parameter
values are converted.  The table below summarises the default conversions
and default types used.

@example
Actual Parameter       |  Default conversion  |   Type of actual
                       |                      |   value passed
===============================================================
123                    |  none                |   long long int
"hello world"          |  none                |   const char *
a: ARRAY OF CHAR       |  ADR(a)              |   char *
a: ARRAY [0..5] OF CHAR|  ADR(a)              |   char *
3.14                   |  none                |   long double
@end example

If you wish to pass @code{int} values then you should explicitly
convert the constants using one of the conversion mechanisms.
For example:  @code{INTEGER(10)} or @code{VAL(INTEGER, 10)} or
@code{CAST(INTEGER, 10)}.

@node Assembly language, Alignment, Interface to C, Using
@section Interface to assembly language

The interface for GNU Modula-2 to assembly language is almost
identical to GNU C.  The only alterations are that the keywords
@code{asm} and @code{volatile} are in capitals, following the Modula-2
convention.

A simple, but highly non optimal, example is given below. Here we want
to add the two @code{CARDINAL}s @code{foo} and @code{bar} together and
return the result.

@example
PROCEDURE Example (foo, bar: CARDINAL) : CARDINAL ;
VAR
   myout: CARDINAL ;
BEGIN
   ASM VOLATILE ("movl %1,%%eax; addl %2,%%eax; movl %%eax,%0"
      : "=g" (myout)           (* outputs *)
      : "g" (foo), "g" (bar)   (* inputs  *)
      : "eax") ;               (* we trash *)
   RETURN( myout )
END Example ;
@end example

For a full description of this interface we refer the reader to the GNU C manual.

@xref{Extended Asm, ,Extensions to the C Language Family,gcc}.

@node Alignment, Built-ins, Assembly language, Using
@section Data type alignment

GNU Modula-2 allows you to specify alignment for types and variables.
The syntax is similar to GCC and uses the @code{__ATTRIBUTE__}
mechanism.  The ebnf of the alignment production is:

@example
Alignment := [ "__ATTRIBUTE__" "(" "(" ALIGNED "(" ConstExpression ")" ")" ")" ]
           =:
@end example

The @code{Alignment} ebnf statement may be used during contruction of
types, records, record fields, arrays, pointers and variables.  Below
is an example of aligning a type so that the variable @code{bar} is
aligned on a 1024 address.

@example
MODULE align ;

TYPE
   foo = INTEGER __ATTRIBUTE__ ((ALIGNED(1024))) ;

VAR
   z  : INTEGER ;
   bar: foo ;
BEGIN
END align.
@end example

The next example aligns a variable on a 1024 byte boundary.

@example
MODULE align2 ;

VAR
   x  : CHAR ;
   z  : ARRAY [0..255] OF INTEGER __ATTRIBUTE__ ((ALIGNED(1024))) ;
BEGIN
END align2.
@end example

Here the example aligns a pointer on a 1024 byte boundary.

@example
MODULE align4 ;

FROM SYSTEM IMPORT ADR ;
FROM libc IMPORT exit ;

VAR
   x  : CHAR ;
   z  : POINTER TO INTEGER __ATTRIBUTE__ ((ALIGNED(1024))) ;
BEGIN
   IF ADR(z) MOD 1024=0
   THEN
      exit(0)
   ELSE
      exit(1)
   END
END align4.
@end example

In example @code{align5} record field @code{y} is aligned on a 1024
byte boundary.

@example
MODULE align5 ;

FROM SYSTEM IMPORT ADR ;
FROM libc IMPORT exit ;

TYPE
   rec = RECORD
            x: CHAR ;
            y: CHAR  __ATTRIBUTE__ ((ALIGNED(1024))) ;
         END ;
VAR
   r: rec ;
BEGIN
   IF ADR(r.y) MOD 1024=0
   THEN
      exit(0)
   ELSE
      exit(1)
   END
END align5.
@end example

In the example below module @code{align6} declares @code{foo} as an
array of 256 @code{INTEGER}s.  The array @code{foo} is aligned on a
1024 byte boundary.

@example
MODULE align6 ;

FROM SYSTEM IMPORT ADR ;
FROM libc IMPORT exit ;

TYPE
   foo = ARRAY [0..255] OF INTEGER __ATTRIBUTE__ ((ALIGNED(1024))) ;

VAR
   x  : CHAR ;
   z  : foo ;
BEGIN
   IF ADR(z) MOD 1024=0
   THEN
      exit(0)
   ELSE
      exit(1)
   END
END align6.
@end example

@node Built-ins, The PIM system module, Alignment, Using
@section Accessing GNU Modula-2 Built-ins

This section describes the built-in constants and functions defined in
GNU Modula-2.  The following compiler constants can be accessed using
the @code{__ATTRIBUTE__} @code{__BUILTIN__} keywords. These are not
part of the Modula-2 language and they may differ depending upon the
target architecture but they provide a method whereby common
libraries can interface to a different underlying architecture.

The built-in constants are: @code{BITS_PER_UNIT}, @code{BITS_PER_WORD},
@code{BITS_PER_CHAR} and @code{UNITS_PER_WORD}. They are integrated into
GNU Modula-2 by an extension to the @code{ConstFactor} rule:

@example
ConstFactor := ConstQualidentOrSet | Number | ConstString |
               "(" ConstExpression ")" | "NOT" ConstFactor |
               ConstAttribute =:

ConstAttribute := "__ATTRIBUTE__" "__BUILTIN__" "(" "(" Ident ")" ")" =:
@end example

Here is an example taken from the ISO library @code{SYSTEM.def}:

@example
CONST
   BITSPERLOC    = __ATTRIBUTE__ __BUILTIN__ ((BITS_PER_UNIT)) ;
   LOCSPERWORD   = __ATTRIBUTE__ __BUILTIN__ ((UNITS_PER_WORD)) ;
@end example

Built-in functions are transparent to the end user. All built-in
functions are declared in @code{DEFINITION MODULE}s and are imported
as and when required.  Built-in functions are declared in definition
modules by using the @code{__BUILTIN__} keyword. Here is a section of
the ISO library @code{LongMath.def} which demonstrates this feature.

@example
PROCEDURE __BUILTIN__ sqrt (x: LONGREAL): LONGREAL;
  (* Returns the square root of x *)
@end example

This indicates that the function @code{sqrt} will be implemented using
the gcc built-in maths library.  If gcc cannot utilise the built-in
function (for example if the programmer requested the address of
@code{sqrt}) then code is generated to call the alternative function
implemented in the @code{IMPLEMENTATION} @code{MODULE}.

Sometimes a function exported from the @code{DEFINITION} @code{MODULE}
will have a different name from the built-in function within gcc. In
such cases the mapping between the GNU Modula-2 function name and the
gcc name is expressed using the keywords @code{__ATTRIBUTE__}
@code{__BUILTIN__} @code{((Ident))}. For example the function
@code{sqrt} in @code{LongMath.def} maps onto the gcc built-in function
@code{sqrtl} and this is expressed as:

@example
PROCEDURE __ATTRIBUTE__ __BUILTIN__ ((sqrtl)) sqrt
                                    (x: LONGREAL) : LONGREAL;
  (* Returns the positive square root of x *)
@end example

The following module @code{Builtins.def} enumerates the list of
built-in functions which can be accessed in GNU Modula-2. It also
serves to define the parameter and return value for each function:

@include Builtins.texi

Although this module exists and will result in the generation of
in-line code if optimization flags are passed to GNU Modula-2, users
are advised to utilize the same functions from more generic libraries.
The built-in mechanism will be applied to these generic
libraries where appropriate. Note for the mathematical routines to
be in-lined you need to specify the @samp{-ffast-math -O} options.

@node The PIM system module, The ISO system module, Built-ins, Using
@section The PIM system module

@include SYSTEM-pim.texi

The different dialects of Modula-2 PIM-[234] and ISO Modula-2 declare
the function @code{SIZE} in different places.  PIM-[34] and ISO
Modula-2 declare @code{SIZE} as a pervasive function (declared in the
base module).  PIM-2 defined @code{SIZE} in the @code{SYSTEM} module
(as shown above).

GNU Modula-2 allows users to specify the dialect of Modula-2 by using
the @code{-fiso} and @code{-fpim2} command line switches.

@node The ISO system module, , The PIM system module, Using
@section The ISO system module

@include SYSTEM-iso.texi

@node Obtaining, Licence, Using, Top
@chapter Obtaining GNU Modula-2.

@section Warning

This code is still in development.
Nevertheless the compiler is sufficiently stable to support itself on
Debian GNU/Linux x86 systems.  The PIM libraries are complete but the
ISO libraries are still in development.
Patches and development volunteers highly welcome! 
@xref{Contributing, Contributing to GNU Modula-2}.

@section Getting GNU Modula-2

The easiest way to obtain GNU Modula-2 is to install i386, amd64 or
ppc64 Debian GNU/Linux and then add these repository descriptions to
your @file{/etc/apt/sources.list} file.

@example
#
#  GNU Modula-2 repo
#

deb http://floppsie.comp.glam.ac.uk/debian/ lenny main 
deb-src http://floppsie.comp.glam.ac.uk/debian/ lenny main
@end example

Now as root type:

@example
$ apt-get update
$ apt-get install gm2-doc gm2
@end example

As a normal user you can obtain the source code via:

@example
$ apt-get source gm2
@end example

If you are not running Debian GNU/Linux then you can either download
the source tarball and build it manually or checkout the latest
sources using CVS and combine them with the appropriate gcc tarball
and then finally build it manually.

Combined GNU Modula-2 and patched GCC tarballs exist at
@uref{http://floppsie.comp.glam.ac.uk/download/c}.
Search for files which look like @file{gm2+gcc-@var{version}.tar.gz}.
For example you should be able to download the latest version of GNU
Modula-2 and GCC using these commands.

@example
$ wget http://floppsie.comp.glam.ac.uk/download/c/gcc-@value{version-GCC}+gm2-cvs-latest.tar.gz
$ tar zxf gcc-@value{version-GCC}+gm2-cvs-latest.tar.gz
@end example

@section Building GNU Modula-2 from source under GNU/Linux

On a GNU/Linux system you should also be able to build it using these
commands.  The following commands assume your shell is @file{/bin/bash}.
To build GNU Modula-2 type:

@example
$ mkdir -p $HOME/opt
$ mkdir -p build-@value{version-GCC}
$ cd build-@value{version-GCC}
$ ../gcc-4.1.2+gm2-cvs-latest/configure --enable-languages=c,c++,gm2 \
     --disable-multilib --enable-checking=all --prefix=$HOME/opt
$ make "SHELL=/bin/bash"
@end example

To install GNU Modula-2, after a successful build, type:

@example
$ make "SHELL=/bin/bash" install
$ cd ..
@end example

Now you should be able to perform:

@example
$ export PATH=$HOME/opt/bin:$PATH
$ cd gcc-@value{version-GCC}/gcc/gm2/examples/hello
$ make
@end example

which will create an @file{a.out} for the infamous hello world
example.

@section Development sources via CVS

Development sources can be downloaded via CVS but they must be grafted
carefully onto an existing GCC release.  The notes in this section
document how this is achieved, however a prepared CVS and GCC release
is available here
@uref{http://floppsie.comp.glam.ac.uk/download/c/gcc-@value{version-GCC}+gm2-cvs-latest.tar.gz}
and it is created each night.

If you want to obtain the latest sources via CVS then type the
following:

@example
$ cvs -z3 -d:pserver:anoncvs@@cvs.sv.gnu.org:/sources/gm2 co gm2
@end example

This will checkout a copy of GNU Modula-2 into one subdirectory,
@file{gm2}.  This version of GNU Modula-2 needs to be placed inside
the GCC source tree in the position gcc-@value{version-GCC}/gcc before
GNU Modula-2 can be built. Please check the GNU Modula-2 homepage
@uref{http://www.nongnu.org/gm2} for details about which GCC releases
are supported by GNU Modula-2.

Once you have downloaded the correct GCC release from
@uref{http://gcc.gnu.org} or a mirror site you should unpack the GCC
archive.  Assuming that both the @file{gcc-@value{version-GCC}} and
@file{gm2} directories are at the same level, you can graft @file{gm2}
onto @file{gcc-@value{version-GCC}} by:

@example   
$ mv gm2 gcc-@value{version-GCC}/gcc
@end example

If the directory
@samp{gcc-@value{version-GCC}/gcc/gm2/patches/gcc/@value{version-GCC}}
exists then the patch files inside that directory can be applied to the
@samp{gcc-@value{version-GCC}} tree. This is done via:

@example
$ cd gcc-@value{version-GCC}
$ if [ -d gcc/gm2/patches/gcc/@value{version-GCC} ] ; then
     for i in gcc/gm2/patches/gcc/@value{version-GCC}/* ; do
        if [ -f $i ] ; then
           patch -p1 < $i
        fi
     done
  fi
@end example

Note that if you download a tarball from
@url{http://floppsie.comp.glam.ac.uk} then any patching will have
already been applied.  @xref{Obtaining, , ,}.

@section Stress testing GM2

Currently there are two automated methods to test GNU Modula-2.
The first method is @samp{make gm2.paranoid} in which @code{gm2}
builds itself and finally the test runs both parent and child
generations of the compiler and compares the output. Be warned
that this test can take some time to execute.
This test is invoked by:

@example
$ cd host-build/gcc ; make gm2.paranoid
@end example

The second method used to test GNU Modula-2 is to run the regression
test suite.  The GNU Modula-2 regression test suite is available for
download.  To install and run the GNU Modula-2 regression suite you
need to have installed the @file{dejagnu} and @file{expect}
packages. Note that you need to ensure that you have at least the
following releases of dejagnu components:

@example
$ runtest --version

Expect version is	5.42.1
Tcl version is		8.4
Framework version is	1.4.4
@end example

otherwise some of the tests may not run.

If you have downloaded the combined GCC and GNU Modula-2 tarball
@uref{http://floppsie.comp.glam.ac.uk/download/c/gcc-@value{version-GCC}+gm2-cvs-latest.tar.gz}
then this will also contain the GNU Modula-2 testsuite.  In this case
you can skip over the following @file{cvs} and @file{tar} commands.

However if you have downloaded GNU Modula-2 using CVS then you will
also need to download and position the testsuite.
Assuming that the root of the GCC source tree is in the current
working directory you can use the following commands to install
the test suite:

@example
$ cvs -z3 -d:pserver:anoncvs@@cvs.sv.gnu.org:/sources/gm2 co testsuite
$ tar cf - testsuite | ( cd gcc-@var{version}/gcc ; tar xf - )
@end example

Do not simply move the directory @file{testsuite} into
@file{gcc-@var{version}/gcc} as the GNU Modula-2 regression
tests have to be overlaid on top of the gcc testsuite.

Thereafter you can run the GNU Modula-2 testsuite by:

@example
$ cd host-build/gcc
$ make check-gm2
@end example

Depending on the speed of your computer these tests may take a while
to complete.

@section Building GNU Modula-2 under Cygwin

GNU Modula-2 now builds under Cygwin.  The Cygwin version used was gcc
version 3.4.4, gdc 0.12 using dmd 0.125.  The following set of
commands were used to build GNU Modula-2.

@example
$ mkdir build
$ cd build
$ ../gcc-4.1.2+gm2-cvs-latest/configure --prefix=/gm2/opt \
  --disable-multilib --enable-checking=all \
  --enable-languages=c,c++,gm2
$ make
@end example

GNU Modula-2 can be installed by:

@example
$ make install
@end example

You now need to modify your path to include @file{gm2}.  This is done
by:

@example
$ export PATH=/gm2/opt/bin:$PATH
@end example

and now you can try out the @code{hello world} example:

@example
$ cd ../gcc-@value{version-GCC}/gcc/gm2/examples/hello
$ make
$ ./a.exe
@end example

@section Moving the installation of GNU Modula-2 to another directory

This section documents how you can configure GNU Modula-2 to install in
one directory and at a later time move the installation to another
completely different directory.  The example assumes the user has a
bourne shell.

Let us assume that the build was configured as such:

@example
$ mkdir build
$ cd build
$ ../gcc-@value{version-GCC}+gm2-cvs-latest/configure \
   --prefix=$HOME/private \
   --enable-languages=c,c++,gm2  --enable-checking \
   --disable-multilib
@end example

in this example we see that the installation directory would normally
be @file{$HOME/private}.  This is accomplished by the following
commands:

@example
$ make
$ make install
@end example

Now, assuming we have correct privileges, we may move the entire
contents of @file{$HOME/private} to @file{/usr/local/public}:

@example
$ mv $HOME/private /usr/local/public
@end example

The new compiler and libraries can be referenced by modifying
our @code{PATH} environment variable:

@example
$ PATH=/usr/local/public/bin:$PATH
$ export PATH
$ GM2_ROOT=/usr/local/public
$ export GM2_ROOT
@end example

Finally we can rebuild the @code{hello world} example found
in @file{../gcc-@value{version-GCC}/gcc/gm2/examples/hello} by:

@example
$ cd ../gcc-@value{version-GCC}/gcc/gm2/examples/hello
$ make
$ ./a.out
@end example

@section Building GNU Modula-2 under Mac OSX

The easiest way to build GNU Modula-2 under Mac OSX is to use
@samp{macports}.  At the time of writing GNU Modula-2 is not an
official mac port, however you can build it locally and produce your
own testing release quite easily.

Firstly you must install @samp{macports} @url{http://www.macports.org/install.php}.
Secondly you need to modify your @samp{macports} configuration file
@file{/opt//local/etc/macports/sources.conf} so that it allows users to
maintain private ports.  This requires that you add the line:

@example
file:///Users/@samp{yourusername}/MacPorts/ports
@end example

which allows you to keep your own @samp{macports} under
@samp{$HOME/MacPorts/ports}.  Now download the GNU Modula-2
Portfile and build the port index.

@example
$ mkdir -p $HOME/MacPorts/ports/lang/gm2-latest
$ cd $HOME/MacPorts/ports/lang/gm2-latest
$ curl http://floppsie.comp.glam.ac.uk/download/c/patches/gcc/4.1.2/Portfile \
  -o Portfile
$ cd $HOME/MacPorts/port
$ portindex
Creating software index in /Users/@samp{yourusername}/MacPorts/ports
Adding port lang/gm2-latest

Total number of ports parsed:   1
Ports successfully parsed:      1
Ports failed:                   0
@end example

@example
$ sudo port clean --all gm2-latest
--->  Cleaning gm2-latest
$ sudo port build gm2-latest
Password:
--->  Fetching gm2-latest
--->  Attempting to fetch gcc-core-4.1.2.tar.bz2 from ftp://ftp.lip6.fr/pub/gnu//gcc/gcc-4.1.2
--->  Attempting to fetch gcc-g++-4.1.2.tar.bz2 from ftp://ftp.lip6.fr/pub/gnu//gcc/gcc-4.1.2
--->  Attempting to fetch gm2-cvs-latest.tar.bz2 from ftp://ftp.lip6.fr/pub/gnu//gcc/gcc-4.1.2
--->  Attempting to fetch gm2-cvs-latest.tar.bz2 from http://www.mirrorservice.org/sites/ftp.gnu.org/gnu//gcc/gcc-4.1.2
--->  Attempting to fetch gm2-cvs-latest.tar.bz2 from ftp://ftp.gwdg.de/pub/linux/gcc/releases/gcc-4.1.2/
--->  Attempting to fetch gm2-cvs-latest.tar.bz2 from ftp://ftp.nluug.nl/mirror/languages/gcc/releases/gcc-4.1.2/
--->  Attempting to fetch gm2-cvs-latest.tar.bz2 from http://arn.se.distfiles.macports.org/gm2-latest
--->  Attempting to fetch gm2-cvs-latest.tar.bz2 from ftp://ftp.funet.fi/pub/mirrors/sources.redhat.com/pub/gcc/releases/gcc-4.1.2/
--->  Attempting to fetch gm2-cvs-latest.tar.bz2 from ftp://ftp.funet.fi/pub/gnu/prep//gcc/gcc-4.1.2
--->  Attempting to fetch gm2-cvs-latest.tar.bz2 from http://mirrors.kernel.org/gnu//gcc/gcc-4.1.2
--->  Attempting to fetch gm2-cvs-latest.tar.bz2 from ftp://ftp.chg.ru/pub/gnu//gcc/gcc-4.1.2
--->  Attempting to fetch gm2-cvs-latest.tar.bz2 from http://mirrors.ibiblio.org/pub/mirrors/gnu/ftp/gnu//gcc/gcc-4.1.2
--->  Attempting to fetch gm2-cvs-latest.tar.bz2 from http://distfiles.macports.org/gm2-latest
--->  Attempting to fetch gm2-cvs-latest.tar.bz2 from ftp://gcc.gnu.org/pub/gcc/releases/gcc-4.1.2/
--->  Attempting to fetch gm2-cvs-latest.tar.bz2 from ftp://ftp.dti.ad.jp/pub/GNU//gcc/gcc-4.1.2
--->  Attempting to fetch gm2-cvs-latest.tar.bz2 from ftp://ftp.unicamp.br/pub/gnu//gcc/gcc-4.1.2
--->  Attempting to fetch gm2-cvs-latest.tar.bz2 from http://mirror.aarnet.edu.au/pub/GNU//gcc/gcc-4.1.2
--->  Attempting to fetch gm2-cvs-latest.tar.bz2 from http://aarnet.au.distfiles.macports.org/pub/macports/mpdistfiles/gm2-latest
--->  Attempting to fetch gm2-cvs-latest.tar.bz2 from http://mirror.pacific.net.au/pub1/gnu/gnu//gcc/gcc-4.1.2
--->  Attempting to fetch gm2-cvs-latest.tar.bz2 from http://mirror.internode.on.net/pub/gnu//gcc/gcc-4.1.2
--->  Attempting to fetch gm2-cvs-latest.tar.bz2 from http://floppsie.comp.glam.ac.uk/download/c
--->  Verifying checksum(s) for gm2-latest
--->  Extracting gm2-latest
--->  Applying patches to gm2-latest
--->  Configuring gm2-latest
--->  Building gm2-latest
@end example

Now you can produce your own release of GNU Modula-2 via:

@example
$ sudo port dmg gm2-latest
--->  Staging gm2-latest into destroot
--->  Creating pkg for gm2-latest-4.1.2
--->  Creating disk image for gm2-latest-4.1.2
@end example

You can run the regression testsuite by:

@example
$ sudo port install dejagnu
$ cd /opt/local/var/macports/build/_opt_local_var_macports_sources_rsync.macports.org_release_ports_lang_gcc41/work/build/gcc
$ sudo make check-gm2
$ sudo make gm2.paranoid
@end example

Here is a simple script which enables you to download, build and test
the latest GNU Modula-2 cvs snapshot:

@example
#!/bin/bash

cd $HOME/MacPorts/ports/lang/gm2-latest
curl http://floppsie.comp.glam.ac.uk/download/c/patches/gcc/4.1.2/Portfile -o Portfile
cd $HOME/MacPorts/ports
portindex
cd $HOME
sudo port clean --all gm2-latest
sudo port build gm2-latest
cd /opt/local/var/macports/build/_opt_local_var_macports_sources_rsync.macports.org_release_ports_lang_gcc41/work/build/gcc
sudo make gm2.paranoid
sudo make check-gm2
@end example

@section Building GNU Modula-2 under FreeBSD

[This section is out of date and has not been verified against
gcc-@value{version-GCC} and GNU Modula-2 release
gm2-@value{version-GM2}].

When building GNU Modula-2 under FreeBSD, there are essentially three
issues that need to be addressed.

The first, is the system shell, @file{/bin/sh}. GNU Modula-2's build
script uses some @file{bash} constructs that are not understood by
@file{sh}.  Therefore @file{bash} must be installed and this can be
obtained from the ports package collection (ports:shells/bash).

The second, is the compiler used to bootstrap GNU Modula-2. On
FreeBSD4.x the system compiler is from the 2.95.x generation, and
should work without problems.  On 5-RELEASE and 6-CURRENT, the system
compiler is from the 3.4.x generation or greater, and it is known to
create a faulty GNU Modula-2 compiler. Therefore you will need to
install an earlier gcc on your machine. Known to work are gcc 3.2.3
(ports:lang/gcc32), gcc 3.3.4, 3.3.5 and 3.3.6 (ports:lang/gcc33).

Finally, @file{gmake} is required.

It is recommended that the same options are used to configure GNU
Modula-2 as those suggested in the ports collection.  A number of
options are not relevant for building GNU Modula-2 and these can be
safely omitted. The only two which apply directly to GNU Modula-2's
build process are @code{--with-system-zlib} and @code{--disable-nls}.

The example below assumes that @code{gcc-3.2.3} is installed (from the
ports collection) and the compiler is called @file{gcc32}. The example
assumes that the bash shell has been installed (as described above).

@example
  mkdir host-build
  cd host-build
  env CONFIG_SHELL=/usr/local/bin/bash CC=gcc32 ../gcc-@var{version}/configure
      --with-system-zlib --disable-nls --enable-languages=c,c++,gm2
  gmake
@end example

If you choose to install the generated compiler, you are urged to make
use of the name rewriting options of configure
(@code{--program-prefix} and @code{--program-suffix} work fine), and
to avoid possible conflicts with a port that installs it's own gcc,
you may also want to add @code{--host}. Here is the author of this
section's full configure line:

@example
  env CONFIG_SHELL=/usr/local/bin/bash CC=gcc32 ../gcc-@var{version}/configure
      --with-system-zlib --disable-nls --enable-languages=c,c++,gm2
      --program-prefix=m2 --host=i386-gm2bld-freebsd5.3
@end example

@node Licence, GNU Project, Obtaining, Top
@section Licence of GNU Modula-2

@include gpl.texi

@node GNU Project, Contributing, Licence, Top

@include gnu.texi

@node Contributing, Internals, GNU Project, Top
@section Contributing to GNU Modula-2

Please do. But also please read the GNU Emacs info under

@example
* Standards: (standards).       GNU coding standards.
* Intellectual Property::       Keeping Free Software Free
* Reading Non-Free Code::       Referring to Proprietary Programs
* Contributions::               Accepting Contributions
@end example

You might consider joining the GM2 Mailing list available via
a web brouser at

@uref{http://lists.nongnu.org/mailman/listinfo/gm2}
available via email: @uref{mail:gm2-subscribe@@nongnu.org} before you
start coding.

Many thanks and enjoy your coding!

@node Internals, EBNF, Contributing, Top

This section is still being written.
@c @include gm2-internals.texi

@node EBNF, Libraries, Internals, Top
@chapter EBNF of GNU Modula-2

This chapter contains the EBNF of GNU Modula-2. This grammer currently
supports both PIM and ISO dialects.  The rules here are automatically
extracted from the grammer files in GNU Modula-2 and serve to document
the syntax of the extensions described earlier and how they fit in
with the base language.

Note that the first six productions are built into the lexical analysis
phase.

@include gm2-ebnf.texi

@node Libraries, Function Index, EBNF, Top
@chapter PIM and ISO library definitions

This chapter contains M2F, ULM, PIM and ISO libraries. The ISO
libraries are currently work in progress, many are complete but
probably contain many bugs.  The M2F libraries are very mature as the
compiler uses them extensively.  Permission has been kindly granted by
the authors of the ULM libraries to include them with GNU
Modula-2.  These libraries (under the GNU GPL) were written at the
University of Ulm and were originally shipped with the ULM sparc
Modula-2 compiler.

@include gm2-libs.texi

@node Function Index, , Libraries, Top

@c @printindex cp
@printindex fn

@summarycontents
@contents
@bye
