\input texinfo 
@c -*-texinfo-*-

@c

@code{makeinfo}
@code{texinfo-format-buffer}

@c
@c Design notes and documentation about GNU Modula-2
@c
@c
@c part 1 header
@c

@setfilename gm2.info

@include version.texi
@set version-GDB     6.6

@settitle The GNU Modula-2 front end to GCC (gm2-@value{version-GM2})

@c Part 2: Titlepage and Copyright

@c The titlepage segment does not appear in the Info file. 
@titlepage
@sp 10
@comment The title is printed in a large font.
@center @titlefont{The GNU Modula-2 front end to GCC}
@sp 10
@center @titlefont{gm2-@value{version-GM2}}
@c
@page
@setchapternewpage odd
@sp 2
@center Gaius Mulley
@sp 3
@center Last updated @value{version-update}
@sp 10
@c
@center @image{gm2/images/gnu,,1.5in}
@sp 6
@quotation
``And then one day you find ten years have got behind you'', Pink Floyd
@end quotation
@c
@vskip 0pt plus 1filll
Copyright @copyright{} 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
2008, 2009 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with the Front-Cover texts being `A GNU Manual,''
and with the Back-Cover Texts as in (a) below.  A copy of the
license is included in the section entitled `GNU Free Documentation
License.''

(a) The FSF's Back-Cover Text is: `You have freedom to copy and modify
this GNU Manual, like GNU software.  Copies published by the Free
Software Foundation raise funds for GNU development.''
@end titlepage

@c Part 4: `Top' Node and Master Menu

@ifinfo
@node Top, Using, (dir), (dir)
@top Introduction
@end ifinfo

@menu
* Using::            Using GNU Modula-2.
* Obtaining::        Obtaining GNU Modula-2.
* Licence::          Licence of GNU Modula-2.
* GNU Project::      The GNU Project and GNU/Linux.
* Contributing::     Contributing to GNU Modula-2.
* Internals::        GNU Modula-2 internals.
* EBNF::             EBNF of GNU Modula-2
* Libraries::        PIM and ISO library definitions.
* Function Index::   Index for all library functions.
@end menu

@node Using, Obtaining, Top, Top
@chapter Using GNU Modula-2

@menu
* What is GNU Modula-2::  Brief description of GNU Modula-2.
* Why use GNU Modula-2::  Advantages of GNU Modula-2.
* Release map::           Future releases of GNU Modula-2.
* Compiler options::      GNU Modula-2 compiler options.
* Example usage::         Example compile and link.
* Environment variables:: GNU Modula-2 related environment variables.
* Elementary data types:: Data types supported by GNU Modula-2.
* Standard procedures::   Permanently accessible base procedures.
* Dialect::               GNU Modula-2 supported dialects.
* Extensions::            GNU Modula-2 language extensions.
* Type compatibility::    Data type compatibility.
* Unbounded by reference::Explanation of a language optimization.
* Interface for Python::  How to produce swig interface files.
* Interface to C::        Interfacing GNU Modula-2 to C.
* Assembly language::     Interface to assembly language.
* Built-ins::             Accessing GNU Modula-2 Built-ins.
* The PIM system module:: SYSTEM data types and procedures.
* The ISO system module:: SYSTEM data types, procedures and run time.
@end menu

This document contains the user and design issues relevant to the
Modula-2 front end to gcc.  Throughout this document the GNU Modula-2
front end is often referred to as @samp{gm2-@value{version-GM2}} or
@samp{gm2} for short.  This corresponds to GCC version
@value{version-GCC} and GNU Modula-2 version @value{version-GM2}.

@node What is GNU Modula-2, Why use GNU Modula-2, , Using
@section What is GNU Modula-2

GNU Modula-2 is a front end @uref{http://gcc.gnu.org/frontends.html}
for GCC. GCC is a retargetable C compiler which has been ported to a large
number of architectures and operating systems. GNU Modula-2 utilizes the
back end of GCC and replaces the C language front end with a Modula-2
front end. Consequently GNU Modula-2 has been built on i[3456]86 GNU/Linux,
i[3456]86 BSD, Opteron LP64 GNU/Linux and sparc GNU/Linux systems.
It has also been built as a cross compiler for MinGW and StrongARM GNU/Linux.

The GNU Modula-2 compiler is based on the language as defined in
'Programming in Modula-2' 2nd Edition, Springer Verlag, 1982, 1983 by
Niklaus Wirth (PIM2), 'Programming in Modula-2', 3rd Corrected
Edition, Springer Verlag, 1985 (PIM3) and 'Programming in Modula-2',
4th Edition, Springer Verlag, 1988 (PIM4)
@uref{http://freepages.modula2.org/report4/modula-2.html}.  It also
includes ISO M2 features and GNU Modula-2 extensions. Currently GNU
Modula-2 (@value{version-GM2}) implements all PIM dialects of the
language, eventually GNU Modula-2 will be fully compliant with ISO
Modula-2.

There are currently three sets of libraries. The 'Programming in
Modula-2' libraries, the 'University of ULM libraries' and the ISO
libraries. The ISO libraries are still being written, however all
definition modules for the three library sets are contained within
this document.

@node Why use GNU Modula-2, Release map, What is GNU Modula-2, Using
@section Why use GNU Modula-2

This section is not designed to generate a language war, but rather
map out some of the advantages of using GNU Modula-2 rather than
translate Modula-2 sources into another language.

It is expected that the primary purpose of GNU Modula-2 will be to
compile legacy code. Currently there are only a few commercial
Modula-2 compilers being actively maintained. Code which was written
ten or fifteen years ago may still be compiled by older commercial
(possibly unmaintained) compilers. While the 32 bit x86 remains these
compilers presumably can be run in compatibility mode (some compilers
only produced 16 bit code). Time is running out as the computing
industry is switching to 64 microprocessors. While x86 emulation or 16
bit backwards compatibility is always possible it has some serious
drawbacks. In order for the older source to run natively the source
code will either have to be translated into another high level
language or alternatively a Modula-2 compiler which can target these
new generation of microprocessors will have to be acquired. GNU
Modula-2 builds and passes all its regression tests on Debian Pure 64
(LP64 architecture), 64 bit Solaris, 32 bit x86 GNU/Linux (Suse,
Debian, stable and unstable) and 32 bit x86 FreeBSD.

GNU Modula-2 also has the advantage of being closely tied to GCC.  Not
only does this produce excellent code and excellent architectural and
operating system coverage but it also utilises many of the GCC
features. For example GNU Modula-2 can invoke the C preprocessor to
manage conditional compilation; in-lining of @code{SYSTEM} procedures,
intrinsic functions, memory copying routines are also exploited;
access to assembly language using GCC syntax is also provided.  GNU
Modula-2 also support sets of any ordinal type (memory permitting).

GNU Modula-2 was based on a Modula-2 front end which performed a
substantial amount of static analysis of the source code (see
@samp{-Wpedantic}, @samp{-Wpedantic-param-names}, @samp{-Wstudents}
and @samp{-Wpedentic-cast}.

Finally runtime checking has been implemented and can check: bounds of
subranges and array indexes, functions execute a @code{RETURN}
statement, a pointer does not dereference a @code{NIL} pointer value
and that the expression within a @code{CASE} statement is correctly
matched.

@node Release map, Compiler options, Why use GNU Modula-2, Using
@section Release map

This section attempts to give an idea of which releases points are
likely in the future. Clearly this is a fairly fluid release map but
hopefully it is more helpful than omitting it altogether. Please note
that this is not set in stone and if you wish to see something
different please email @email{gaius@@gnu.org} with your ideas. Also
please note that the actual release numbers do not have any
correlation to the estimated time of release. For example please do
not misunderstand that GM2-1.0 will take twice as long as GM2-0.5 to
appear. It is worthing noting that some of the later points in the
release life have already been addressed (in part) but are not yet
complete.

@table @code

@item 0.50
compatible with gcc-3.3.6. GNU Modula-2 is stable and passes all
regression tests on LP64 Opteron and 32 bit x86 GNU/Linux.  The
compiler is PIM-234 compatible (use @samp{-fpim2}, @samp{-fpim3} and
@samp{-fpim4} to force mutually exclusive PIM features).

It is also able to compile the University of Ulm libraries which are
now distributed as part of GNU Modula-2.  To reference these libraries
use the @samp{-flibs=ulm} compiler switch.

@item 0.60
many Logitech compatible libraries will be provided, which will
be available when invoked by @samp{-fpim}.

@item 0.70
ISO exception handling working.  Core exception handling ISO modules
completed.  Basic ISO IO libraries implemented.

@item 0.80
a full set of ISO libraries will have been implemented.  GNU Modula-2
will be sufficiently ISO compliant to compile the libraries but will
not yet be able to fully conform to the ISO Modula-2 standard.
COMPLEX types implemented.

@item 0.90
Multi-dimensional dynamic arrays complete.  This release marks the
porting and bug fixing and rapid releasing count down towards..

@item 1.0
GNU Modula-2 will be fully ISO compliant.
@end table

There will be releases inbetween those outlined above and these releases
may occur when GNU Modula-2 builds using a different GCC source tree.
It is a goal that backward compatibility to gcc-3.3.6 will be provided
as far as it is possible.  Releases will also occur if a key component
of ISO Modula-2 is implemented (for example exception handling,
complex types or @samp{FINALLY} is implemented).

@node Compiler options, Example usage, Release map, Using
@section Compiler options

This section describes the compiler options specific to GNU Modula-2 for
generic flags details see
@xref{Invoking GCC, , ,gcc}.

@table @code

@item -d
a GCC option @xref{Invoking GCC, , ,gcc}.  It allows users
to specify how the rtl passes should dump their internal state.

@item -I
used to specify the search path for definition and implementation
modules.  An example is:  @code{gm2 -g -c -I.:../../libs foo.mod}.
If this option is not specified then the default path is added
which consists of the current directory followed by the appropriate
language dialect library directories.

@item -fobject-path=
used to specify the path for objects during the linking stage.  An
example is: @code{gm2 -g -fobject-path=.:../../libs/O2 -I.:../../libs
foo.mod}.  The combination of @code{-I} and @code{-fobject-path=}
allows projects to keep various styles of objects separate from their
source counterparts.  For example it would be possible to compile
implementation modules with different levels of optimization and
with/without debugging and keep them in separate directories.  If the
@code{-fobject-path=} option is not specified then it is set
internally by using the path as specified by the @code{-I} option.  If
the @code{-I} was also not specified then it uses the current
directory.  In all cases the appropriate language dialect library
directories are appended to the end of the path.

@item -fdump-system-exports
display all inbuilt system items.
This is an internal command line option.

@item -fswig
generate a swig interface file.

@item -fshared
generate a shared library from the module.

@item -fmakeinit
generate the start up C code for the module, a file @file{_m2_modulename.c} is created.
This is an internal command line option.

@item -fmakeall
generate a temporary makefile and build all dependent modules and
link.

@item -fruntime-modules=
specify, using a comma separated list, the runtime modules and their
order.  These modules will initialized first before any other modules
in the application dependancy.  By default the runtime modules list is
set to @code{Storage,SYSTEM,M2RTS,RTExceptions}.

@item -fbounds
generate code to check the bounds of subranges and array indexes.

@item -freturn
generate code to check that functions always exit with a @code{RETURN}
and do not fall out at the end.

@item -fnil
turns on runtime checking to detect accessing data through a
@code{NIL} value pointer.

@item -fcase
turns on runtime checking to check whether a @code{CASE} statement
requires an @code{ELSE} clause when on was not specified.

@item -fcheck-all
turns on all runtime checks. This is the same as invoking
GNU Modula-2 using the command options
@code{-fbounds} @code{-freturn} @code{-fnil} @code{-fcase}.

@item -v
display all calls to subsidiary programs, such as the C preprocessor,
the GNU Modula-2 linker and compiler.

@item -fstatistics
generates quadruple information: number of quadruples generated,
number of quadruples remaining after optimisation.

@item -fmakelist
this option is only applicable when linking a program module.  The
compiler will generate a @file{modulename.lst} file which contains a
list indicating the initialisation order of all modules which are to
be linked. The actual link does not occur.  The GNU Modula-2 linker
scans all @code{IMPORT}s, generates a list of dependencies and
produces an ordered list for initialisation. It will probably get the
order wrong if your project has cyclic dependencies, but the
@file{.lst} file is plain text and can be modified if required.  Once
the @file{.lst} file is created it can be used by the compiler to link
your project via the @samp{-fuselist} option.  It has no effect if the
@samp{-c} option is present.

@item -fuselist
providing @samp{gm2} has been told to link the program module this
option uses the file @file{modulename.lst} for the initialisation
order of modules.

@item -fcpp
preprocess the source with @samp{cpp -lang-asm -traditional-cpp}
For further details about these options see @xref{Invocation, , ,cpp}.
If @samp{-fcpp} is supplied then all definition modules and
implementation modules which are parsed will be preprocessed by
@samp{cpp}.

@item -fiso
turn on ISO standard features. Currently this enables the ISO
@code{SYSTEM} module and alters the default library search path so
that the ISO libraries are searched before the PIM libraries.  It also
effects the behaviour of @code{DIV} and @code{MOD} operators.
See @xref{Dialect, , ,gm2}.

@item -fpim
turn on PIM standard features. Currently this enables the PIM
@code{SYSTEM} module and determines which identifiers are pervasive
(declared in the base module). If no other @samp{-fpim[234]} switch is
used then division and modulus operators behave as defined in PIM4.
See @xref{Dialect, , ,gm2}.

@item -fpim2
turn on PIM-2 standard features. Currently this removes @code{SIZE}
from being a pervasive identifier (declared in the base module).  It
places @code{SIZE} in the @code{SYSTEM} module.  It also effects the
behaviour of @code{DIV} and @code{MOD} operators.
See @xref{Dialect, , ,gm2}.

@item -fpim3
turn on PIM-3 standard features. Currently this only effects the
behaviour of @code{DIV} and @code{MOD} operators.
See @xref{Dialect, , ,gm2}.

@item -fpim4
turn on PIM-4 standard features. Currently this only effects the
behaviour of @code{DIV} and @code{MOD} operators.
See @xref{Dialect, , ,gm2}.

@item -fpositive-mod-floor-div
forces the @code{DIV} and @code{MOD} operators to behave as defined by PIM4.
All modulus results are positive and the results from the division are
rounded to the floor.
See @xref{Dialect, , ,gm2}.

@item -flibs=ulm
modifies the default library search path so that the University of Ulm
libraries are searched before the other PIM libraries.

@item -flibs=pim
modifies the default library search path so that the PIM libraries
are searched before any others (the default).

@item -flibs=min
modifies the default library search path so that the absolute minimum
of Modula-2 runtime libraries are loaded (a stripped down M2RTS, SYSTEM
and libc).

@item -flibs=iso
modifies the default library search path so that the ISO libraries are
searched before any others (not needed if @samp{-fiso} was specified).

@item -flibs=logitech
modifies the default library search path so that the Logitech compatible
libraries are searched before the base PIM libraries.

@item -flibs=pim-coroutine
modifies the default libraries search path so that the PIM @code{SYSTEM}
module providing coroutine support is searched before the base PIM libraries.
This directory also includes many coroutine related libraries.

@item -fextended-opaque
allows opaque types to be implemented as any type. This is a GNU
Modula-2 extension and it requires that the implementation module
defining the opaque type is available so that it can be resolved when
compiling the module which imports the opaque type.

@item -fsources
displays the path to the source of each module.  This option
can be used at compile time to check the correct definition module
is being used.

@item -fmodules
displays the path to each modules object file.  This option
is used at link time to check the correct object file is being
linked.

@item -fdef=
recognise the specified suffix as a definition module filename.
The default implmentation and module filename suffix is @file{.def}.
If this option is used GNU Modula-2 will still fall back to this
default if a requested definition module is not found.

@item -fmod=
recognise the specified suffix as implementation and module filenames.
The default implmentation and module filename suffix is @file{.mod}.
If this option is used GNU Modula-2 will still fall back to this
default if it needs to read an implmentation module and the specified
suffixed filename does not exist.
Both this option and @code{-fdef=} also work with the @code{-fmakeall}
option.

@item -fxcode
issues all errors and warnings in the @file{Xcode} format.

@item -funbounded-by-reference
enable optimization of unbounded parameters by attempting to pass non
@code{VAR} unbounded parameters by reference.  This optimization
avoids the implicit copy inside the callee procedure. GNU Modula-2
will only allow unbounded parameters to be passed by reference if,
inside the callee procedure, they are not written to, no address is
calculated on the array and it is not passed as a @code{VAR}
parameter.  Note that it is possible to write code to break this
optimization, therefore this option should be used carefully.
For example it would be possible to take the address of an array, pass
the address and the array to a procedure, read from the array in
the procedure and write to the location using the address parameter.

Due to the dangerous nature of this option it is not enabled
when the -O option is specified.

@item -Wverbose-unbounded
inform the user which non @code{VAR} unbounded parameters will be
passed by reference.  This only produces output if the option
@samp{-funbounded-by-reference} is also supplied on the command line.

@item -Wstudents
checks for bad programming style. This option is aimed at new users of
Modula-2 in that it checks for situations which might cause confusion
and thus mistakes.  It checks whether variables of the same name are
declared in different scopes and whether variables look like keywords.
Experienced users might find this option too aggressive.

@item -Wpedantic
forces the compiler to reject nested @code{WITH} statements
referencing the same record type.  Does not allow multiple imports of
the same item from a module.  It also checks that: procedure variables
are written to before being read; variables are not only written to
but read from; variables are declared and used.  If the compiler
encounters a variable being read before written it will terminate with
a message.  It will check that @code{FOR} loop indices are not used
outside the end of this loop without being reset.

@item -Wpedantic-param-names
procedure parameter names are checked in the definition module 
against their implementation module counterpart. This is not
necessary in ISO or PIM versions of Modula-2, but it can be
extremely useful, as long as code is intentionally
written in this way.

@item -Wpedantic-cast
warns if the ISO system function is used and if the size of
the variable is different from that of the type. This is legal
in ISO Modula-2, however it can be dangerous. Some users may prefer
to use @code{VAL} instead in these situations and use @code{CAST}
exclusively for changes in type on objects which have the same size.

@end table

@node Example usage, Environment variables, Compiler options, Using
@section Example compile and link

This section describes how to compile and link a simple hello world
program.  It provides a few examples of using the different options
mentioned in @xref{Compiler options, , ,gm2}.  Assuming that you have
a file called @file{hello.mod} in your current directory which
contains:

@example
MODULE hello ;

FROM StrIO IMPORT WriteString, WriteLn ;

BEGIN
   WriteString('hello world') ; WriteLn
END hello.
@end example

You should be able to compile it by: @samp{gm2 -c -g -I. hello.mod}
and link via: @samp{gm2 -g -I. hello.mod}.  The result should be an
@samp{a.out} file created in your directory.

Alternatively it may be compiled by:

@samp{gm2 -g -I. -fmakeall hello.mod}
@footnote{To see all the compile actions taken by @samp{gm2} users can also
add the @samp{-v} flag at the command line, for example:

@samp{gm2 -v -g -I. -fmakeall hello.mod}

This displays the subprocesses initiated by @samp{gm2} which can be useful
when trouble shooting.}

@node Environment variables, Elementary data types, Example usage, Using
@section GNU Modula-2 related environment variables

This section descibes the environment variables used by GNU Modula-2 and
how they can be used to switch between releases of the compiler.  Other
environment variables can be set to modify the default library path.
Initially we will consider environment variables most likely used by
the end user.  These two environment variables are @code{GM2IPATH}
and @code{GM2OPATH}.

For example suppose a compile and link on the command line looks like
this:

@example
$ gm2 -g -c -I. -I../project:../project/unix foo.mod
$ gm2 -g -I. -I../project:../project/unix \
  -fobject-path=../project/obj:../project/unix/obj -I. foo.mod
@end example

they can be simplified by utilising two environment variables to do
exactly the same compile and link.

@example
$ export GM2IPATH=../project:../project/unix
$ export GM2OPATH=../project/obj:../project/unix/obj
$ gm2 -g -c -I. foo.mod
$ gm2 -g -I. foo.mod
@end example

It is important to note that the two environment variables
@code{GM2IPATH} and @code{GM2OPATH} have a lower priority than any
@code{-I} or @code{-fobject-path=} command line option.  The search
order for compiling and linking is: command line switches followed by
environment variable paths followed by default runtime libraries or
Modula-2 dialect libraries.  If in doubt include the @code{-v} option
to see the search path used between the compiler subcomponents.

Lastly there is the @code{GM2_ROOT} environment variable which
determines whether the compiler subcomponents reside in the
filesystem.  This environment variable overrides the compiler time
configure option @code{--prefix=}.  For example suppose the compiler
was built to reside in @file{/usr/local} and the system administrator
decided to move the entire compiler tree to
@file{/architecture/i386/usr}.  Once the tree is moved then a system
wide environment variable (@code{GM2ROOT}) could be set to:

@example
$ export GM2ROOT=/architecture/i386/usr
@end example

The system administrator needs to ensure that the front end binary
@file{gm2} can be seen by the users path.  At that point a user can
invoke @code{gm2 -g -c -I. hello.mod} from the command line and all
subcomponents will be picked up from @file{/architecture/i386/usr}.
This allows users to try out different GNU Modula-2 releases and also
allows system administrators to install compiler binaries at different
locations to where they were initially configured to reside.

@node Elementary data types, Standard procedures, Environment variables, Using
@section Elementary data types

This section describes the elementary data types supported by GNU
Modula-2. It also describes the relationship between these data types
and the equivalent C data types.

The following data types are supported: @code{INTEGER},
@code{LONGINT}, @code{SHORTINT}, @code{CARDINAL}, @code{LONGCARD},
@code{SHORTCARD}, @code{BOOLEAN}, @code{REAL}, @code{LONGREAL},
@code{SHORTREAL}, @code{COMPLEX}, @code{LONGCOMPLEX},
@code{SHORTCOMPLEX} and @code{CHAR}.

An equivalence table is given below:

@example
GNU Modula-2              GNU C
======================================
INTEGER                   int
LONGINT                   long long int
SHORTINT                  short int
CARDINAL                  unsigned int
LONGCARD                  long long unsigned int
SHORTCARD                 short unsigned int
BOOLEAN                   int
REAL                      double
LONGREAL                  long double
SHORTREAL                 float
CHAR                      char
SHORTCOMPLEX              _Complex float
COMPLEX                   _Complex double
LONGCOMPLEX               _Complex long double
@end example

Note that GNU Modula-2 also supports fixed sized data types which are
exported from the @code{SYSTEM} module.
@xref{The PIM system module, , ,gm2}.
@xref{The ISO system module, , ,gm2}.

@node Standard procedures, Dialect, Elementary data types, Using
@section Permanently accessible base procedures.

This section describes the procedures and functions which are
always visible.

@subsection Standard procedures and functions common to PIM and ISO

The following procedures are implemented and conform with Programming
in Modula-2 and ISO Modula-2: @code{NEW}, @code{DISPOSE}, @code{INC},
@code{DEC}, @code{INCL}, @code{EXCL} and @code{HALT}.  The standard
functions are: @code{HIGH}, @code{CAP}, @code{ABS}, @code{ODD},
@code{VAL}, @code{CHR}, @code{MIN}, @code{MAX}. All these functions
and procedures (except @code{HALT}, @code{NEW}, @code{DISPOSE} and,
under non constant conditions, @code{LENGTH}) generate in-line code
for efficiency.

@example

(*
   NEW - the procedure NEW is replaced by:
         ALLOCATE(p, TSIZE(p^)) ;
         The user is expected to import the procedure ALLOCATE
         (normally found in the module, Storage.)

         In:  a variable p: of any pointer type.
         Out: variable, p, is set to some allocated memory
              which is large enough to hold all the contents of p^.
*)

@findex NEW
PROCEDURE NEW (VAR p:<any pointer type>) ;
@end example

@example

(*
   DISPOSE - the procedure DISPOSE is replaced by:
             DEALLOCATE(p, TSIZE(p^)) ;
             The user is expected to import the procedure DEALLOCATE
             (normally found in the module, Storage.)

             In:  a variable p: of any pointer type which has been
                  initialized by a call to NEW.
             Out: the area of memory
                  holding p^ is returned to the system.
                  Note that the underlying procedure DEALLOCATE
                  procedure in module Storage will assign p to NIL.
*)

@findex DISPOSE
PROCEDURE DISPOSE (VAR p:<any pointer type>) ;
@end example

@example

(*
   INC - can take one or two parameters. If supplied with one
         parameter it adds 1 to the variable, v.
         If two parameters are supplied then the value, a, is
         added to, v.
*)

@findex INC
PROCEDURE INC (VAR v: <any base type>; [a: <any base type> = 1]) ;
@end example

@example

(*
   DEC - can take one or two parameters. If supplied with one
         parameter it subtracts 1 from the variable, v.
         If two parameters are supplied then the value, a, is
         subtracted from, v.
*)

@findex DEC
PROCEDURE DEC (VAR v: <any base type>; [a: <any base type> = 1]) ;
@end example

@example

(*
   INCL - includes bit element, e, to a set type, s.
*)

@findex INCL
PROCEDURE INCL (VAR s: <any set type>; e: <element of set type s>) ;
@end example

@example

(*
   EXCL - excludes bit element, e, from a set type, s.
*)

@findex EXCL
PROCEDURE EXCL (VAR s: <any set type>; e: <element of set type s>) ;
@end example

@example

(*
   HALT - will call the HALT procedure inside the module M2RTS.
          Users can replace M2RTS.
*)

@findex HALT
PROCEDURE HALT ;

@end example

The following define the standard set of functions which conform with
Programming in Modula-2 and ISO Modula-2.

@example

(*
   HIGH - returns the last accessible index of an parameter declared as
          ARRAY OF CHAR. Thus

          PROCEDURE foo (a: ARRAY OF CHAR) ;
          VAR
             c: CARDINAL ;
          BEGIN
             c := HIGH(a)
          END foo ;

          BEGIN
             foo('hello')
          END

          will cause the local variable, c, to contain the value 4
*)

@findex HIGH
PROCEDURE HIGH (a: ARRAY OF CHAR) : CARDINAL ;
@end example

@example

(*
   CAP - returns the capital of character, ch, providing
         ch lies within the range 'a'..'z'. Otherwise, ch,
         is returned unaltered.
*)

@findex CAP
PROCEDURE CAP (ch: CHAR) : CHAR ;

@end example

@example

(*
   ABS - returns the positive value of, i.
*)

@findex ABS
PROCEDURE ABS (i: <any signed type>) : <any signed type> ;

@end example

@example

(*
   VAL - converts data, i, of <any simple data type 2> to
         <any simple data type 1> and returns this value.
         No range checking is performed during this conversion.
*)

@findex VAL
PROCEDURE VAL (<any simple data type 1>,
               i: <any simple data type 2>) : <any simple data type 1> ;

@end example

@example
(*
   CHR - converts a value of a <whole number type> into a CHAR.
         CHR(x) is shorthand for VAL(CHAR, x).
*)

@findex CHR
PROCEDURE CHR (x: <whole number type>) : CHAR ;

@end example

@example
(*
   ODD - returns TRUE if the value is not divisible by 2.
*)

@findex ODD
PROCEDURE ODD (x: <whole number type>) : BOOLEAN ;

@end example

@example
(*
   MIN - returns the lowest legal value of an ordinal type.
*)

@findex MIN
PROCEDURE MIN (t: <ordinal type>) : <ordinal type> ;

@end example

@example
(*
   MAX - returns the largest legal value of an ordinal type.
*)

@findex MAX
PROCEDURE MAX (t: <ordinal type>) : <ordinal type> ;

@end example


@subsection ISO specific standard procedures and functions

The standard function @code{LENGTH} is specific to ISO Modula-2 and
is defined as:

@example

(*
   LENGTH - returns the length of string, a.
*)

@findex LENGTH
PROCEDURE LENGTH (a: ARRAY OF CHAR) : CARDINAL ;

@end example

This function is evaluated at compile time, providing that string
@code{a} is a constant. If @code{a} cannot be evaluated then a call is
made to @code{M2RTS.Length}.

@c complete other ISO functions

@node Dialect, Extensions, Standard procedures, Using
@section GNU Modula-2 supported dialects

This section describes the dialects understood by GNU Modula-2.
It also describes the differences between the dialects and
any command line switches which determine dialect behaviour.

The GNU Modula-2 compiler is based on the language as defined in
'Programming in Modula-2' 2nd Edition, Springer Verlag, 1982, 1983 by
Niklaus Wirth (PIM2), 'Programming in Modula-2', 3rd Corrected
Edition, Springer Verlag, 1985 (PIM3) and 'Programming in Modula-2',
4th Edition, Springer Verlag, 1988 (PIM4).  It also includes ISO M2
features and GNU Modula-2 extensions. Currently GNU Modula-2
(@value{version-GM2}) implements all PIM dialects of the language,
eventually GNU Modula-2 will be fully compliant with ISO Modula-2.

The command line switches @samp{-fpim2}, @samp{-fpim3},
@samp{-fpim4} and @samp{-fiso} can be used to force mutually
exclusive features. However by default the compiler will not
agressively fail if a non mutually exclusive feature is used
from another dialect. For example it is possible to specify
@samp{-fpim2} and still utilise @samp{DEFINITION} @samp{MODULES}
which have no export list.

Some dialect differences will force a compile time error, for example
in PIM2 the user must @code{IMPORT} @code{SIZE} from the module
@code{SYSTEM}, whereas in PIM3 and PIM4 @code{SIZE} is a pervasive
function. Thus compiling PIM4 source code with the @samp{-fpim2}
switch will cause a compile time error. This can be fixed quickly
with an additional @code{IMPORT} or alternatively by compiling with
the @samp{-fpim4} switch.

However there are some very important differences between the dialects
which are mutually exclusive and therefore it is vital that users
choose the dialects with care when these language features are used.

@subsection Integer division, remainder and modulus

The most dangerous set of mutually exclusive features found in the
four dialects supported by GNU Modula-2 are the @code{INTEGER}
division, remainder and modulus arithmetic operators.  It is important
to note that the same source code can be compiled to give different
runtime results depending upon these switches! The reference manual
for the various dialects of Modula-2 are quite clear about this
behaviour and sadly there are three distinct definitions.

The table below illustrates the problem when a negative operand is
used.

@example
                  Pim2/3          Pim4                ISO
               -----------    -----------    ----------------------
lval    rval   DIV     MOD    DIV     MOD    DIV    MOD    /    REM
 31      10      3       1      3       1      3      1     3     1
-31      10     -3      -1     -4       9     -4      9    -3    -1
 31     -10     -3       1     -3       1     Exception    -3     1
-31     -10      3      -1      4       9     Exception     3    -1
@end example

See also P24 of PIM2, P27 of PIM3, P29 of PIM4 and P201 of the ISO Standard.
At present all dialect division, remainder and modulus are implemented as
above, apart from the exception calling in the ISO dialect. Instead of
exception handling the results are the same as the PIM4 dialect. This
is a temporary implementation situation.

@node Extensions, Type compatibility, Dialect, Using
@section GNU Modula-2 language extensions

This section introduces the GNU Modula-2 language extensions.
The GNU Modula-2 compiler allows abstract data types to be any type,
not just restricted to a pointer type providing the
@samp{-fextended-opaque} option is supplied
@xref{Compiler options, , ,gm2}.

Declarations can be made in any order, whether they are
types, constants, procedures, nested modules or variables
(see @xref{Passes, , ,}.)

GNU Modula-2 also allows programmers to interface to @code{C} and
assembly language.

GNU Modula-2 provides support for the special tokens @code{__LINE__},
@code{__FILE__}, @code{__FUNCTION__} and @code{__DATE__}. Support for
these tokens will occur even if the @samp{-fcpp} option is not
supplied. A table of these identifiers and their data type and values
is given below:

@example
Scope       GNU Modula-2 token      Data type and example value

anywhere    __LINE__                Constant Literal compatible
                                    with CARDINAL, INTEGER and WORD.
                                    Example 1234

anywhere    __FILE__                Constant string compatible
                                    with parameter ARRAY OF CHAR or
                                    an ARRAY whose SIZE is >= string
                                    length. Example
                                    "hello.mod"

procedure   __FUNCTION__            Constant string compatible
                                    with parameter ARRAY OF CHAR or
                                    an ARRAY whose SIZE is >= string
                                    length. Example
                                    "calc"

module      __FUNCTION__            Example
                                    "module hello initialization"

anywhere    __DATE__                Constant string compatible
                                    with parameter ARRAY OF CHAR or
                                    an ARRAY whose SIZE is >= string
                                    length. Example
                                    "Thu Apr 29 10:07:16 BST 2004"

anywhere   __COLUMN__               Gives a contant literal number
                                    determining the column of the
                                    first token on the line.

@end example

The preprocessor @samp{cpp} can be invoked via the @samp{-fcpp}
command line option. This in turn invokes @samp{cpp} with the
following arguments @samp{-traditional -lang-asm}.  These options
preserve comments and all quotations.  @samp{gm2} treats a @samp{#}
character in the first column as a preprocessor directive.

For example here is a module which calls @code{FatalError}
via the macro @code{ERROR}.

@example
MODULE cpp ;

FROM SYSTEM IMPORT ADR, SIZE ;
FROM libc IMPORT exit, printf, malloc ;

PROCEDURE FatalError (a, file: ARRAY OF CHAR;
                         line: CARDINAL;
                         func: ARRAY OF CHAR) ;
BEGIN
   printf("%s:%d:fatal error, %s, in %s\n",
           ADR(file), line, ADR(a), ADR(func)) ;
   exit(1)
END FatalError ;

#define ERROR(X)  FatalError(X, __FILE__, __LINE__, __FUNCTION__)

VAR
   pc: POINTER TO CARDINAL;
BEGIN
   pc := malloc(SIZE(CARDINAL)) ;
   IF pc=NIL
   THEN
      ERROR('out of memory')
   END
END cpp.
@end example

@subsection Optional procedure parameter

GNU Modula-2 allows the last parameter to a procedure or function
parameter to be optional. For example in the ISO library
@file{COROUTINES.def} the procedure @code{NEWCOROUTINE} is defined as
having an optional fifth argument (@code{initProtection}) which, if
absent, is automatically replaced by @code{NIL}.

@example
@findex NEWCOROUTINE
PROCEDURE NEWCOROUTINE (procBody: PROC; workspace: SYSTEM.ADDRESS;
                        size: CARDINAL; VAR cr: COROUTINE;
                        [initProtection: PROTECTION = NIL]);

  (* Creates a new coroutine whose body is given by procBody,
     and returns the identity of the coroutine in cr.
     workspace is a pointer to the work space allocated to
     the coroutine; size specifies the size of this workspace
     in terms of SYSTEM.LOC.

     The optional fifth argument may contain a single parameter
     which specifies the initial protection level of the coroutine.
  *)
@end example

The implementation module @file{COROUTINES.mod} implements this
procedure using the following syntax:

@example
PROCEDURE NEWCOROUTINE (procBody: PROC; workspace: SYSTEM.ADDRESS;
                        size: CARDINAL; VAR cr: COROUTINE;
                        [initProtection: PROTECTION]);
BEGIN
   
END NEWCOROUTINE ;
@end example

Note that it is illegal for this declaration to contain an initialiser
value for @code{initProtection}. However it is necessary to surround
this parameter with the brackets @code{[} and @code{]}. This serves to
remind the programmer that the last parameter was declared as optional
in the definition module.

Local procedures can be declared to have an optional final parameter
in which case the initializer is mandatory in the implementation or
program module.

GNU Modula-2 also provides additional fixed sized data types which
are all exported from the @code{SYSTEM} module.
@xref{The PIM system module, , ,gm2}.
@xref{The ISO system module, , ,gm2}.

@node Type compatibility, Unbounded by reference, Extensions, Using
@section GNU Modula-2 language extensions

This section discuss the issues surrounding assignment, expression
and parameter compatibility, their effect of the additional
fixed sized datatypes and also their effect of runtime checking.
The data types supported by the compiler are:

@example
GNU Modula-2              scope      switches
=============================================
INTEGER                   pervasive
LONGINT                   pervasive
SHORTINT                  pervasive
CARDINAL                  pervasive
LONGCARD                  pervasive
SHORTCARD                 pervasive
BOOLEAN                   pervasive
REAL                      pervasive
LONGREAL                  pervasive
SHORTREAL                 pervasive
CHAR                      pervasive
SHORTCOMPLEX              pervasive
COMPLEX                   pervasive
LONGCOMPLEX               pervasive

BITSET                    SYSTEM
LOC                       SYSTEM     -fiso
BYTE                      SYSTEM
WORD                      SYSTEM
ADDRESS                   SYSTEM

The following extensions are supported for
most architectures (please check SYSTEM.def).
=============================================
INTEGER8                  SYSTEM
INTEGER16                 SYSTEM
INTEGER32                 SYSTEM
INTEGER64                 SYSTEM
CARDINAL8                 SYSTEM
CARDINAL16                SYSTEM
CARDINAL32                SYSTEM
CARDINAL64                SYSTEM
BITSET8                   SYSTEM
BITSET16                  SYSTEM
BITSET32                  SYSTEM
WORD16                    SYSTEM
WORD32                    SYSTEM
WORD64                    SYSTEM
REAL32                    SYSTEM
REAL64                    SYSTEM
REAL96                    SYSTEM
REAL128                   SYSTEM
COMPLEX32                 SYSTEM
COMPLEX64                 SYSTEM
COMPLEX96                 SYSTEM
COMPLEX128                SYSTEM
@end example

The compiler categorises compatibility between all these types
into three components: assignment, parameter and expression.

@subsection Assignment compatibility

This section discusses the assignment issues surrounding assignment
compatibility of fundamental types.  Obviously compatibility exists
between the same sized types.  Same type family of different sizes are
also compatible as long as the @code{MAX(}type@code{)} and
@code{MIN(}type@code{)} is known.  So for example this includes the
@code{INTEGER} family, @code{CARDINAL} family and the @code{REAL}
family.  The reason for this is that when the assignment is performed
the compiler will check to see that the expression (on the right of
the @code{:=}) lies within the bounds of the designator type (on the
left hand side of the @code{:=}).  Thus these ordinal types can be
assignment compatible.  However it does mean that @code{WORD32} is not
compatible with @code{WORD16} as @code{WORD32} does not have a minimum
or maximum value and therefore cannot be checked.  The compiler does
not know which of the two bytes from @code{WORD32} should be copied
into @code{WORD16} and which two should be ignored.  Currently the
types @code{BITSET8}, @code{BITSET16} and @code{BITSET32} are
assignment incompatible.  However this restriction maybe lifted when
further runtime checking is achieved.

Modula-2 does allow @code{INTEGER} to be assignment compatible with
@code{WORD} as they are the same size.  Likewise GNU Modula-2 allows
@code{INTEGER16} to be compatible with @code{WORD16} and the same for
the other fixed sized types and their sized equivalent in either
@code{WORD}n, @code{BYTE} or @code{LOC} types.  However it prohibits
assignment between @code{WORD} and @code{WORD32} even though on many
systems these sizes will be the same.  The reasoning behind this rule
is that the extended fixed sized types are meant to be used by
applications requiring fixed sized data types and it is more portable
to forbid the bluring of the boundaries between fixed sized and
machine dependant sized types.

Intemediate code runtime checking is always generated by the front
end.  However this intemediate code is only translated into actual
code if the appropriate command line switches are specified.  This
allows the compiler to perform limited range checking at compile time.
In the future it will allow the extensive GCC optimisations to
propagate constant values through to the range checks which if they
are found to exceed the type bounds will result in a compile time
error message.

@subsection Expression compatibility

According to the various Modula-2 standards @code{INTEGER} and
@code{CARDINAL} types are not expression compatible
(@uref{http://freepages.modula2.org/report4/modula-2.html} and ISO
Modula-2).  This is rule is also extended across the fixed sized
data types.

@subsection Parameter compatibility

Parameter compatibility is divided into two arenas, pass by value and
pass by reference (@code{VAR}).  In the case of pass by value the
rules are exactly the same as assignment.  However in the second case,
pass by reference, the actual parameter and formal parameter must be
the same size and family.  Furthermore @code{INTEGER} and
@code{CARDINAL}s are not treated as compatible in the pass by
reference case.

The types @code{BYTE}, @code{LOC} and @code{WORD} and sized
their derivitives are assignment and parameter compatible with any
data type of the same size.

@node Unbounded by reference, Interface for Python, Type compatibility, Using
@section Unbounded by reference

This section documents a GNU Modula-2 compiler switch which implements
a language optimisation surrounding the implementation of unbounded
arrays.  In GNU Modula-2 the unbounded array is implemented by
utilising an internal structure @code{struct @{dataType *address,
unsigned int high@}}.  So given the Modula-2 procedure declaration:

@example
PROCEDURE foo (VAR a: ARRAY OF dataType) ;
BEGIN
   IF a[2]= (* etc *)
END foo ;
@end example

it is translated into GCC @code{tree}s, which can be represented
in their C form thus:

@example
void foo (struct @{dataType *address, unsigned int high@} a)
@{
   if (a.address[2] == /* etc */
@}
@end example

Whereas if the procedure @code{foo} was declared as:

@example
PROCEDURE foo (a: ARRAY OF dataType) ;
BEGIN
   IF a[2]= (* etc *)
END foo ;
@end example

then it is implemented by being translated into the following
GCC @code{tree}s, which can be represented in their C form thus:

@example
void foo (struct @{dataType *address, unsigned int high@} a)
@{
   dataType *copyContents = (dataType *)alloca (a.high+1);
   memcpy(copyContents, a.address, a.high+1);
   a.address = copyContents;

   if (a.address[2] == /* etc */
@}
@end example

This implementation works, but it makes a copy of each non VAR
unbounded array when a procedure is entered.  If the unbounded array
is not changed during procedure @code{foo} then this implementation
will be very inefficient.  In effect Modula-2 lacks the @code{REF}
keyword of Ada.  Consequently the programmer maybe tempted to
sacrifice semantic clarity for greater efficiency by declaring the
parameter using the @code{VAR} keyword in place of @code{REF}.

The @code{-funbounded-by-reference} switch instructs the compiler to
check and see if the programmer is modifying the content of any
unbounded array.  If it is modified then a copy will be made upon
entry into the procedure.  Conversely if the content is only read and
never modified then this non @code{VAR} unbounded array is a candidate
for being passed by reference.  It is only a candidate as it is still
possible that passing this parameter by reference could alter the
meaning of the source code.  For example consider the following case:

@example
PROCEDURE StrConCat (VAR a: ARRAY OF CHAR; b, c: ARRAY OF CHAR) ;
BEGIN
   (* code which performs string a := b + c *)
END StrConCat ;

PROCEDURE foo ;
VAR
   a: ARRAY [0..3] OF CHAR ;
BEGIN
   a := 'q' ;
   StrConCat(a, a, a)
END foo ;
@end example

In the code above we see that the same parameter, @code{a}, is being
passed three times to @code{StrConCat}.  Clearly even though parameters
@code{b} and @code{c} are never modified it would be incorrect to
implement them as pass by reference.  Therefore the compiler checks to
see if any non @code{VAR} parameter is type compatible with any
@code{VAR} parameter and if so it generates runtime procedure entry
checks to determine whether the contents of parameters @code{b} or
@code{c} matches the contents of @code{a}.  If a match is detected
then a copy is made and the @code{address} in the unbounded
@code{struct}ure is modified.

The compiler will check the address range of each candidate against
the address range of any @code{VAR} parameter, providing they are type
compatible.  For example consider:

@example
PROCEDURE foo (a: ARRAY OF BYTE; VAR f: REAL) ;
BEGIN
   f := 3.14 ;
   IF a[0]=BYTE(0)
   THEN
      (* etc *)
   END
END foo ;

PROCEDURE bar ;
BEGIN
   r := 2.0 ;
   foo(r, r)
END bar ;
@end example

Here we see that although parameter, @code{a}, is a candidate for the
passing by reference, it would be incorrect to use this
transformation.  Thus the compiler detects that parameters, @code{a}
and @code{f} are type compatible and will produce runtime checking
code to test whether the address range of their respective contents
intersect.

@node Interface for Python, Interface to C, Unbounded by reference, Using
@section How to produce swig interface files

This section describes how your Modula-2 implementation modules can be
called from Python (and other scripting languages such as TCL and
Perl).  GNU Modula-2 can be instructed to create a swig interface when
it is compiling an implementation module.  Swig then uses the
interface file to generate all the necessary wrapping to that the
desired scripting language may access your implementation module.

Here is an example of how you might call upon the services of the
Modula-2 library module @code{NumberIO} from Python.
This example can be found in the directory
@file{gm2/examples/swig/full-strlib} and can be run using the commands:

@example
$ cd gcc-@value{version-GCC}/gcc/gm2/examples/swig/full-strlib
$ make numberio
@end example

If you wanted to do this step by step without the @file{Makefile} then
firstly you should compile the @code{NumberIO} module as a shared
library.  This can be achieved by using the following commands:

@example
$ cd gcc-@value{version-GCC}/gcc/gm2/examples/swig/full-strlib
$ gm2 -fshared -I. -c -fPIC -g -fswig -I../../../gm2-libs \
    ../../../gm2-libs/NumberIO.mod
@end example

The example assumes that the source code for @file{NumberIO.mod} can
be found in directory @file{../../../gm2-libs}.  The first command
produces two files: @file{NumberIO.i} and @file{NumberIO.o}.  The file
@file{NumberIO.o} is a position independant code object file whereas
the file @file{NumberIO.i} is a swig interface file and contains a
swig interpretation of the @file{NumberIO.def}.  GNU Modula-2 uses the
same mechanism for handling exceptions as GNU C++.  The file
@file{NumberIO.i} contains exception handling information therefore we
need to ask @code{swig} to generate C++ wrappers for
@file{NumberIO.mod}.  This is achieved by:

@example
$ swig -c++ -python NumberIO.i
$ gcc -c -fPIC NumberIO_wrap.cxx -I/usr/include/python2.4
@end example

The swig command line generates the necessary Python and C++ interface
files using the interface file.  The C++ interface file is also
compiled into position independant code.  Finally the module
@code{NumberIO} is linked with all its dependants and
@file{NumberIO_wrap.o}.

@example
$ gm2 -shared -fshared -fPIC -g \
     ../../../gm2-libs/NumberIO.mod NumberIO_wrap.o -o _NumberIO.so
@end example

Now it is possible to run the following Python script
(called @file{testnum.py}):

@example
import NumberIO

print "1234 x 2 =", NumberIO.NumberIO_StrToInt("1234")*2
@end example

like this:

@example
$ python testnum.py
1234 x 2 = 2468
@end example

@subsection Limitations of automatic generated of Swig files

This section discusses the limitations of automatically generating
swig files.  From the previous example we see that the module
@code{NumberIO} had a swig interface file @file{NumberIO.i}
automatically generated by the compiler.  If we consider three of the
procedure definitions in @file{NumberIO.def} we can see the
success and limitations of the automatic interface generation.

@example
PROCEDURE StrToHex (a: ARRAY OF CHAR; VAR x: CARDINAL) ;
PROCEDURE StrToInt (a: ARRAY OF CHAR; VAR x: INTEGER) ;
PROCEDURE ReadInt (VAR x: CARDINAL) ;
@end example

Below are the swig interface prototypes:

@example
extern void NumberIO_StrToHex (char *_m2_address_a,
                               int _m2_high_a, unsigned int *OUTPUT);
/*  parameters: x is known to be an OUTPUT */
extern void NumberIO_StrToInt (char *_m2_address_a,
                               int _m2_high_a, int *OUTPUT);
/*  parameters: x is guessed to be an OUTPUT */
extern void NumberIO_ReadInt (int *x);
/*  parameters: x is unknown */
@end example

In the case of @code{StrToHex} it can be seen that the compiler
detects that the last parameter is an output.  It explicitly tells
swig this by using the parameter name @code{OUTPUT} and in the
following comment it informs the user that it knows this to be an
output parameter.  In the second procedure @code{StrToInt} it marks
the final parameter as an output, but it tells the user that this is
only a guess.  Finally in @code{ReadInt} it informs the user that
it does not know whether the parameter, @code{x}, is an output, input
or an inout parameter.

The compiler decides whether to mark a parameter as either:
@code{INPUT}, @code{OUTPUT} or @code{INOUT} if it is read before
written or visa versa in the first basic block.  At this point
it will write output that the parameter is known.  If it is not
read or written in the first basic block then subsequent basic blocks
are searched and the result is commented as a guess.  Finally if
no read or write occurs then the parameter is commented as unknown.
However, clearly it is possible to fool this mechanism.  Nevertheless
automatic generation of implementation module into swig interface files
was thought sufficiently useful despite these limitations.

In conclusion it would be wise to check all parameters in any
automatically generated swig interface file.  Furthermore you can
force the automatic mechanism to generate correct interface files by
reading or writing to the @code{VAR} parameter in the first basic
block of a procedure.

@section Interfacing GNU Modula-2 to C
@node Interface to C, Assembly language, Interface for Python, Using

The GNU Modula-2 compiler tries to use the C calling convention
wherever possible however some parameters have no C equivalent and
thus a language specific method is used. For example unbounded arrays
are passed as a @code{struct @{void *address, unsigned int high@}} and
the contents of these arrays are copied by callee functions when they
are declared as non @code{VAR} parameters.  The @code{VAR} equivalent
unbounded array parameters need no copy, but still use the
@code{struct} representation.

The recommended method of interfacing GNU Modula-2 to C is by telling
the definition module that the implementation is in the C language.
This is achieved by using the tokens @code{DEFINITION MODULE FOR "C"}.
Here is an example which can be found in the source tree
@file{gcc-@var{version}/gcc/gm2/examples/callingC/libprintf.def}

@example
DEFINITION MODULE FOR "C" libprintf ;

EXPORT UNQUALIFIED printf ;

PROCEDURE printf (a: ARRAY OF CHAR; ...) : [ INTEGER ] ;

END libprintf.
@end example

the @code{UNQUALIFIED} keyword in the definition module informs
GNU Modula-2 not to prefix the module name to exported references
in the object file.

The @code{printf} declaration states that the first parameter
semantically matches @code{ARRAY OF CHAR} but since the module is for
the C language it will be mapped onto @code{char *}. The token
@code{...} indicates a variable number of arguments (varargs) and all
parameters passed here are mapped onto their C equivalents. Arrays and
constant strings are passed as pointers.  Lastly the @code{[ INTEGER ]}
states that the caller can ignore the function return result if desired.

The hello world program can be rewritten as:

@example
MODULE hello ;

FROM libprintf IMPORT printf ;

BEGIN
   printf("hello world\n")
END hello.
@end example

and it can be compiled by:

@samp{gm2 -fmakeall -g -I. hello.mod -lc}

In reality the @samp{-lc} is redundant as libc is always included in the
linking process. It is shown here to emphasize that the C library or
object file containing @code{printf} must be present.

@node Assembly language, Built-ins, Interface to C, Using
@section Interface to assembly language

The interface for GNU Modula-2 to assembly language is almost
identical to GNU C.  The only alterations are that the keywords
@code{asm} and @code{volatile} are in capitals, following the Modula-2
convention.

A simple, but highly non optimal, example is given below. Here we want
to add the two @code{CARDINAL}s @code{foo} and @code{bar} together and
return the result.

@example
PROCEDURE Example (foo, bar: CARDINAL) : CARDINAL ;
VAR
   myout: CARDINAL ;
BEGIN
   ASM VOLATILE ("movl %1,%%eax; addl %2,%%eax; movl %%eax,%0"
      : "=g" (myout)           (* outputs *)
      : "g" (foo), "g" (bar)   (* inputs  *)
      : "eax") ;               (* we trash *)
   RETURN( myout )
END Example ;
@end example

For a full description of this interface we refer the reader to the GNU C manual.

@xref{Extended Asm, ,Extensions to the C Language Family,gcc}.

@node Built-ins, The PIM system module, Assembly language, Using
@section Accessing GNU Modula-2 Built-ins

This section describes the built-in constants and functions defined in
GNU Modula-2.  The following compiler constants can be accessed using
the @code{__ATTRIBUTE__} @code{__BUILTIN__} keywords. These are not
part of the Modula-2 language and they may differ depending upon the
target architecture but they provide a method whereby common
libraries can interface to a different underlying architecture.

The built-in constants are: @code{BITS_PER_UNIT}, @code{BITS_PER_WORD},
@code{BITS_PER_CHAR} and @code{UNITS_PER_WORD}. They are integrated into
GNU Modula-2 by an extension to the @code{ConstFactor} rule:

@example
ConstFactor := ConstQualidentOrSet | Number | ConstString |
               "(" ConstExpression ")" | "NOT" ConstFactor |
               ConstAttribute =:

ConstAttribute := "__ATTRIBUTE__" "__BUILTIN__" "(" "(" Ident ")" ")" =:
@end example

Here is an example taken from the ISO library @code{SYSTEM.def}:

@example
CONST
   BITSPERLOC    = __ATTRIBUTE__ __BUILTIN__ ((BITS_PER_UNIT)) ;
   LOCSPERWORD   = __ATTRIBUTE__ __BUILTIN__ ((UNITS_PER_WORD)) ;
@end example

Built-in functions are transparent to the end user. All built-in
functions are declared in @code{DEFINITION MODULE}s and are imported
as and when required.  Built-in functions are declared in definition
modules by using the @code{__BUILTIN__} keyword. Here is a section of
the ISO library @code{LongMath.def} which demonstrates this feature.

@example
PROCEDURE __BUILTIN__ sqrt (x: LONGREAL): LONGREAL;
  (* Returns the square root of x *)
@end example

This indicates that the function @code{sqrt} will be implemented using
the gcc built-in maths library. If gcc cannot utilise the built-in
function (for example if the programmer requested the address of
@code{sqrt}) then code is generated to call the alternative function
implemented in the @code{IMPLEMENTATION} @code{MODULE}.

Sometimes a function exported from the @code{DEFINITION} @code{MODULE}
will have a different name from the built-in function within gcc. In
such cases the mapping between the GNU Modula-2 function name and the
gcc name is expressed using the keywords @code{__ATTRIBUTE__}
@code{__BUILTIN__} @code{((Ident))}. For example the function
@code{sqrt} in @code{LongMath.def} maps onto the gcc built-in function
@code{sqrtl} and this is expressed as:

@example
PROCEDURE __ATTRIBUTE__ __BUILTIN__ ((sqrtl)) sqrt
                                    (x: LONGREAL) : LONGREAL;
  (* Returns the positive square root of x *)
@end example

The following module @code{Builtins.def} enumerates the list of
built-in functions which can be accessed in GNU Modula-2. It also
serves to define the parameter and return value for each function:

@include Builtins.texi

Although this module exists and will result in the generation of
in-line code if optimization flags are passed to GNU Modula-2, users
are advised to utilize the same functions from more generic libraries.
The built-in mechanism will be applied to these generic
libraries where appropriate. Note for the mathematical routines to
be in-lined you need to specify the @samp{-ffast-math -O} options.

@node The PIM system module, The ISO system module, Built-ins, Using
@section The PIM system module

@include SYSTEM-pim.texi

The different dialects of Modula-2 PIM-[234] and ISO Modula-2 declare
the function @code{SIZE} in different places.  PIM-[34] and ISO
Modula-2 declare @code{SIZE} as a pervasive function (declared in the
base module).  PIM-2 defined @code{SIZE} in the @code{SYSTEM} module
(as shown above).

GNU Modula-2 allows users to specify the dialect of Modula-2 by using
the @code{-fiso} and @code{-fpim2} command line switches.

@node The ISO system module, , The PIM system module, Using
@section The ISO system module

@include SYSTEM-iso.texi

@node Obtaining, Licence, Using, Top
@chapter Obtaining GNU Modula-2.

@section Warning

This code is currently in development and it is not yet complete.
Nevertheless the compiler is sufficiently stable to support itself on
Debian GNU/Linux x86 systems. The PIM libraries are complete but the
ISO libraries and ISO language features are still in development.
Patches and development volunteers highly welcome! 
@xref{Contributing, Contributing to GNU Modula-2}.

@section Getting GNU Modula-2

The easiest way to obtain GNU Modula-2 is to install i386, amd64 or
ppc64 Debian GNU/Linux and then add these repository descriptions to
your @file{/etc/apt/sources.list} file.

@example
#
#  GNU Modula-2 repo
#

deb http://floppsie.comp.glam.ac.uk/debian/ etch main non-free contrib
deb-src http://floppsie.comp.glam.ac.uk/debian/ etch main non-free contrib
@end example

Now as root type:

@example
$ apt-get update
$ apt-get install gm2-doc gm2
@end example

As a normal user you can obtain the source code via:

@example
$ apt-get source gm2
@end example

If you are not running Debian GNU/Linux then you can either download
the source tarball and build it manually or checkout the latest
sources using CVS and combine them with the appropriate gcc tarball
and then finally build it manually.

Combined GNU Modula-2 and patched GCC tarballs exist at
@uref{http://floppsie.comp.glam.ac.uk/pub/c}.
Search for files which look like @file{gm2+gcc-@var{version}.tar.gz}.
For example you should be able to download the latest version of GNU
Modula-2 and GCC using these commands.

@example
$ wget http://floppsie.comp.glam.ac.uk/download/c/gcc-@value{version-GCC}+gm2-cvs-latest.tar.gz
$ tar zxf gcc-@value{version-GCC}+gm2-cvs-latest.tar.gz
@end example

On a GNU/Linux system you should also be able to build it using these
commands.  The following commands assume your shell is @file{/bin/bash}.
To build GNU Modula-2 type:

@example
$ mkdir -p $HOME/opt
$ mkdir -p build-@value{version-GCC}
$ cd build-@value{version-GCC}
$ ../gcc-4.1.2+gm2-cvs-latest/configure --enable-languages=c,c++,gm2 \
     --disable-multilib --enable-checking=all --prefix=$HOME/opt
$ make
@end example

To install GNU Modula-2, after a successful build, type:

@example
$ make install
$ cd ..
@end example

Now you should be able to perform:

@example
$ export PATH=$HOME/opt/bin:$PATH
$ cd gcc-@value{version-GCC}/gcc/gm2/examples/hello
$ make
@end example

which will create an @file{a.out} for the infamous hello world
example.

@section Development sources via CVS

Development sources can be downloaded via CVS but they must be grafted
carefully onto an existing GCC release.  The notes in this section
document how this is achieved, however a prepared CVS and GCC release
is available here
@uref{http://floppsie.comp.glam.ac.uk/download/c/gcc-@value{version-GCC}+gm2-cvs-latest.tar.gz}
and it is created each night.

If you want to obtain the latest sources via CVS then type the
following:

@example
$ cvs -z3 -d:pserver:anoncvs@@cvs.sv.gnu.org:/sources/gm2 co gm2
@end example

This will checkout a copy of GNU Modula-2 into one subdirectory,
@file{gm2}.  This version of GNU Modula-2 needs to be placed inside
the GCC source tree in the position gcc-@value{version-GCC}/gcc before
GNU Modula-2 can be built. Please check the GNU Modula-2 homepage
@uref{http://www.nongnu.org/gm2} for details about which GCC releases
are supported by GNU Modula-2.

Once you have downloaded the correct GCC release from
@uref{http://gcc.gnu.org} or a mirror site you should unpack the GCC
archive.  Assuming that both the @file{gcc-@value{version-GCC}} and
@file{gm2} dicectories are at the same level, you can graft @file{gm2}
onto @file{gcc-@value{version-GCC}} by:

@example   
$ mv gm2 gcc-@value{version-GCC}/gcc
@end example

If the directory
@samp{gcc-@value{version-GCC}/gcc/gm2/patches/gcc/@value{version-GCC}}
exists then the patch files inside that directory can be applied to the
@samp{gcc-@value{version-GCC}} tree. This is done via:

@example
$ cd gcc-@value{version-GCC}
$ if [ -d gcc/gm2/patches/gcc/@value{version-GCC} ] ; then
     for i in gcc/gm2/patches/gcc/@value{version-GCC}/* ; do
        if [ -f $i ] ; then
           patch -p1 < $i
        fi
     done
  fi
@end example

Note that if you download a tarball from
@url{http://floppsie.comp.glam.ac.uk} then any patching will have
already been applied.  @xref{Obtaining, , ,}.

@section Stress testing GM2

Currently there are two automated methods to test GNU Modula-2.
The first method is @samp{make gm2.paranoid} in which @code{gm2}
builds itself and finally the test runs both parent and child
generations of the compiler and compares the output. Be warned
that this test can take some time to execute.
This test is invoked by:

@example
$ cd host-build/gcc ; make gm2.paranoid
@end example

The second method used to test GNU Modula-2 is to run the regression
test suite.  The GNU Modula-2 regression test suite is available for
download.  To install and run the GNU Modula-2 regression suite you
need to have installed the @file{dejagnu} and @file{expect}
packages. Note that you need to ensure that you have at least the
following releases of dejagnu components:

@example
$ runtest --version

Expect version is	5.42.1
Tcl version is		8.4
Framework version is	1.4.4
@end example

otherwise some of the tests may not run.

If you have downloaded the combined GCC and GNU Modula-2 tarball
@uref{http://floppsie.comp.glam.ac.uk/download/c/gcc-@value{version-GCC}+gm2-cvs-latest.tar.gz}
then this will also contain the GNU Modula-2 testsuite.  In this case
you can skip over the following @file{cvs} and @file{tar} commands.

However if you have downloaded GNU Modula-2 using CVS then you will
also need to download and position the testsuite.
Assuming that the root of the GCC source tree is in the current
working directory you can use the following commands to install
the test suite:

@example
$ cvs -z3 -d:pserver:anoncvs@@cvs.sv.gnu.org:/sources/gm2 co testsuite
$ tar cf - testsuite | ( cd gcc-@var{version}/gcc ; tar xf - )
@end example

Do not simply move the directory @file{testsuite} into
@file{gcc-@var{version}/gcc} as the GNU Modula-2 regression
tests have to be overlaid on top of the gcc testsuite.

Thereafter you can run the GNU Modula-2 testsuite by:

@example
$ cd host-build/gcc
$ make check-gm2
@end example

Depending on the speed of your computer these tests may take a while
to complete.

@section Building GNU Modula-2 under Cygwin

GNU Modula-2 now builds under Cygwin.  The Cygwin version used was gcc
version 3.4.4, gdc 0.12 using dmd 0.125.  The following set of
commands were used to build GNU Modula-2.

@example
$ mkdir build
$ cd build
$ ../gcc-4.1.2+gm2-cvs-latest/configure --prefix=/gm2/opt \
  --disable-multilib --enable-checking=all \
  --enable-languages=c,c++,gm2
$ make
@end example

GNU Modula-2 can be installed by:

@example
$ make install
@end example

You now need to modify your path to include @file{gm2}.  This is done
by:

@example
$ export PATH=/gm2/opt/bin:$PATH
@end example

and now you can try out the @code{hello world} example:

@example
$ cd ../gcc-@value{version-GCC}/gcc/gm2/examples/hello
$ make
$ ./a.exe
@end example

@section Moving the installation of GNU Modula-2 to another directory

This section documents how you can configure GNU Modula-2 to install in
one directory and at a later time move the installation to another
completely different directory.  The example assumes the user has a
bourne shell.

Let us assume that the build was configured as such:

@example
$ mkdir build
$ cd build
$ ../gcc-@value{version-GCC}+gm2-cvs-latest/configure \
   --prefix=$HOME/private \
   --enable-languages=c,c++,gm2  --enable-checking \
   --disable-multilib
@end example

in this example we see that the installation directory would normally
be @file{$HOME/private}.  This is accomplished by the following
commands:

@example
$ make
$ make install
@end example

Now, assuming we have correct privileges, we may move the entire
contents of @file{$HOME/private} to @file{/usr/local/public}:

@example
$ mv $HOME/private /usr/local/public
@end example

The new compiler and libraries can be referenced by modifying
our @code{PATH} environment variable:

@example
$ PATH=/usr/local/public/bin:$PATH
$ export PATH
@end example

Finally we can rebuild the @code{hello world} example found
in @file{../gcc-@value{version-GCC}/gcc/gm2/examples/hello} by:

@example
$ cd ../gcc-@value{version-GCC}/gcc/gm2/examples/hello
$ make
$ ./a.out
@end example

@section Building GNU Modula-2 under FreeBSD

[This section is out of date and has not been verified against
gcc-@value{version-GCC} and GNU Modula-2 release
gm2-@value{version-GM2}].

When building GNU Modula-2 under FreeBSD, there are essentially three
issues that need to be addressed.

The first, is the system shell, @file{/bin/sh}. GNU Modula-2's build
script uses some @file{bash} constructs that are not understood by
@file{sh}.  Therefore @file{bash} must be installed and this can be
obtained from the ports package collection (ports:shells/bash).

The second, is the compiler used to bootstrap GNU Modula-2. On
FreeBSD4.x the system compiler is from the 2.95.x generation, and
should work without problems.  On 5-RELEASE and 6-CURRENT, the system
compiler is from the 3.4.x generation or greater, and it is known to
create a faulty GNU Modula-2 compiler. Therefore you will need to
install an earlier gcc on your machine. Known to work are gcc 3.2.3
(ports:lang/gcc32), gcc 3.3.4, 3.3.5 and 3.3.6 (ports:lang/gcc33).

Finally, @file{gmake} is required.

It is recommended that the same options are used to configure GNU
Modula-2 as those suggested in the ports collection.  A number of
options are not relevant for building GNU Modula-2 and these can be
safely omitted. The only two which apply directly to GNU Modula-2's
build process are @code{--with-system-zlib} and @code{--disable-nls}.

The example below assumes that @code{gcc-3.2.3} is installed (from the
ports collection) and the compiler is called @file{gcc32}. The example
assumes that the bash shell has been installed (as described above).

@example
  mkdir host-build
  cd host-build
  env CONFIG_SHELL=/usr/local/bin/bash CC=gcc32 ../gcc-@var{version}/configure
      --with-system-zlib --disable-nls --enable-languages=c,c++,gm2
  gmake
@end example

If you choose to install the generated compiler, you are urged to make
use of the name rewriting options of configure
(@code{--program-prefix} and @code{--program-suffix} work fine), and
to avoid possible conflicts with a port that installs it's own gcc,
you may also want to add @code{--host}. Here is the author of this
section's full configure line:

@example
  env CONFIG_SHELL=/usr/local/bin/bash CC=gcc32 ../gcc-@var{version}/configure
      --with-system-zlib --disable-nls --enable-languages=c,c++,gm2
      --program-prefix=m2 --host=i386-gm2bld-freebsd5.3
@end example

@node Licence, GNU Project, Obtaining, Top
@section Licence of GNU Modula-2

@include gpl.texi

@node GNU Project, Contributing, Licence, Top

@include gnu.texi

@node Contributing, Internals, GNU Project, Top
@section Contributing to GNU Modula-2

Please do. But also please read the GNU Emacs info under

@example
* Standards: (standards).       GNU coding standards.
* Intellectual Property::       Keeping Free Software Free
* Reading Non-Free Code::       Referring to Proprietary Programs
* Contributions::               Accepting Contributions
@end example

You might consider joining the GM2 Mailing list available via
a web brouser at

@uref{http://lists.nongnu.org/mailman/listinfo/gm2}
available via email: @uref{mail:gm2-subscribe@@nongnu.org} before you
start coding.

Many thanks and enjoy your coding!

@node Internals, EBNF, Contributing, Top
@chapter GNU Modula-2 Internals

This document is a small step in the long journey of documenting the GNU
Modula-2 compiler and how it integrates with GCC.
The document is still in it's infancy.

@menu
* History::                 How GNU Modula-2 came about.
* Overview::                Overview of the structure of GNU Modula-2.
* Integrating::             How the front end integrates with gcc.
* Passes::                  What gets processed during each pass.
* Run time::                Integration of run time modules with the compiler.
* Scope rules::             Clarification of some the scope rules.
* Done list::               Progression of the GNU Modula-2 project.
* To do list::              Outstanding issues.
@end menu

@node History, Overview, , Internals
@section History

The Modula-2 compiler sources have come from the m2f compiler which
runs under GNU/Linux. The original m2f compiler was written in Modula-2
and was bootstrapped via a modified version of p2c 1.20. The m2f
compiler was a recursive descent which generated quadruples as
intermediate code. It also used C style calling convention wherever
possible and utilized a C structure for dynamic arrays.

@node Overview, Integrating, History, Internals
@section Overview

GNU Modula-2 uses flex and a machine generated recursive descent
parser. Most of the source code is written in Modula-2 and
bootstrapping is achieved via a modified version of p2c-1.20.
The modified p2c-1.20 is contained in the GNU Modula-2 source
tree as are a number of other tools necessary for bootstrapping.

The changes to p2c include:

@itemize @bullet
@item
allowing @code{DEFINITION MODULE FOR "C"}
@item
fixes to abstract data types.
@item
making p2c understand the 2nd Edition dialect of Modula-2.
@item
introducing the @code{UNQUALIFIED} keyword.
@item
allowing varargs (@code{...}) inside @code{DEFINITION MODULE FOR "C"} modules.
@item
fixing the parser to understand commented @code{FORWARD} prototypes,
which are ignored by GNU Modula-2.
@item
fixes to the @code{CASE} syntax for 2nd Edition Modula-2.
@item
fixes to a @code{FOR} loop counting down to zero using a @code{CARDINAL}.
@item
introducing an initialization section for each implementation module.
@item
various porting improvements and general tidying up so that
it compiles with the gcc option @code{-Wall}.
@end itemize

GNU Modula-2 comes with PIM and ISO style libraries. The compiler
is built using PIM libraries and the source of the compiler
complies with the PIM dialect together with a few @code{C}
library calling extensions.

The compiler is a four pass compiler. The first pass tokenizes
the source code, creates scope and enumeration type symbols.
All tokens are placed into a dynamic buffer and subsequent passes reread
tokens and build types, quadruples and resolve hidden types.
@xref{Passes, , ,}.

GNU Modula-2 uses a technique of double book keeping @footnote{See the
excellent tutorial by Joachim Nadler translated by Tim Josling}.
@xref{Back end Access to Symbol Table, , , gcc}.
The front end builds a complete symbol table and a list of quadruples.
Each symbol is translated into a @code{gcc} equivalent after which
each quadruple is translated into a @code{gcc} @code{tree}.

@node Integrating, Passes, Overview, Internals
@section How the front end integrates with gcc

The M2Base and M2System
modules contain base types and system types respectively they
map onto GCC back-end data types.

@node Passes, Run time, Integrating, Internals
@section Passes

This section describes the general actions of each pass.  The key to
building up the symbol table correctly is to ensure that the symbols
are only created in the scope where they were declared.  This may seem
obvious (and easy) but it is complicated by two issues: firstly GNU
Modula-2 does not generate @code{.sym} files and so all imported
definition modules are parsed after the module is parsed; secondly the
import/export rules might mean that you can see and use a symbol
before it is declared in a completely different scope.

Here is a brief description of the lists of symbols maintained within
@code{DefImp} and @code{Module} symbols. It is these lists and actions
at each pass which manipulate these lists which solve the scoping and
visability of all symbols.

The @code{DefImp} symbol maintains the: @code{ExportQualified},
@code{ExportUnQualified}, @code{ExportRequest}, @code{IncludeList},
@code{ImportTree}, @code{ExportUndeclared},
@code{NeedToBeImplemented}, @code{LocalSymbols},
@code{EnumerationScopeList}, @code{Unresolved}, @code{ListOfVars},
@code{ListOfProcs} and @code{ListOfModules} lists.

The @code{Module} symbol maintains the: @code{LocalSymbols},
@code{ExportTree}, @code{IncludeList}, @code{ImportTree},
@code{ExportUndeclared}, @code{EnumerationScopeList},
@code{Unresolved}, @code{ListOfVars}, @code{ListOfProcs} and
@code{ListOfModules} lists.

Initially we discuss the lists which are common to both @code{DefImp}
and @code{Module} symbols, thereafter the lists peculiar to @code{DefImp}
and @code{Module} symbols are discussed.

The @code{ListOfVars}, @code{ListOfProcs} and @code{ListOfModules}
lists (common to both symbols) and simply contain a list of
variables, procedures and inner modules which are declared with this
definition/implementation or program module.

The @code{LocalSymbols} list (common to both symbols) contains a
complete list of symbols visible in this modules scope. The symbols in
this list may have been imported or exported from an inner module.

The @code{EnumerationScope} list (common to both symbols) defines all
visible enumeration symbols.  When this module is parsed the contents
of these enumeration types are marked as visible. Internally to GNU
Modula-2 these form a pseudo scope (rather like a @code{WITH}
statement which temporarily makes the fields of the record visible).

The @code{ExportUndeclared} list (common to both symbols) contains a
list of all symbols marked as exported but are as yet undeclared.

The @code{IncludeList} is (common to both symbols) contains a list of
all modules imported by the @code{IMPORT modulename ;} construct.

The @code{ImportTree} (common to both symbols) contains a tree of all
imported identifiers.

The @code{ExportQualified} and @code{ExportUnQualified} trees (only
present in the @code{DefImp} symbol) contain identifiers which are
marked as @code{EXPORT QUALIFIED} and @code{EXPORT UNQUALIFIED}
respectively.

The @code{NeedToBeImplemented} list (only present in the @code{DefImp}
symbol) and contains a list of all unresolved symbols which are exported.

@subsection Pass 1

During pass 1 each @code{DefImp} and @code{Module} symbol is
created. These are also placed into a list of outstanding sources to
be parsed.  The import and export lists are recorded and each object
imported is created in the module from whence it is exported and added
into the imported list of the current module. Any exported objects are
placed into the export list and marked as qualified or unqualified.

Inner module symbols are also created and their import and export
lists are also processed. An import list will result in a symbol being
fetched (or created if it does not exist) from the outer scope and
placed into the scope of the inner module. An export list results in
each symbol being fetched or created in the current inner scope and
added to the outer scope. If the symbol has not yet been declared then
it is added to the current modules @code{ExportUndeclared} list.

Procedure symbols are created (the parameters are parsed but no more
symbols are created). Enumerated types are created, hidden types in
the definition modules are marked as such. All the rest of the Modula-2
syntax is parsed but no symbols are created.

@subsection Pass 2

This section discuss varient records and their representation within
the front end @file{gm2/gm2-compiler/SymbolTable.mod}. Records and
varient records are declared in pass 2.

Ordinary records are represented by the following symbol table entries:

@example
TYPE
   this = RECORD
             foo: CARDINAL ;
             bar: CHAR ;
          END ;


    SymRecord [1]
   +-------------+
   | Name = this |        SymRecordField [2]
   | ListOfSons  |       +-------------------+
   |    +--------|       | Name = foo        |
   |    | [2] [3]|       | Parent = [1]      |
   +-------------+       | Type = [Cardinal] |
   | LocalSymbols|       +-------------------+
   | +-----------+
   | | foo bar   |
   | +-----------+
   +-------------+


    SymRecordField [3]
   +-------------------+
   | Name = bar        |
   | Parent = [1]      |
   | Type = [Cardinal] |
   +-------------------+
@end example

Whereas varient records are represented by the following symbol table
entries:

@example
TYPE
   this = RECORD
             CASE tag: CHAR OF
             'a': foo: CARDINAL ;
                  bar: CHAR |
             'b': an:  REAL |
             ELSE
             END
          END ;


    SymRecord [1]
   +-------------+
   | Name = this |        SymRecordField [2]
   | ListOfSons  |       +-------------------+
   |    +--------|       | Name = tag        |
   |    | [2] [3]|       | Parent = [1]      |
   |    +--------+       | Type = [CHAR]     |
   | LocalSymbols|       +-------------------+
   | +-----------+
   | | tag foo   |
   | | bar an    |
   | +-----------+
   +-------------+

    SymVarient [3]          SymFieldVarient [4]
   +-------------------+   +-------------------+
   | Parent = [1]      |   | Parent = [1]      |
   | ListOfSons        |   | ListOfSons        |  
   |    +--------------|   |    +--------------|
   |    | [4] [5]      |   |    | [6] [7]      |
   +-------------------+   +-------------------+

    SymFieldVarient [5]
   +-------------------+
   | Parent = [1]      |
   | ListOfSons        |  
   |    +--------------|
   |    | [8]          |
   +-------------------+

    SymRecordField [6]      SymRecordField [7]
   +-------------------+   +-------------------+
   | Name = foo        |   | Name = bar        |
   | Parent = [1]      |   | Parent = [1]      |
   | Type = [CARDINAL] |   | Type = [CHAR]     |
   +-------------------+   +-------------------+

    SymRecordField [8]
   +-------------------+
   | Name = an         |
   | Parent = [1]      |
   | Type = [REAL]     |
   +-------------------+
@end example

Varient records which have nested @code{CASE} statements are
represented by the following symbol table entries:

@example
TYPE
   this = RECORD
             CASE tag: CHAR OF
             'a': foo: CARDINAL ;
                  CASE bar: BOOLEAN OF
                  TRUE : bt: INTEGER |
                  FALSE: bf: CARDINAL
                  END |
             'b': an:  REAL |
             ELSE
             END
          END ;


    SymRecord [1]
   +-------------+
   | Name = this |        SymRecordField [2]
   | ListOfSons  |       +-------------------+
   |    +--------|       | Name = tag        |
   |    | [2] [3]|       | Parent = [1]      |
   |    +--------+       | Type = [CHAR]     |
   | LocalSymbols|       +-------------------+
   | +-----------+
   | | tag foo   |
   | | bar bt bf |
   | | an        |
   | +-----------+
   +-------------+

      ('1st CASE')            ('a' selector)
    SymVarient [3]          SymFieldVarient [4]
   +-------------------+   +-------------------+
   | Parent = [1]      |   | Parent = [1]      |
   | ListOfSons        |   | ListOfSons        |  
   |    +--------------|   |    +--------------|
   |    | [4] [5]      |   |    | [6] [7] [8]  |
   +-------------------+   +-------------------+

     ('b' selector)
    SymFieldVarient [5]
   +-------------------+
   | Parent = [1]      |
   | ListOfSons        |  
   |    +--------------|
   |    | [9]          |
   +-------------------+

    SymRecordField [6]      SymRecordField [7]
   +-------------------+   +-------------------+
   | Name = foo        |   | Name = bar        |
   | Parent = [1]      |   | Parent = [1]      |
   | Type = [CARDINAL] |   | Type = [BOOLEAN]  |
   +-------------------+   +-------------------+

      ('2nd CASE')
    SymVarient [8]
   +-------------------+
   | Parent = [1]      |
   | ListOfSons        |
   |    +--------------|
   |    | [12] [13]    |
   +-------------------+

    SymRecordField [9]
   +-------------------+
   | Name = an         |
   | Parent = [1]      |
   | Type = [REAL]     |
   +-------------------+

    SymRecordField [10]     SymRecordField [11]
   +-------------------+   +-------------------+
   | Name = bt         |   | Name = bf         |
   | Parent = [1]      |   | Parent = [1]      |
   | Type = [REAL]     |   | Type = [REAL]     |
   +-------------------+   +-------------------+

    (TRUE selector)            (FALSE selector)
    SymFieldVarient [12]    SymFieldVarient [13]
   +-------------------+   +-------------------+
   | Parent = [1]      |   | Parent = [1]      |
   | ListOfSons        |   | ListOfSons        |
   |    +--------------|   |    +--------------|
   |    | [10]         |   |    | [11]         |
   +-------------------+   +-------------------+
@end example

@subsection Pass 3

To do

@subsection Pass H

To do

@subsection Declaration ordering

This section gives a few stress testing examples and walks though
the mechanics of the passes and how the lists of symbols are created.

The first example contains a nested module in which an enumeration
type is created and exported. A procedure declared before the nested
module uses the enumeration type.

@example
MODULE colour ;

   PROCEDURE make (VAR c: colours) ;
   BEGIN
      c := yellow
   END make ;

   MODULE inner ;
   EXPORT colours ;

   TYPE
      colours = (red, blue, yellow, white) ;
   END inner ;

VAR
   g: colours
BEGIN
   make(g)
END colour.
@end example

@node Run time, Scope rules, Passes, Internals
@section Run time

This section describes how the GNU Modula-2 compiler interfaces with
the run time system.  The modules which must be common to all library
collections are @code{M2RTS} and @code{SYSTEM}. In the PIM library
collection an implementation of @code{M2RTS} and @code{SYSTEM} exist;
likewise in the ISO library and ULM library collection these modules
also exist.

The @code{M2RTS} module contains many of the base runtime features
required by the GNU Modula-2 compiler. For example @code{M2RTS}
contains the all the low level exception handling routines.  These
include exception handlers for run time range checks for:
assignments, increments, decrements, static array access,
dynamic array access, for loop begin,
for loop to, for loop increment, pointer via nil,
function without return, case value not specified and no exception.
The @code{M2RTS} module also contains the @code{HALT} and @code{LENGTH}
procedure. The ISO @code{SYSTEM} module contains a number of
@code{SHIFT} and @code{ROTATE} procedures which GNU Modula-2 will call
when wishing to shift and rotate multi-word set types.

@subsection Exception handling

This section describes how exception handling is implemented in GNU
Modula-2.  We begin by including a simple Modula-2 program which uses
exception handling and provide the same program written in C++.  The
compiler will translate the Modula-2 into the equivalent trees, just
like the C++ frontend.  This ensures that the Modula-2 frontend will
not do anything that the middle and backend cannot process, which
ensures that migration through the later gcc releases will be smooth.

Here is an example of Modula-2 using exception handling:

@example
MODULE except ;

FROM libc IMPORT printf ;
FROM Storage IMPORT ALLOCATE, DEALLOCATE ;

PROCEDURE fly ;
BEGIN
   printf("fly main body\n") ;
   IF 4 DIV ip^ = 4
   THEN
      printf("yes it worked\n")
   ELSE
      printf("no it failed\n")
   END
END fly ;

PROCEDURE tryFlying ;
BEGIN
   printf("tryFlying main body\n");  
   fly ;
EXCEPT
   printf("inside tryFlying exception routine\n") ;
   IF (ip#NIL) AND (ip^=0)
   THEN
      ip^ := 1 ;
      RETRY
   END
END tryFlying ;

PROCEDURE keepFlying ;
BEGIN
   printf("keepFlying main body\n") ;
   tryFlying ;
EXCEPT
   printf("inside keepFlying exception routine\n") ;
   IF ip=NIL
   THEN
      NEW(ip) ;
      ip^ := 0 ;
      RETRY
   END
END keepFlying ;

VAR
   ip: POINTER TO INTEGER ;
BEGIN
   ip := NIL ;
   keepFlying ;
   printf("all done\n")
END except.
@end example

Now the same program implemented in GNU C++

@example
#include <stdio.h>
#include <stdlib.h>

// a c++ example of Modula-2 exception handling

static int *ip = NULL;

void fly (void)
@{
  printf("fly main body\n") ;
  if (ip == NULL)
    throw;
  if (*ip == 0)
    throw;
  if (4 / (*ip) == 4)
    printf("yes it worked\n");
  else
    printf("no it failed\n");
@}

/*
 *   a C++ version of the Modula-2 example given in the ISO standard.
 */

void tryFlying (void)
@{
 again_tryFlying:
  printf("tryFlying main body\n");  
  try @{
    fly() ;
  @}
  catch (...) @{
    printf("inside tryFlying exception routine\n") ;
    if ((ip != NULL) && ((*ip) == 0)) @{
      *ip = 1;
      // retry
      goto again_tryFlying;
    @}
    printf("did't handle exception here so we will call the next exception routine\n") ;
    throw;  // unhandled therefore call previous exception handler
  @}
@}

void keepFlying (void)
@{
 again_keepFlying:
  printf("keepFlying main body\n") ;
  try @{
    tryFlying();
  @}
  catch (...) @{
    printf("inside keepFlying exception routine\n");
    if (ip == NULL) @{
      ip = (int *)malloc(sizeof(int));
      *ip = 0;
      goto again_keepFlying;
    @}
    throw;  // unhandled therefore call previous exception handler
  @}
@}

main ()
@{
  keepFlying();
  printf("all done\n");
@}
@end example

The equivalent program in GNU C is given below.  However the
use of @code{setjmp} and @code{longjmp} in creating an exception
handler mechanism is not used used by GNU C++ and GNU Java.
The GNU exception handling ABI uses @code{TRY_CATCH_EXPR} tree
nodes.  Thus GNU Modula-2 generates trees which model the C++
code above, rather than the C code shown below.  The code here
serves as a mental model (for readers who are familiar with C
but not of C++) of what is happening in the C++ code above.

@example
#include <setjmp.h>
#include <malloc.h>
#include <stdio.h>

typedef enum jmpstatus @{
  jmp_normal,
  jmp_retry,
  jmp_exception,
@} jmp_status;

struct setjmp_stack @{
  jmp_buf  env;
  struct setjmp_stack *next;
@} *head = NULL;

void pushsetjmp (void)
@{
  struct setjmp_stack *p = (struct setjmp_stack *)
                           malloc (sizeof (struct setjmp_stack));

  p->next = head;
  head = p;
@}

void exception (void)
@{
  printf("invoking exception handler\n");
  longjmp (head->env, jmp_exception);
@}

void retry (void)
@{
  printf("retry\n");
  longjmp (head->env, jmp_retry);
@}

void popsetjmp (void)
@{
  struct setjmp_stack *p = head;

  head = head->next;
  free (p);
@}

static int *ip = NULL;

void fly (void)
@{
  printf("fly main body\n");
  if (ip == NULL) @{
    printf("ip == NULL\n");
    exception();
  @}
  if ((*ip) == 0) @{
    printf("*ip == 0\n");
    exception();
  @}
  if ((4 / (*ip)) == 4)
    printf("yes it worked\n");
  else
    printf("no it failed\n");
@}

void tryFlying (void)
@{
  void tryFlying_m2_exception () @{
    printf("inside tryFlying exception routine\n");
    if ((ip != NULL) && ((*ip) == 0)) @{
      (*ip) = 1;
      retry();
    @}
  @}

  int t;

  pushsetjmp ();
  do @{
    t = setjmp (head->env);
  @} while (t == jmp_retry);

  if (t == jmp_exception) @{
    /* exception called */
    tryFlying_m2_exception ();
    /* exception has not been handled, invoke previous handler */
    printf("exception not handled here\n");
    popsetjmp();
    exception();
  @}

  printf("tryFlying main body\n");  
  fly();
  popsetjmp();
@}

void keepFlying (void)
@{
  void keepFlying_m2_exception () @{
    printf("inside keepFlying exception routine\n");
    if (ip == NULL) @{
      ip = (int *)malloc (sizeof (int));
      *ip = 0;
      retry();
    @}
  @}
  int t;

  pushsetjmp ();
  do @{
    t = setjmp (head->env);
  @} while (t == jmp_retry);
  
  if (t == jmp_exception) @{
    /* exception called */
    keepFlying_m2_exception ();
    /* exception has not been handled, invoke previous handler */
    popsetjmp();
    exception();
  @}
  printf("keepFlying main body\n");
  tryFlying();
  popsetjmp();
@}

main ()
@{
  keepFlying();
  printf("all done\n");
@}
@end example

@node Scope rules, Done list, Run time, Internals
@section Scope rules

This section describes my understanding of the Modula-2 scope rules
with respect to enumerated types.  If they are incorrect please
correct me by email @email{gaius@@gnu.org}. They also serve to
document the behaviour of GNU Modula-2 in these cirumstances.

In GNU Modula-2 the syntax for a type declaration is defined as:

@example
TypeDeclaration := Ident "=" Type =:

Type :=  SimpleType | ArrayType
          | RecordType          
          | SetType             
          | PointerType         
          | ProcedureType
      =:								   
									   
SimpleType := Qualident | Enumeration | SubrangeType =:

@end example

If the @code{TypeDeclaration} rule is satisfied by
@code{SimpleType} and @code{Qualident} ie:

@example
TYPE
   foo = bar ;
@end example

then @code{foo} is said to be equivalent to @code{bar}. Thus
variables, parameters and record fields declared with either type will
be compatible with each other.

If, however, the @code{TypeDeclaration} rule is satisfied by any
alternative clause @code{ArrayType}, @code{RecordType},
@code{SetType}, @code{PointerType}, @code{ProcedureType},
@code{Enumeration} or @code{SubrangeType} then in these cases a new
type is created which is distinct from all other types.  It will be
incompatible with all other user defined types.

It also has furthur consequences in that if bar was defined as an
enumerated type and foo is imported by another module then the
enumerated values are also visible in this module.

Consider the following modules:

@example
DEFINITION MODULE impc ;

TYPE
   C = (red, blue, green) ;

END impc.
@end example

@example
DEFINITION MODULE impb ;

IMPORT impc ;

TYPE
   C = impc.C ;

END impb.
@end example

@example
MODULE impa ;

FROM impb IMPORT C ;

VAR
   a: C ;
BEGIN
   a := red
END impa.
@end example

Here we see that the type @code{C} defined in module @code{impb} is
equivalent to the type @code{C} in module @code{impc}. Module
@code{impa} imports the type @code{C} from module @code{impb}
and at that point the enumeration values @code{red, blue, green}
(declared in module @code{impc}) are also visible.

The ISO Standand (p.41) in section 6.1.8 Import Lists states:

``Following the module heading, a module may have a sequence of import
lists. An import list includes a list of the identifiers that are to
be explicitly imported into the module. Explicit import of an
enumeration type identifier implicitly imports the enumeration
constant identifiers of the enumeration type.

Imported identifiers are introduced into the module, thus extending
their scope, but they have a defining occurrence that appears elsewhere.

Every kind of module may include a sequence of import lists, whether it
is a program module, a definition module, an implementation module or
a local module. In the case of any other kind of module, the imported
identifiers may be used in the block of the module.''

These statements confirm that the previous example is legal. But it
prompts the question, what about implicit imports othersise known
as qualified references.

In section 6.10 Implicit Import and Export of the ISO Modula-2 standard
it says:

``The set of identifiers that is imported or exported if an identifier
is explicitly imported or exported is called the (import and export)
closure of that identifier. Normally, the closure includes only the
explicitly imported or exported identifier. However, in the case
of the explicit import or export of an identifier of an enumeration
type, the closure also includes the identifiers of the values of that
type.

Implicit export applies to the identifiers that are exported (qualified)
from separate modules, by virtue of their being the subject of a
definition module, as well as to export from a local module that
uses an export list.''

Clearly this means that the following is legal:

@example
MODULE impd ;

IMPORT impc ;

VAR
   a: impc.C ;
BEGIN
   a := impc.red
END impd.
@end example

It also means that the following code is legal:

@example
MODULE impe ;

IMPORT impb ;

VAR
   a: impb.C ;
BEGIN
   a := impb.red
END impe.
@end example

And also this code is legal:

@example
MODULE impf ;

FROM impb IMPORT C ;

VAR
   a: C ;
BEGIN
   a := red
END impf.
@end example

And also that this code is legal:

@example
DEFINITION MODULE impg ;

IMPORT impc;

TYPE
   C = impc.C ;

END impg.
@end example

@example
IMPLEMENTATION MODULE impg ;

VAR
   t: C ;
BEGIN
   t := red
END impg.
@end example

Furthermore the following code is also legal as the new type, @code{C}
is declared and exported. Once exported all its enumerated fields
are also exported.

@example
DEFINITION MODULE imph;

IMPORT impc;
TYPE
   C = impc.C;

END imph.
@end example

Here we see that the current scope is populated with the enumeration
fields @code{red, blue, green} and also it is possible to reference
these values via a qualified identifier.

@example
IMPLEMENTATION MODULE imph;

IMPORT impc;

VAR
   a: C ;
   b: impc.C ;
BEGIN
   a := impc.red ;
   b := red ;
   a := b ;
   b := a
END imph.
@end example


@node Done list, To do list, Scope rules, Internals
@section Done list

What has been done:

@itemize @bullet

@item
Coroutines have been implemented. The @code{SYSTEM} module in
PIM-[234] now includes @code{TRANSFER}, @code{IOTRANSFER} and
@code{NEWPROCESS}. This module is available in the directory
@file{gm2/gm2-libs-coroutines}.  Users of this module also have to
link with GNU Pthreads @code{-lpth}.

@item
GM2 now works on the @code{opteron} 64 bit architecture. @code{make
gm2.paranoid} and @code{make check-gm2} pass.

@item
GM2 can now be built as a cross compiler to the MinGW platform under
GNU/Linux i386.

@item
GM2 now works on the @code{sparc} architecture. @code{make
gm2.paranoid} and @code{make check-gm2} pass.

@item
converted the regression test suite into the GNU dejagnu format.
In turn this can be grafted onto the GCC testsuite and can be
invoked as @code{make check-gm2}. GM2 should now pass all
regression tests.

@item
provided access to a few compiler built-in constants
and twenty seven built-in C functions.

@item
definition modules no longer have to @code{EXPORT QUALIFIED}
objects (as per PIM-3, PIM-4 and ISO).

@item
implemented ISO Modula-2 sets. Large sets are now allowed,
no limits imposed. The comparison operators
@code{# = <= >= < >} all behave as per ISO standard.
The obvious use for large sets is
@code{SET OF CHAR}. These work well with gdb once it has been
patched to understand Modula-2 sets.

@item
added @code{DEFINITION MODULE FOR "C"} method of linking
to C. Also added varargs handling in C definition modules.

@item
cpp can be run on definition and implementation modules.

@item
@samp{-fmakell} generates a temporary @code{Makefile} and
will build all dependant modules.

@item
compiler will bootstrap itself and three generations of the
compiler all produce the same code.

@item
the back end will generate code and assembly declarations for
modules containing global variables of all types. Procedure
prologue/epilogue is created.

@item
all loop constructs, if then else, case statements and expressions.

@item
nested module initialization.

@item
pointers, arrays, procedure calls, nested procedures.

@item
front end @samp{gm2} can now compile and link modules.

@item
the ability to insert gnu asm statements within GNU Modula-2.

@item
inbuilt functions, @code{SIZE}, @code{ADR}, @code{TSIZE}, @code{HIGH} etc

@item
block becomes and complex procedure parameters (unbounded arrays, strings).

@item
the front end now utilizes GCC tree constants and types and is no
longer tied to a 32 bit architecture, but reflects the 'configure'
target machine description.

@item
fixed all C compiler warnings when gcc compiles the p2c generated C
with -Wall.

@item
built a new parser which implements error recovery.

@item
added mechanism to invoke cpp to support conditional compilation if required.

@item
all @samp{Makefile}s are generated via @samp{./configure}

@end itemize

@node To do list, , Done list, Internals
@section To do list

What needs to be done:

@itemize @bullet

@item
ISO library implementation needs to be completed
(use FIO.mod as the underlying substructure).

@item
Easy access to other libraries using @code{-flibs=} so that libraries
can be added into the @file{/usr/.../gcc-lib/gm2/...} structure. ISO
language complience.

@item
implement many of the ISO built-in functions and procedures.

@item
investigate the use of collect2 during link/module initialization.

@item
improve documentation, specifically this document which should
also include a synopsis of 2nd Edition Modula-2.

@item
shared library access and generation

@item
modifying @file{SymbolTable.mod} and @file{M2Quads.mod} to
make all the data structures dynamic.

@item
testing and fixing bugs

@end itemize

@node EBNF, Libraries, Internals, Top
@chapter EBNF of GNU Modula-2

This chapter contains the EBNF of GNU Modula-2. This grammer
currently supports PIM and a number of ISO features. It is intended
to be altered to become fully complient with ISO in the future.
The rules here are automatically extracted from the grammer files in
GNU Modula-2 and serve to document the syntax of the extensions described
earlier and how they fit in with the base language.

Note that the first six productions are built into the lexical analysis
phase.

@include gm2-ebnf.texi

@node Libraries, Function Index, EBNF, Top
@chapter PIM and ISO library definitions

This chapter contains M2F, ULM, PIM and ISO libraries. The ISO
libraries are currently work in progress, many are incomplete and even
more have no implementation module. The M2F libraries are very mature
as the compiler uses them extensively. Permission has been kindly
granted by the authors of the ULM libraries to include them with GNU
Modula-2. These libraries (under the GNU GPL) were written at the
University of Ulm and were originally shipped with the ULM sparc
Modula-2 compiler.

@include gm2-libs.texi

@node Function Index, , Libraries, Top

@c @printindex cp
@printindex fn

@summarycontents
@contents
@bye
