\input texinfo 
@c -*-texinfo-*-

@code{makeinfo}
@code{texinfo-format-buffer}

@c
@c Design notes and documentation about GNU Modula-2
@c
@c
@c part 1 header
@c

@setfilename gm2.info
@settitle The GNU Modula-2 front end to GCC

@c
@c Part 2: Summary Description and Copyright
@c

@ifinfo
This is a short example of a complete Texinfo file.

Copyright @copyright{} 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
@end ifinfo

@c Part 3: Titlepage and Copyright
@c The titlepage segment does not appear in the Info file. 
@titlepage
@sp 10
@comment The title is printed in a large font.
@center @titlefont{The GNU Modula-2 front end to GCC}

@c The following two commands start the copyright page.
@page
@setchapternewpage odd
@sp 2
@center Gaius Mulley
@sp 3
@center Last updated 27 November 2003
@sp 10
@c @center @image{gm2/images/gnu,,1.5in}
@vskip 0pt plus 1filll
Copyright @copyright{} 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
@end titlepage

@c Part 4: `Top' Node and Master Menu

@ifinfo
@node Top, Using, (dir), (dir)
@top Introduction
@end ifinfo

@menu
* Using::            Using GNU Modula-2.
* Obtaining::        Obtaining GNU Modula-2.
* Internals::        GNU Modula-2 internals.
* Contributing::     Contributing to GNU Modula-2.
* EBNF::             EBNF of GNU Modula-2
* Libraries::        PIM and ISO library definitions.
* Function Index::   Index for all library functions.
@end menu

@node Using, Obtaining, Top, Top
@chapter Using GNU Modula-2

@menu
* About::                 What this document explains.
* History::               How GNU Modula-2 came about.
* Compiler options::      GNU Modula-2 compiler options.
* Example usage::         Example compile and link.
* Elementary data types:: Data types supported by GNU Modula-2.
* Standard procedures::   Permanently accessible base procedures.
* Extensions::            GNU Modula-2 language extensions.
* Interface to C::        Interfacing GNU Modula-2 to C.
* h2def::                 Semi-automatic translation of C header files.
* Assembly language::     Interface to assembly language.
* Built-ins::             Accessing GNU Modula-2 Built-ins.
@end menu

@node About, Compiler options, , Using
@section About

This document contains the user and design issues relevant to the
Modula-2 front end to gcc. The GNU Modula-2 compiler is based on the
language as defined in 'Programming in Modula-2' 2nd Edition, Springer
Verlag, 1982, 1983 by Niklaus Wirth (PIM2), 'Programming in
Modula-2', 3rd Corrected Edition, Springer Verlag, 1985 (PIM3) and
'Programming in Modula-2', 4th Edition, Springer Verlag, 1988 (PIM4).
It also includes ISO M2 features and GNU M2 extensions.

There are currently two sets of libraries. The 'Programming in Modula-2'
libraries are reasonably complete whereas the ISO libraries are still
in development. However both sets of definition modules are contained
within this document.

@node Compiler options, Example usage, About, Using
@section Compiler options

This section describe the compiler options specific to GNU Modula-2 for
generic flags details see
@xref{Invoking GCC, , ,gcc}.

@table @code

@item -Wmakeall
generate a temporary makefile and build all dependent modules and
link.

@item -Wbounds
generate code to check the bounds of subranges and array indexes.

@item -Wreturn
generate code to check that functions always exit with a @samp{RETURN} and do not
fall out at the end.

@item -v
display all calls to subsidiary programs, such as the C preprocessor,
the GNU Modula-2 linker and compiler.

@item -Wstatistics
generates quadruple information: number of quadruples generated,
number of quadruples remaining after optimisation.

@item -Wstudents
checks for bad programming style. This option is aimed at new users of
Modula-2 in that it checks for situations which might cause confusion
and thus mistakes.  It checks whether variables of the same name are
declared in different scopes and whether variables look like keywords.
Experienced users might find this option too aggressive.

@item -Wpedantic
forces the compiler to reject nested @samp{WITH} statements
referencing the same record type.  Does not allow multiple imports of
the same item from a module.  It also checks that: procedure variables
are written to before being read; variables are not only written to
but read from; variables are declared and used.  If the compiler
encounters a variable being read before written it will terminate with
a message.  It will check that @samp{FOR} loop indices are not used
outside the end of this loop without being reset.

@item -Wmakelist
this option is only applicable when linking a program module.  The
compiler will generate a @file{modulename.lst} file which contains a
list indicating the initialisation order of all modules which are to
be linked. The actual link does not occur.  The GNU Modula-2 linker
scans all @code{IMPORT}s, generates a list of dependencies and
produces an ordered list for initialisation. It will probably get the
order wrong if your project has cyclic dependencies, but the
@file{.lst} file is plain text and can be modified if required.  Once
the @file{.lst} file is created it can be used by the compiler to link
your project via the @samp{-Wuselist} option.  It has no effect if the
@samp{-c} option is present.

@item -Wuselist
providing @samp{gm2} has been told to link the program module this
option uses the file @file{modulename.lst} for the initialisation
order of modules.

@item -Wcpp
do preprocess the source with @samp{cpp -lang-asm -traditional-cpp}
For further details about these options see @xref{Invocation, , ,cpp}.
If @samp{-Wcpp} is supplied then all definition modules and
implementation modules which are parsed will be preprocessed by
@samp{cpp}.

@item -Wiso
turn on ISO standard features. Currently this enables the ISO
@code{SYSTEM} module and alters the default library search path so
that the ISO libraries are searched before the PIM libraries.

@item -Wextended-opaque
allows opaque types to be implemented as any type. This is a GNU
Modula-2 extension and it requires that the implementation module
defining the opaque type is available so that it can be resolved when
compiling the module which imports the opaque type.

@item -Wsources
displays the path to the source of each module.
@end table

@node Example usage, Elementary data types, Compiler options, Using
@section Example compile and link

This section describes how to compiler and link a simple hello world
program.  It provides a few examples of using the different options
mentioned in @xref{Compiler options, , ,gm2}.  Assuming that you have
a file called @file{hello.mod} in your current directory which
contains:

@example
MODULE hello ;

FROM StrIO IMPORT WriteString, WriteLn ;

BEGIN
   WriteString('hello world') ; WriteLn
END hello.
@end example

You should be able to compile it by: @samp{gm2 -c -g -I. hello.mod}
and link via: @samp{gm2 -g -I. hello.mod}.  The result should be an
@samp{a.out} file created in your directory.  @footnote{The @samp{-v}
displays the subprocesses initiated by @samp{gm2} which can be useful
when trouble shooting.}

Alternatively it may be compiled by:

@samp{gm2 -g -I. -Wmakeall hello.mod}

@node Elementary data types, Standard procedures, Example usage, Using
@section Elementary data types

This section describes the elementary data types supported by GNU
Modula-2. It also describes the relationship between these data types
and the equivalent C data types.

The following data types are supported: @code{INTEGER},
@code{LONGINT}, @code{CARDINAL}, @code{LONGCARD}, @code{BOOLEAN},
@code{REAL}, @code{LONGREAL}, @code{SHORTREAL}, and @code{CHAR}.

An equivalence table is given below:

@example
GNU Modula-2              GNU C
======================================
INTEGER                   int
LONGINT                   long int
CARDINAL                  unsigned int
LONGCARD                  long unsigned int
BOOLEAN                   int
REAL                      double
LONGREAL                  long double
SHORTREAL                 float
CHAR                      char
@end example

@node Standard procedures, Extensions, Elementary data types, Using
@section Permanently accessible base procedures.

This section describes the procedures and functions which are
always visible.

@subsection Standard procedures and functions common to PIM and ISO

The following procedures are implemented and conform with Programming
in Modula-2 and ISO Modula-2: @code{NEW}, @code{DISPOSE}, @code{INC},
@code{DEC}, @code{INCL}, @code{EXCL} and @code{HALT}.  The standard
functions are: @code{HIGH}, @code{CAP}, @code{ABS}, @code{ODD},
@code{VAL}, @code{CHR}, @code{MIN}, @code{MAX}. All these functions
and procedures (except @code{HALT}, @code{NEW}, @code{DISPOSE} and,
under non constant conditions, @code{LENGTH}) generate in-line code
for efficiency.

@example

(*
   NEW - the procedure NEW is replaced by:
         ALLOCATE(p, TSIZE(p^)) ;
         The user is expected to import the procedure ALLOCATE
         (normally found in the module, Storage.)

         In:  a variable p: of any pointer type.
         Out: variable, p, is set to some allocated memory
              which is large enough to hold all the contents of p^.
*)

@findex NEW
PROCEDURE NEW (VAR p:<any pointer type>) ;
@end example

@example

(*
   DISPOSE - the procedure DISPOSE is replaced by:
             DEALLOCATE(p, TSIZE(p^)) ;
             The user is expected to import the procedure DEALLOCATE
             (normally found in the module, Storage.)

             In:  a variable p: of any pointer type which has been
                  initialized by a call to NEW.
             Out: the area of memory
                  holding p^ is returned to the system.
                  Note that the underlying procedure DEALLOCATE
                  procedure in module Storage will assign p to NIL.
*)

@findex DISPOSE
PROCEDURE DISPOSE (VAR p:<any pointer type>) ;
@end example

@example

(*
   INC - can take one or two parameters. If suppied with one
         parameter it adds 1 to the variable, v.
         If two parameters are supplied then the value, a, is
         added to, v.
*)

@findex INC
PROCEDURE INC (VAR v: <any base type>; [a: <any base type> = 1]) ;
@end example

@example

(*
   DEC - can take one or two parameters. If suppied with one
         parameter it subtracts 1 from the variable, v.
         If two parameters are supplied then the value, a, is
         subtracted from, v.
*)

@findex DEC
PROCEDURE DEC (VAR v: <any base type>; [a: <any base type> = 1]) ;
@end example

@example

(*
   INCL - includes bit element, e, to a set type, s.
*)

@findex INCL
PROCEDURE INCL (VAR s: <any set type>; e: <element of set type s>) ;
@end example

@example

(*
   EXCL - excludes bit element, e, from a set type, s.
*)

@findex EXCL
PROCEDURE EXCL (VAR s: <any set type>; e: <element of set type s>) ;
@end example

@example

(*
   HALT - will call the HALT procedure inside the module M2RTS.
          Users can replace M2RTS.
*)

@findex HALT
PROCEDURE HALT ;

@end example

The following define the standard set of functions which conform with Programming
in Modula-2 and ISO Modula-2.

@example

(*
   HIGH - returns the last accessible indice of an parameter declared as
          ARRAY OF CHAR. Thus

          PROCEDURE foo (a: ARRAY OF CHAR) ;
          VAR
             c: CARDINAL ;
          BEGIN
             c := HIGH(a)
          END foo ;

          BEGIN
             foo('hello')
          END

          will cause the local variable, c, to contain the value 4
*)

@findex HIGH
PROCEDURE HIGH (a: ARRAY OF CHAR) : CARDINAL ;
@end example

@example

(*
   CAP - returns the capital of character, ch, providing
         ch lies within the range 'a'..'z'. Otherwise, ch,
         is returned unaltered.
*)

PROCEDURE CAP (ch: CHAR) : CHAR ;

@end example
@c @code{CAP}, @code{ABS}, @code{VAL},
@c @code{CHR}, @code{ODD}, @code{MIN}, @code{MAX}

@subsection ISO specific standard procedures and functions

The standard function @code{LENGTH} is specific to ISO Modula-2 and
is defined as:

@example

(*
   LENGTH - returns the length of string, a.
*)

@findex LENGTH
PROCEDURE LENGTH (a: ARRAY OF CHAR) : CARDINAL ;

@end example

This function is evaluated at compile time, providing that string
@code{a} is a constant. If @code{a} cannot be evaluated then a call is
made to @code{M2RTS.Length}.

@c complete other ISO functions

@node Extensions, Interface to C, Standard procedures, Using
@section GNU Modula-2 language extensions

This section introduces the GNU Modula-2 language extensions.
The GNU Modula-2 compiler allows abstract data types to be any type,
not just restricted to a pointer type providing the
@samp{-Wextended-opaque} option is supplied
@xref{Compiler options, , ,gm2}.

Declarations can be made in any order, whether they are
types, constants, procedures, nested modules or variables
(see @xref{Passes, , ,}.)

GNU Modula-2 also allows programmers to interface to @code{C} and
assembly language.

The preprocessor @samp{cpp} can be invoked via the @samp{-Wcpp}
command line option. This in turn invokes @samp{cpp} with the
following arguments @samp{-traditional -lang-asm}.  These options
preserve comments and all quotations.  @samp{gm2} treats a @samp{#}
character in the first column as a preprocessor directive.

For example here is a module which calls @code{FatalError}
twice via the macro @code{ERROR}.

@example
MODULE cpp ;

FROM SYSTEM IMPORT ADR, SIZE ;
FROM libc IMPORT exit, printf, malloc ;

PROCEDURE FatalError (a, file: ARRAY OF CHAR;
                         line: CARDINAL) ;
VAR
   r: INTEGER ;
BEGIN
   r := printf("%s:%d:fatal error, %s\n",
               ADR(file), line, ADR(a)) ;
   exit(1)
END FatalError ;

#define ERROR(X)  FatalError(X, __FILE__, __LINE__)

VAR
   pc: POINTER TO CARDINAL;
BEGIN
   pc := malloc(SIZE(CARDINAL)) ;
   IF pc=NIL
   THEN
      ERROR('out of memory')
   END
END cpp.
@end example

@subsection Optional procedure parameter

GNU Modula-2 allows the last parameter to a procedure or function
parameter to be optional. For example in the ISO library
@file{COROUTINES.def} the procedure @code{NEWCOROUTINE} is defined as
having an optional fifth argument (@code{initProtection}) which, if
absent, is automatically replaced by @code{NIL}.

@example
@findex NEWCOROUTINE
PROCEDURE NEWCOROUTINE (procBody: PROC; workspace: SYSTEM.ADDRESS;
                        size: CARDINAL; VAR cr: COROUTINE;
                        [initProtection: PROTECTION = NIL]);

  (* Creates a new coroutine whose body is given by procBody,
     and returns the identity of the coroutine in cr.
     workspace is a pointer to the work space allocated to
     the coroutine; size specifies the size of this workspace
     in terms of SYSTEM.LOC.

     The optional fifth argument may contain a single parameter
     which specifies the initial protection level of the coroutine.
  *)
@end example

The implementation module @file{COROUTINES.mod} implements this
procedure using the following syntax:

@example
PROCEDURE NEWCOROUTINE (procBody: PROC; workspace: SYSTEM.ADDRESS;
                        size: CARDINAL; VAR cr: COROUTINE;
                        [initProtection: PROTECTION]);
BEGIN
   
END NEWCOROUTINE ;
@end example

Note that it is illegal for this declaration to contain an initialiser
value for @code{initProtection}. However it is necessary to surround
this parameter with the brackets @code{[} and @code{]}. This serves to
remind the programmer that the last parameter was declared as optional
in the definition module.

Local procedures can be declared to have an optional final parameter
in which case the initializer is mandatory in the implementation or
program module.

@node Interface to C, h2def, Extensions, Using
@section Interfacing GNU Modula-2 to C

The GNU Modula-2 compiler tries to use the C calling convention wherever
possible however some parameters have no C equivalent and
thus a language specific method is used. For example unbounded
arrays are passed as a @code{struct void *address, unsigned int high}
and the contents of these arrays are copied by callee functions
when they are declared as non @code{VAR} parameters.
The @code{VAR} equivalent unbounded array parameters need no copy,
but still use the @code{struct} representation.

The recommended method of interfacing GNU Modula-2 to C is by telling
the definition module that the implementation is in the C language.
This is achieved by using the tokens @code{DEFINITION MODULE FOR "C"}.
Here is an example which can be found in the source tree
@file{gcc-@var{version}/gcc/gm2/examples/callingC/libprintf.def}

@example
DEFINITION MODULE FOR "C" libprintf ;

EXPORT UNQUALIFIED printf ;

PROCEDURE printf (a: ARRAY OF CHAR; ...) ;

END libprintf.
@end example

the @code{UNQUALIFIED} keyword in the definition module informs
GNU Modula-2 not to prefix the module name to exported references
in the object file.

The @code{printf} declaration states that the first parameter semantically
matches @code{ARRAY OF CHAR} but since the module is for the C language
it will be mapped onto @code{char *}. The token @code{...} indicates
a variable number of arguments (varargs) and all parameters passed
here are mapped onto their C equivalents. Arrays and constant strings
are passed as pointers.

The hello world program can be rewritten as:

@example
MODULE hello ;

FROM libprintf IMPORT printf ;

BEGIN
   printf("hello world\n")
END hello.
@end example

and it can be compiled by:

@samp{gm2 -Wmakeall -g -I. hello.mod -lc}

In reality the @samp{-lc} is redundant as libc is always included in the
linking process. It is shown here to emphasize that the C library or
object file containing @code{printf} must be present.

@node h2def, Assembly language, Interface to C, Using
@section Semi-automatic translation of C header files

The tool @samp{h2def} can be used to semi-automatically generate
@code{DEFINITION MODULE FOR "C"} modules. The tool takes as input a C
header file and generates as output a corresponding textual definition
module.  While the tool will not automatically translate complex C
header files it will generate definition modules for simple header
files.

For example consider the following excerpt from the
header file (@file{vga.h}):

@example
/* blit flags */
#define HAVE_BITBLIT 1
#define HAVE_FILLBLIT 2
#define HAVE_IMAGEBLIT 4
#define HAVE_HLINELISTBLIT 8
#define HAVE_BLITWAIT 16

    typedef struct @{
	int width;
	int height;
	int bytesperpixel;
	int colors;
	int linewidth;		/* scanline width in bytes */
	int maxlogicalwidth;	/* maximum logical scanline width */
	int startaddressrange;	/* changeable bits set */
	int maxpixels;		/* video memory / bytesperpixel */
	int haveblit;		/* mask of blit functions available */
	int flags;		/* other flags */

	/* Extended fields: */

	int chiptype;		/* Chiptype detected */
	int memory;		/* videomemory in KB */
	int linewidth_unit;	/* Use only a multiple of this as parameter for set_logicalwidth and
				   set_displaystart */
	char *linear_aperture;	/* points to mmap secondary mem aperture of card (NULL if unavailable) */
	int aperture_size;	/* size of aperture in KB if size>=videomemory. 0 if unavail */
	void (*set_aperture_page) (int page);
	/* if aperture_size<videomemory select a memory page */
	void *extensions;	/* points to copy of eeprom for mach32 */
	/* depends from actual driver/chiptype.. etc. */
    @} vga_modeinfo;

    extern vga_modeinfo *vga_getmodeinfo(int mode);
    extern int vga_getdefaultmode(void);
    extern int vga_getcurrentmode(void);
    extern int vga_getcurrentchipset(void);
    extern char *vga_getmodename(int mode);
@end example

Using the following command line @code{h2def vga.h} will generate
the module below:

@example
DEFINITION MODULE FOR "C" vga ;

CONST
     HAVE_BITBLIT =  1 ;
     HAVE_FILLBLIT =  2 ;
     HAVE_IMAGEBLIT =  4 ;
     HAVE_HLINELISTBLIT =  8 ;
     HAVE_BLITWAIT =  16 ;

TYPE
     vga_modeinfo =   RECORD
                         width: INTEGER ;
                         height: INTEGER ;
                         bytesperpixel: INTEGER ;
                         colors: INTEGER ;
                         linewidth: INTEGER ;
                         maxlogicalwidth: INTEGER ;
                         startaddressrange: INTEGER ;
                         maxpixels: INTEGER ;
                         haveblit: INTEGER ;
                         flags: INTEGER ;
                         chiptype: INTEGER ;
                         memory: INTEGER ;
                         linewidth_unit: INTEGER ;
                         linear_aperture: POINTER TO CHAR ;
                         aperture_size: INTEGER ;
                         set_aperture_page:  PROCEDURE (INTEGER) ;
                         extensions: ADDRESS ;
                      END ;
    
 PROCEDURE vga_getmodeinfo (mode: INTEGER) : ADDRESS ;
 PROCEDURE vga_getdefaultmode () : INTEGER ;
 PROCEDURE vga_getcurrentmode () : INTEGER ;
 PROCEDURE vga_getcurrentchipset () : INTEGER ;
 PROCEDURE vga_getmodename (mode: INTEGER) : ADDRESS ;

END vga.
@end example

The main limitation of @code{h2def} is in the preprocessing handling.
It does not understand the C preprocessor token constructor directives
@code{#} and @code{##}. Also it will not combine successive string
tokens.

Support for the @code{#define} mechanism is limited. Initially the
macro is parsed to check whether it is a constant expression.  If it
fails it is reassigned as a macro definition.  A macro which contains
C statement code cannot be translated into a definition module. These
macros and all dependents are poisoned and are not translated.
At present it does not understand macros with arguments.

The @samp{-I} option to @code{h2def} allows include directories to be
specified and the @samp{-C} option states that a macro definition must
be computed at compile time.  For example consider the following
header file called @code{ifdef.h}:

@example
#if !defined(FOOBAR)
# define FOOBAR
# define MAXIMUM 1000
#else
# define MAXIMUM 2000
#endif
@end example

which if processed by @code{h2def -CFOOBAR ifdef.h} yields the following code:

@example
DEFINITION MODULE FOR "C" ifdef ;

# if (!(defined(FOOBAR)))
CONST
   MAXIMUM = 1000 ;
# else
   MAXIMUM = 2000 ;
# endif
     
END ifdef.
@end example

The @samp{-a} option provides a method whereby the C parameter
construct @code{sometype *foo} is translated in Modula-2 as
@code{foo: ARRAY OF sometype}.

Normally output for @code{h2def} will require some manual
intervention. Some header files need more help than others, for
example the GNU/Linux svga header file @code{vga.h} requires a little
help whereas the GNU pthread file @code{pthread.h} requires more.
Nevertheless the effort required is considerably less than writing the
modules by hand.

The @samp{-e} option will emit an error message if a C syntax error is
encountered. The @samp{-p} option generate a comment for every
occurance of an object which cannot be translated into Modula-2.

@node Assembly language, Built-ins, h2def, Using
@section Interface to assembly language

The interface for GNU Modula-2 to assembly language is almost
identical to GNU C.  The only alterations are that the keywords
@code{asm} and @code{volatile} are in capitals, following the Modula-2
convention.

A simple, but highly non optimal, example is given below. Here we want
to add the two @code{CARDINAL}s @code{foo} and @code{bar} together and
return the result.

@example
PROCEDURE Example (foo, bar: CARDINAL) : CARDINAL ;
VAR
   myout: CARDINAL ;
BEGIN
   ASM VOLATILE ("movl %1,%%eax; addl %2,%%eax; movl %%eax,%0"
      : "=g" (myout)           (* outputs *)
      : "g" (foo), "g" (bar)   (* inputs  *)
      : "eax") ;               (* we trash *)
   RETURN( myout )
END Example ;
@end example

For a full description of this interface we refer the reader to the GNU C manual.

@xref{Extended Asm, ,Extensions to the C Language Family,gcc}.

@node Built-ins, , Assembly language, Using
@section Accessing GNU Modula-2 Built-ins

This section describes the built-in constants and functions defined in
GNU Modula-2.  The following compiler constants can be accessed using
the @code{__ATTRIBUTE__} @code{__BUILTIN__} keywords. These are not
part of the Modula-2 language and they may differ depending upon the
target architecture but they provide a method whereby common
libraries can interface to a different underlying architecture.

The built-in constants are: @code{BITS_PER_UNIT}, @code{BITS_PER_WORD},
@code{BITS_PER_CHAR} and @code{UNITS_PER_WORD}. They are integrated into
GNU Modula-2 by an extension to the @code{ConstFactor} rule:

@example
ConstFactor := ConstQualidentOrSet | Number | ConstString |
               "(" ConstExpression ")" | "NOT" ConstFactor |
               ConstAttribute =:

ConstAttribute := "__ATTRIBUTE__" "__BUILTIN__" "(" "(" Ident ")" ")" =:
@end example

Here is an example taken from the ISO library @code{SYSTEM.def}:

@example
CONST
   BITSPERLOC    = __ATTRIBUTE__ __BUILTIN__ ((BITS_PER_UNIT)) ;
   LOCSPERWORD   = __ATTRIBUTE__ __BUILTIN__ ((UNITS_PER_WORD)) ;
@end example

Built-in functions are transparent to the end user. All built-in
functions are declared in @code{DEFINITION MODULE}s and are imported
as and when required.  Built-in functions are declared in definition
modules by using the @code{__BUILTIN__} keyword. Here is a section of
the ISO library @code{LongMath.def} which demonstrates this feature.

@example
PROCEDURE __BUILTIN__ sqrt (x: LONGREAL): LONGREAL;
  (* Returns the square root of x *)
@end example

This indicates that the function @code{sqrt} will be implemented using
the gcc built-in maths library. If gcc cannot utilise the built-in
function (for example if the programmer requested the address of
@code{sqrt}) then code is generated to call the alternative function
implemented in the @code{IMPLEMENTATION} @code{MODULE}.

Sometimes a function exported from the @code{DEFINITION} @code{MODULE}
will have a different name from the built-in function within gcc. In such
cases the mapping between the GNU Modula-2 function name and the gcc name
is expressed using the keywords @code{__ATTRIBUTE__} @code{__BUILTIN__}
@code{((Ident))}. For example the function @code{sqrt} in @code{LongMath.def}
maps onto the gcc built-in function @code{sqrtl} and this is expressed as:

@example
PROCEDURE __ATTRIBUTE__ __BUILTIN__ ((sqrtl)) sqrt
                                    (x: LONGREAL) : LONGREAL;
  (* Returns the positive square root of x *)
@end example

The following module @code{Builtins.def} enumerates the list of built-in functions
which can be accessed in GNU Modula-2. It also serves to define the parameter
and return value for each function:

@example
 DEFINITION MODULE Builtins ;

FROM SYSTEM IMPORT ADDRESS ;

PROCEDURE __BUILTIN__ sinf (x: SHORTREAL) : SHORTREAL ;
PROCEDURE __BUILTIN__ sin (x: REAL) : REAL ;
PROCEDURE __BUILTIN__ sinl (x: LONGREAL) : LONGREAL ;

PROCEDURE __BUILTIN__ cosf (x: SHORTREAL) : SHORTREAL ;
PROCEDURE __BUILTIN__ cos (x: REAL) : REAL ;
PROCEDURE __BUILTIN__ cosl (x: LONGREAL) : LONGREAL ;

PROCEDURE __BUILTIN__ sqrtf (x: SHORTREAL) : SHORTREAL ;
PROCEDURE __BUILTIN__ sqrt (x: REAL) : REAL ;
PROCEDURE __BUILTIN__ sqrtl (x: LONGREAL) : LONGREAL ;

PROCEDURE __BUILTIN__ fabsf (x: SHORTREAL) : SHORTREAL ;
PROCEDURE __BUILTIN__ fabs (x: REAL) : REAL ;
PROCEDURE __BUILTIN__ fabsl (x: LONGREAL) : LONGREAL ;

PROCEDURE __BUILTIN__ alloca (i: CARDINAL) : ADDRESS ;
PROCEDURE __BUILTIN__ memcpy (dest, src: ADDRESS; n: CARDINAL) : ADDRESS ;
PROCEDURE __BUILTIN__ index (s: ADDRESS; c: INTEGER) : ADDRESS ;
PROCEDURE __BUILTIN__ rindex (s: ADDRESS; c: INTEGER) : ADDRESS ;
PROCEDURE __BUILTIN__ memcmp (s1, s2: ADDRESS; n: CARDINAL) : INTEGER ;
PROCEDURE __BUILTIN__ memset (s: ADDRESS; c: INTEGER; n: CARDINAL) : ADDRESS ;
PROCEDURE __BUILTIN__ strcat (dest, src: ADDRESS) : ADDRESS ;
PROCEDURE __BUILTIN__ strncat (dest, src: ADDRESS; n: CARDINAL) : ADDRESS ;
PROCEDURE __BUILTIN__ strcpy (dest, src: ADDRESS) : ADDRESS ;
PROCEDURE __BUILTIN__ strncpy (dest, src: ADDRESS; n: CARDINAL) : ADDRESS ;
PROCEDURE __BUILTIN__ strcmp (s1, s2: ADDRESS) : INTEGER ;
PROCEDURE __BUILTIN__ strncmp (s1, s2: ADDRESS; n: CARDINAL) : INTEGER ;
PROCEDURE __BUILTIN__ strlen (s: ADDRESS) : INTEGER ;
PROCEDURE __BUILTIN__ strstr (haystack, needle: ADDRESS) : ADDRESS ;
PROCEDURE __BUILTIN__ strpbrk (s, accept: ADDRESS) : ADDRESS ;
PROCEDURE __BUILTIN__ strspn (s, accept: ADDRESS) : CARDINAL ;
PROCEDURE __BUILTIN__ strcspn (s, accept: ADDRESS) : CARDINAL ;
PROCEDURE __BUILTIN__ strchr (s: ADDRESS; c: INTEGER) : ADDRESS ;
PROCEDURE __BUILTIN__ strrchr (s: ADDRESS; c: INTEGER) : ADDRESS ;

END Builtins.
@end example

Although this module exists and will result in the generation of
inline code if optimization flags are passed to GNU Modula-2, users
are advised to utilize the same functions from more generic libraries.
The built-in mechanism will be applied to these generic
libraries where appropriate. Note for the mathematical routines to
be inlined you need to specify the @samp{-ffast-math -O} options.

@node Obtaining, Contributing, Using, Top
@chapter Obtaining GNU Modula-2.

@section Warning

This code is currently in development and it is not yet complete.
Nevertheless the compiler is sufficiently stable to support itself on
Debian GNU/Linux ix86 systems. The PIM libraries are complete but the
ISO libraries and ISO language features are still in development.
Patches and development volunteers highly welcome! 
@xref{Contributing, Contributing to GNU Modula-2}.

@section Getting GNU Modula-2

Currently you have several options, you could either download a source
tar ball from @uref{ftp://floppsie.comp.glam.ac.uk/pub/c} and
search for files which look like @file{gm2+gcc-@var{version}.tar.gz}.
Prebuilt binary packages are also available at
@uref{http://www.unet.univie.ac.at/~a9406973/modula2/downl.html}.

Alternatively the development sources can be downloaded via CVS.
Please be aware that as gm2 is in
development it might fail to compile with the current version of gcc.

@section Development sources via CVS

To get the latest sources to GNU Modula-2 type the following:

@example
export CVSROOT=:pserver:anoncvs@@floppsie.comp.glam.ac.uk:/usr/src/cvs
cvs login
cvs -z9 checkout GM2
@end example

(note the capital GM2 in the checkout, GM2 is the project module within cvs).
This will checkout a copy of GNU Modula-2 into one subdirectory:
@file{gm2}.

This version of GNU Modula-2 needs to be placed inside the GCC source
tree in the position gcc-@var{version}/gcc before GNU Modula-2 can be
built. Please check the GNU Modula-2 homepage
@uref{http://floppsie.comp.glam.ac.uk/Glamorgan/gaius/GNUModula-2.html}
for details about which GCC releases are supported by GNU Modula-2.

Once you have downloaded the correct GCC release from
@uref{http://gcc.gnu.org} or a mirror site you should unpack the GCC archive.
Assuming that both the @file{gcc-@var{version}} and @file{gm2} dicectories
are at the same level, you can graft @file{gm2} onto @file{gcc-@var{version}} by:

@example   
mv gm2 gcc-@var{version}/gcc
@end example

@section Building GNU Modula-2

To build GNU Modula-2 type:

@example
mkdir host-build
cd host-build
../gcc-@var{version}/configure
make
cd ..
@end example

Installing GNU Modula-2 is achieved by:

@example
su
cd host-build
make install
exit
@end example

Now you should be able to perform:

@example
cd gcc-@var{version}/gcc/gm2/examples/hello
make
@end example

which should result in creating an @file{a.out} for the infamous hello
world example.

@section Stress testing GM2

Currently there are two automated methods to test GNU Modula-2.
The first method is @samp{make gm2.paranoid} in which @code{gm2}
builds itself and finally the test runs both parent and child
generations of the compiler and compares the output. Be warned
that this test can take some time to execute.
This test is invoked by:

@example
cd host-build/gcc ; make gm2.paranoid
@end example

The second method used to test GNU Modula-2 is to run the regression
test suite.  The GNU Modula-2 regression test suite is available for
download.  To install and run the GNU Modula-2 regression suite you
need to have installed the @file{dejagnu} and @file{expect}
packages. You also need to have downloaded the gcc testsuite and
grafted it onto the GCC source tree. Finally you need to graft the GNU
Modula-2 testsuite onto the gcc testsuite. To ease this process there
are pre grafted versions available from
@uref{ftp://floppsie.comp.glam.ac.uk/pub/c}.

Assuming that the root of the GCC source tree is in the current
working directory you can use the following commands to install
the test suite:

@example
export CVSROOT=:pserver:anoncvs@@floppsie.comp.glam.ac.uk:/usr/src/cvs
cvs login
cvs -z9 checkout testsuite
tar cf - testsuite | ( cd gcc-@var{version}/gcc ; tar xf - )
@end example

Do not simply move the directory @file{testsuite} into
@file{gcc-@var{version}/gcc} as the GNU Modula-2 regression
tests have to be overlaid on top of the gcc testsuite.

Thereafter you can run the GNU Modula-2 testsuite by:

@example
cd host-build/gcc
make check-gm2
@end example

Depending on the speed of your computer these tests may take a while
to complete.

@node Contributing, Internals, Obtaining, Top
@section Contributing to GNU Modula-2

Please do. But also please read the GNU Emacs info under

@example
* Standards: (standards).       GNU coding standards.
* Intellectual Property::       Keeping Free Software Free
* Reading Non-Free Code::       Referring to Proprietary Programs
* Contributions::               Accepting Contributions
@end example

You might consider joining the GM2 Mailing list:
see URL:
@uref{http://floppsie.comp.glam.ac.uk/mailman/listinfo/gm2}
or mail: @uref{mail:gm2-request@@glam.ac.uk}
before you start coding.

Many thanks and enjoy your coding!

@node Internals, EBNF, Contributing, Top
@chapter GNU Modula-2 Internals

This document is a small step in the long journey of documenting the GNU
Modula-2 compiler and how it integrates with GCC.
The document is still in it's infancy.

@menu
* History::                 Where the sources came from.
* Overview::                Overview of the structure of GNU Modula-2.
* Integrating::             How the front end integrates with gcc.
* Passes::                  What gets processed during each pass.
* Scope rules::             Clarification of some the scope rules.
* Done list::               Progression of the GNU Modula-2 project.
* To do list::              Outstanding issues.
@end menu

@node History, Overview, , Internals
@section History

The Modula-2 compiler sources have come from the m2f compiler which
runs under GNU/Linux. The original m2f compiler was written in Modula-2
and was bootstrapped via a modified version of p2c 1.20. The m2f
compiler was a recursive descent which generated quadruples as
intermediate code. It also used C style calling convention wherever
possible and utilized a C structure for dynamic arrays.

@node Overview, Integrating, History, Internals
@section Overview

GNU Modula-2 uses flex and a machine generated recursive descent
parser. Most of the source code is written in Modula-2 and
bootstrapping is achieved via a modified version of p2c-1.20.
The modified p2c-1.20 is contained in the GNU Modula-2 source
tree as are a number of other tools necessary for bootstrapping.

The changes to p2c include:

@itemize @bullet
@item
allowing @code{DEFINITION MODULE FOR "C"}
@item
fixes to abstract data types.
@item
making p2c understand the 2nd Edition dialect of Modula-2.
@item
introducing the @code{UNQUALIFIED} keyword.
@item
allowing varargs (@code{...}) inside @code{DEFINITION MODULE FOR "C"} modules.
@item
fixing the parser to understand commented @code{FORWARD} prototypes,
which are ignored by GNU Modula-2.
@item
fixes to the @code{CASE} syntax for 2nd Edition Modula-2.
@item
fixes to a @code{FOR} loop counting down to zero using a @code{CARDINAL}.
@item
introducing an initialization section for each implementation module.
@item
various porting improvements and general tidying up so that
it compiles with the gcc option @code{-Wall}.
@end itemize

GNU Modula-2 comes with PIM and ISO style libraries. The compiler
is built using PIM libraries and the source of the compiler
complies with the PIM dialect together with a few @code{C}
library calling extensions.

The compiler is a four pass compiler. The first pass tokenizes
the source code, creates scope and enumeration type symbols.
All tokens are placed into a dynamic buffer and subsequent passes reread
tokens and build types, quadruples and resolve hidden types.
@xref{Passes, , ,}.

GNU Modula-2 uses a technique of double book keeping @footnote{See the
excellent tutorial by Joachim Nadler translated by Tim Josling}.
@xref{Back end Access to Symbol Table, , , gcc}.
The front end builds a complete symbol table and a list of quadruples.
Each symbol is translated into a @code{gcc} equivalent after which
each quadruple is translated into a @code{gcc} @code{tree}.

@node Integrating, Passes, Overview, Internals
@section How the front end integrates with gcc

The M2Base and M2System
modules contain base types and system types respectively they
map onto GCC back-end data types.

@node Passes, Scope rules, Integrating, Internals
@section Passes

This section describes the general actions of each pass.  The key to
building up the symbol table correctly is to ensure that the symbols
are only created in the scope where they were declared.  This may seem
obvious (and easy) but it is complicated by two issues: firstly GNU
Modula-2 does not generate @code{.sym} files and so all imported
definition modules are parsed after the module is parsed; secondly the
import/export rules might mean that you can see and use a symbol
before it is declared in a completely different scope.

Here is a brief description of the lists of symbols maintained within
@code{DefImp} and @code{Module} symbols. It is these lists and actions
at each pass which manipulate these lists which solve the scoping and
visability of all symbols.

The @code{DefImp} symbol maintains the: @code{ExportQualified},
@code{ExportUnQualified}, @code{ExportRequest}, @code{IncludeList},
@code{ImportTree}, @code{ExportUndeclared},
@code{NeedToBeImplemented}, @code{LocalSymbols},
@code{EnumerationScopeList}, @code{Unresolved}, @code{ListOfVars},
@code{ListOfProcs} and @code{ListOfModules} lists.

The @code{Module} symbol maintains the: @code{LocalSymbols},
@code{ExportTree}, @code{IncludeList}, @code{ImportTree},
@code{ExportUndeclared}, @code{EnumerationScopeList},
@code{Unresolved}, @code{ListOfVars}, @code{ListOfProcs} and
@code{ListOfModules} lists.

Initially we discuss the lists which are common to both @code{DefImp}
and @code{Module} symbols, thereafter the lists peculiar to @code{DefImp}
and @code{Module} symbols are discussed.

The @code{ListOfVars}, @code{ListOfProcs} and @code{ListOfModules}
lists (common to both symbols) and simply contain a list of
variables, procedures and inner modules which are declared with this
definition/implementation or program module.

The @code{LocalSymbols} list (common to both symbols) contains a
complete list of symbols visible in this modules scope. The symbols in
this list may have been imported or exported from an inner module.

The @code{EnumerationScope} list (common to both symbols)
defines all visible enumeration symbols.
When this module is parsed these the contents of these enumeration
types are marked as visible. Internally to GNU Modula-2 these form a
pseudo scope (rather like a @code{WITH} statement which temporarily
makes the fields of the record visible).

The @code{ExportUndeclared} list (common to both symbols) contains a
list of all symbols marked as exported but as yet undeclared.

The @code{IncludeList} is (common to both symbols) contains a list of
all modules imported by the @code{IMPORT modulename ;} construct.

The @code{ImportTree} (common to both symbols) contains a tree of all
imported identifiers.

The @code{ExportQualified} and @code{ExportUnQualified} trees (only
present in the @code{DefImp} symbol) contain identifiers which are
marked as @code{EXPORT QUALIFIED} and @code{EXPORT UNQUALIFIED}
respectively.

The @code{NeedToBeImplemented} list (only present in the @code{DefImp}
symbol) and contains a list of all unresolved symbols which are exported.

@subsection Pass 1

During pass 1 each @code{DefImp} and @code{Module} symbol is
created. These are also placed into a list of outstanding sources to
be parsed.  The import and export lists are recorded and each object
imported is created in the module from whence it is exported and added
into the imported list of the current module. Any exported objects are
placed into the export list and marked as qualified or unqualified.

Inner module symbols are also created and their import and export
lists are also processed. An import list will result in a symbol being
fetched (or created if it does not exit) from the outer scope and
placed into the scope of the inner module. An export list results in
each symbol being fetched or created in the current inner scope and
added to the outer scope. If the symbol has not yet been declared then
it is added to the current modules @code{ExportUndeclared} list.

Procedure symbols are created (the parameters are parsed but no more
symbols are created). Enumerated types are created, hidden types in
the definition modules are marked as such. All the rest of the Modula-2
syntax is parsed but no symbols are created.

@subsection Pass 2

To do

@subsection Pass 3

To do

@subsection Pass H

To do

@subsection Declaration ordering

This section gives a few stress testing examples and walks though
the mechanics of the passes and how the lists of symbols are created.

The first example contains a nested module in which an enumeration
type is created and exported. A procedure declared before the nested
module uses the enumeration type.

@example
MODULE colour ;

   PROCEDURE make (VAR c: colours) ;
   BEGIN
      c := yellow
   END make ;

   MODULE inner ;
   EXPORT colours ;

   TYPE
      colours = (red, blue, yellow, white) ;
   END inner ;

VAR
   g: colours
BEGIN
   make(g)
END colour.
@end example

@node Scope rules, Done list, Passes, Internals
@section Scope rules

This section describes my understanding of the Modula-2 scope rules
with respect to enumerated types.  If they are incorrect please
correct me by email @email{gaius@@glam.ac.uk}. They also serve to document
the behaviour of GNU Modula-2 in these cirumstances.

In GNU Modula-2 the syntax for a type declaration is defined as:

@example
TypeDeclaration := Ident "=" Type =:							   

Type :=  SimpleType | ArrayType
          | RecordType          
          | SetType             
          | PointerType         
          | ProcedureType
      =:								   
									   
SimpleType := Qualident | Enumeration | SubrangeType =:								   
@end example

If the @code{TypeDeclaration} rule is satisfied by
@code{SimpleType} and @code{Qualident} ie:

@example
TYPE
   foo = bar ;
@end example

then @code{foo} is said to be equivalent to @code{bar}. Thus
variables, parameters and record fields declared with either type will
be compatible with each other.

If, however, the @code{TypeDeclaration} rule is satisfied by any
alternative clause @code{ArrayType}, @code{RecordType},
@code{SetType}, @code{PointerType}, @code{ProcedureType},
@code{Enumeration} or @code{SubrangeType} then in these cases a new
type is created which is distinct from all other types.  It will be
incompatible with all other user defined types.

It also has furthur consequences in that if bar was defined as an
enumerated type and foo is imported by another module then the
enumerated values are also visible in this module.

Consider the following modules:

@example
DEFINITION MODULE impc ;

TYPE
   C = (red, blue, green) ;

END impc.
@end example

@example
DEFINITION MODULE impb ;

IMPORT impc ;

TYPE
   C = impc.C ;

END impb.
@end example

@example
MODULE impa ;

FROM impb IMPORT C ;

VAR
   a: C ;
BEGIN
   a := red
END impa.
@end example

Here we see that the type @code{C} defined in module @code{impb} is
equivalent to the type @code{C} in module @code{impc}. Module
@code{impa} imports the type @code{C} from module @code{impb}
and at that point the enumeration values @code{red, blue, green}
(declared in module @code{impc}) are also visible.

At the time of writing I cannot find clarification on this issue in
the PIM-[234] books.  However according to the Interim Version of 4th
Working Draft Modula-2 Standard in sections 6.1.6.4. and 6.1.6.5. The
annotation states that:

``The set of identifiers that are explicitly imported must not be
redeclared in the block that imports those identifiers. The implicitly
imported identifiers are given by the closures of all the explicitly
imported identifiers.''

and closure is defined as:

``The closure of an identifier defines the set of identifiers that is
implicitly imported or exported if that identifier is imported or
exported.''

``The closure of an identifier shall be a set consisting of that
identifier, together with the closure of the type if that identifier
is associated with a type.''

``The closure of an identifier is a singleton set containing that
identifier, for an identifier denoting an enumerated type the closure
set includes the enumerated constants of the type as well as the
identifier denoting the type itself.''

``Thus an identifier denoting with an enumerated type is imported
(exported), then the occurance of that identifier in that import list
(export list) is an abbreviation for the occurrence of that
identifier, together with all of the identifiers associated with the
constant values of the enumerated type.''

Which seems to imply that the following module should not compile:

@example
MODULE impd ;

IMPORT impb ;

VAR
   a: impb.C ;
BEGIN
   a := impb.red  (* red should not be resolved *)
END impd.
@end example

Whereas if the module were altered to:

@example
MODULE impd ;

FROM impb IMPORT C ;

VAR
   a: C ;
BEGIN
   a := red
END impd.
@end example

then @code{red} is resolved and the module is legal.

@node Done list, To do list, Scope rules, Internals
@section Done list

What has been done:

@itemize @bullet

@item
converted the regression test suite into the GNU dejagnu format.
In turn this can be grafted onto the GCC testsuite and can be
invoked as @code{make check-gm2}.

@item
provided access to a few compiler built-in constants
and twenty seven built-in C functions.

@item
definition modules no longer have to @samp{EXPORT QUALIFIED}
objects (as per PIM-3, PIM-4 and ISO).

@item
implemented ISO Modula-2 sets. Large sets are now allowed,
no limits imposed. The comparison operators
@samp{# = <= >= < >} all behave as per ISO standard.
The obvious use for large sets is
@samp{SET OF CHAR}. These work well with gdb once it has been
patched to understand Modula-2 sets.

@item
added @code{DEFINITION MODULE FOR "C"} method of linking
to C. Also added varargs handling in C definition modules.

@item
cpp can be run on definition and implementation modules.

@item
@samp{-Wmakell} generates a temporary @code{Makefile} and
will build all dependant modules.

@item
compiler will bootstrap itself and three generations of the
compiler all produce the same code.

@item
the back end will generate code and assembly declarations for
modules containing global variables of all types. Procedure
prologue/epilogue is created.

@item
all loop constructs, if then else, case statements and expressions.

@item
nested module initialization.

@item
pointers, arrays, procedure calls, nested procedures.

@item
front end @samp{gm2} can now compile and link modules.

@item
the ability to insert gnu asm statements within GNU Modula-2.

@item
inbuilt functions, SIZE, ADR, TSIZE, HIGH etc

@item
block becomes and complex procedure parameters (unbounded arrays, strings).

@item
the front end now utilizes GCC tree constants and types and is no
longer tied to a 32 bit architecture, but reflects the 'configure'
target machine description.

@item
fixed all C compiler warnings when gcc compiles the p2c generated C
with -Wall.

@item
built a new parser which implements error recovery.

@item
added mechanism to invoke cpp to support conditional compilation if required.

@item
all @samp{Makefile}s are generated via @samp{./configure}

@end itemize

@node To do list, , Done list, Internals
@section To do list

What needs to be done:

@itemize @bullet

@item
ISO library implementation needs to be completed
(use FIO.mod as the underlying substructure).

@item
Easy access to other libraries using @code{-Wlibs=} so that libraries
can be added into the @file{/usr/.../gcc-lib/gm2/...} structure. ISO
language complience.

@item
implement many of the ISO built-in functions and procedures.

@item
investigate the use of collect2 during link/module initialization.

@item
Coroutines - as mentioned by readers of comp.lang.modula2.

@item
improve documentation, specifically this document which should
also include a synopsis of 2nd Edition Modula-2.

@item
shared library access and generation

@item
modifying @file{SymbolTable.mod} and @file{M2Quads.mod} to
make all the data structures dynamic.

@item
testing and fixing bugs

@end itemize

@node EBNF, Libraries, Internals, Top
@chapter EBNF of GNU Modula-2

This chapter contains the EBNF of GNU Modula-2. This grammer
currently supports PIM and a number of ISO features. It is intended
to be altered to become fully complient with ISO in the future.
The rules here are automatically extracted from the grammer files in
GNU Modula-2 and serve to document the syntax of the extensions described
earlier and how they fit in with the base language.

Note that the first five productions are in-built from the lexical analysis
phase.

@include gm2-ebnf.texi

@node Libraries, Function Index, EBNF, Top
@chapter PIM and ISO library definitions

This chapter contains PIM and ISO libraries. The ISO libraries are currently
work in progress, many are incomplete and even more have no implementation
module. The PIM libraries are very mature as the compiler uses them extensively.

@include gm2-libs.texi

@node Function Index, , Libraries, Top

@c @printindex cp
@printindex fn

@summarycontents
@contents
@bye
