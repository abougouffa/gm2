\input texinfo 
@c -*-texinfo-*-

@c

@code{makeinfo}
@code{texinfo-format-buffer}

@c
@c Design notes and documentation about GNU Modula-2
@c
@c
@c part 1 header
@c

@setfilename gm2.info
@set version-GM2     0.62
@set version-GCC     4.1.2
@set version-HARNESS 0.96
@set version-GDB     6.6

@settitle The GNU Modula-2 front end to GCC (gm2-@value{version-GM2})

@c Part 2: Titlepage and Copyright

@c The titlepage segment does not appear in the Info file. 
@titlepage
@sp 10
@comment The title is printed in a large font.
@center @titlefont{The GNU Modula-2 front end to GCC}
@sp 10
@center @titlefont{gm2-@value{version-GM2}}
@c
@page
@setchapternewpage odd
@sp 2
@center Gaius Mulley
@sp 3
@center Last updated 6th October 2007
@sp 10
@c
@center @image{gm2/images/gnu,,1.5in}
@c@sp 10
@c@quotation
@c``And then one day you find ten years have got behind you'', Pink Floyd
@c@end quotation
@c
@vskip 0pt plus 1filll
Copyright @copyright{} 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with the Front-Cover texts being `A GNU Manual,''
and with the Back-Cover Texts as in (a) below.  A copy of the
license is included in the section entitled `GNU Free Documentation
License.''

(a) The FSF's Back-Cover Text is: `You have freedom to copy and modify
this GNU Manual, like GNU software.  Copies published by the Free
Software Foundation raise funds for GNU development.''
@end titlepage

@c Part 4: `Top' Node and Master Menu

@ifinfo
@node Top, Using, (dir), (dir)
@top Introduction
@end ifinfo

@menu
* Using::            Using GNU Modula-2.
* Obtaining::        Obtaining GNU Modula-2.
* Licence::          Licence of GNU Modula-2.
* GNU Project::      The GNU Project and GNU/Linux.
* Contributing::     Contributing to GNU Modula-2.
* Internals::        GNU Modula-2 internals.
* EBNF::             EBNF of GNU Modula-2
* Libraries::        PIM and ISO library definitions.
* Function Index::   Index for all library functions.
@end menu

@node Using, Obtaining, Top, Top
@chapter Using GNU Modula-2

@menu
* What is GNU Modula-2::  Brief description of GNU Modula-2.
* Why use GNU Modula-2::  Advantages of GNU Modula-2.
* Release map::           Future releases of GNU Modula-2.
* Compiler options::      GNU Modula-2 compiler options.
* Example usage::         Example compile and link.
* Elementary data types:: Data types supported by GNU Modula-2.
* Standard procedures::   Permanently accessible base procedures.
* Dialect::               GNU Modula-2 supported dialects.
* Extensions::            GNU Modula-2 language extensions.
* Interface to C::        Interfacing GNU Modula-2 to C.
* h2def::                 Semi-automatic translation of C header files.
* Assembly language::     Interface to assembly language.
* Built-ins::             Accessing GNU Modula-2 Built-ins.
* The PIM system module:: SYSTEM data types and procedures.
* The ISO system module:: SYSTEM data types, procedures and run time.
@end menu

This document contains the user and design issues relevant to the
Modula-2 front end to gcc.  Throughout this document the GNU Modula-2
front end is often referred to as @samp{gm2-@value{version-GM2}} or
@samp{gm2} for short.  This corresponds to GCC version
@value{version-GCC} and GNU Modula-2 version @value{version-GM2}.

@node What is GNU Modula-2, Why use GNU Modula-2, , Using
@section What is GNU Modula-2

GNU Modula-2 is a front end @uref{http://gcc.gnu.org/frontends.html}
for GCC. GCC is a retargetable C compiler which has been ported to a large
number of architectures and operating systems. GNU Modula-2 utilizes the
back end of GCC and replaces the C language front end with a Modula-2
front end. Consequently GNU Modula-2 has been built on i[3456]86 GNU/Linux,
i[3456]86 BSD, Opteron LP64 GNU/Linux and sparc GNU/Linux systems.
It has also been built as a cross compiler for MinGW and StrongARM GNU/Linux.

The GNU Modula-2 compiler is based on the language as defined in
'Programming in Modula-2' 2nd Edition, Springer Verlag, 1982, 1983 by
Niklaus Wirth (PIM2), 'Programming in Modula-2', 3rd Corrected
Edition, Springer Verlag, 1985 (PIM3) and 'Programming in Modula-2',
4th Edition, Springer Verlag, 1988 (PIM4)
@uref{http://freepages.modula2.org/report4/modula-2.html}.  It also
includes ISO M2 features and GNU Modula-2 extensions. Currently GNU
Modula-2 (@value{version-GM2}) implements all PIM dialects of the
language, eventually GNU Modula-2 will be fully compliant with ISO
Modula-2.

There are currently three sets of libraries. The 'Programming in
Modula-2' libraries, the 'University of ULM libraries' and the ISO
libraries. The ISO libraries are still being written, however all
definition modules for the three library sets are contained within
this document.

@node Why use GNU Modula-2, Release map, What is GNU Modula-2, Using
@section Why use GNU Modula-2

This section is not designed to generate a language war, but rather
map out some of the advantages of using GNU Modula-2 rather than
translate Modula-2 sources into another language.

It is expected that the primary purpose of GNU Modula-2 will be to
compile legacy code. Currently there are only a few commercial
Modula-2 compilers being actively maintained. Code which was written
ten or fifteen years ago may still be compiled by older commercial
(possibly unmaintained) compilers. While the 32 bit x86 remains these
compilers presumably can be run in compatibility mode (some compilers
only produced 16 bit code). Time is running out as the computing
industry is switching to 64 microprocessors. While x86 emulation or 16
bit backwards compatibility is always possible it has some serious
drawbacks. In order for the older source to run natively the source
code will either have to be translated into another high level
language or alternatively a Modula-2 compiler which can target these
new generation of microprocessors will have to be acquired. GNU
Modula-2 builds and passes all its regression tests on Debian Pure 64
(LP64 architecture), 64 bit Solaris, 32 bit x86 GNU/Linux (Suse 9.1,
Debian, stable and unstable) and 32 bit x86 FreeBSD.

GNU Modula-2 also has the advantage of being closely tied to GCC.  Not
only does this produce excellent code and excellent architectural and
operating system coverage but it also utilises many of the GCC
features. For example GNU Modula-2 can invoke the C preprocessor to
manage conditional compilation; in-lining of @code{SYSTEM} procedures,
intrinsic functions, memory copying routines are also exploited;
access to assembly language using GCC syntax is also provided.  GNU
Modula-2 also support sets of any ordinal type (memory permitting).

GNU Modula-2 was based on a Modula-2 front end which performed a
substantial amount of static analysis of the source code (see
@samp{-Wpedantic}, @samp{-Wpedantic-param-names}, @samp{-Wstudents}
and @samp{-Wpedentic-cast}.

Finally runtime checking has been implemented and can check: bounds of
subranges and array indexes, functions execute a @code{RETURN}
statement, a pointer does not dereference a @code{NIL} pointer value
and that the expression within a @code{CASE} statement is correctly
matched.

@node Release map, Compiler options, Why use GNU Modula-2, Using
@section Release map

This section attempts to give an idea of which releases points are
likely in the future. Clearly this is a fairly fluid release map but
hopefully it is more helpful than omitting it altogether. Please note
that this is not set in stone and if you (the users) wish to see
something different please email @email{gaius@@gnu.org} with your
ideas. Also please note that the actual release numbers do not have
any correlation to the estimated time of release. For example please
do not misunderstand that GM2-1.0 will take twice as long as GM2-0.5
to appear. It is worthing noting that some of the later points in the
release life have already been addressed (in part) but are not yet
complete.

@table @code

@item 0.50
compatible with gcc-3.3.6. GNU Modula-2 is stable and passes all
regression tests on LP64 Opteron and 32 bit x86 GNU/Linux.  The
compiler is PIM-234 compatible (use @samp{-fpim2}, @samp{-fpim3} and
@samp{-fpim4} to force mutually exclusive PIM features).

It is also able to compile the University of Ulm libraries which
are now distributed as part of GNU Modula-2. To reference these
libraries use the @samp{-flibs=ulm} compiler switch.

@item 0.60
many Logitech compatible libraries will be provided, which will
be available when invoked by @samp{-fpim}.

@item 0.80
a full set of ISO libraries will have been implemented. GNU Modula-2
will be sufficiently ISO compliant to compile the libraries but will
not yet be able to fully conform to the ISO Modula-2 standard.

@item 1.0
GNU Modula-2 will be fully ISO compliant.
@end table

There will be releases inbetween those outlined above and these releases
may occur when GNU Modula-2 builds using a different GCC source tree.
It is a goal that backward compatibility to gcc-3.3.6 will be provided
as far as it is possible. Releases will also occur if a key component
of ISO Modula-2 is implemented (for example exception handling,
complex types or @samp{FINALLY} is implemented).

@node Compiler options, Example usage, Release map, Using
@section Compiler options

This section describes the compiler options specific to GNU Modula-2 for
generic flags details see
@xref{Invoking GCC, , ,gcc}.

@table @code

@item -fmakeall
generate a temporary makefile and build all dependent modules and
link.

@item -fbounds
generate code to check the bounds of subranges and array indexes.

@item -freturn
generate code to check that functions always exit with a @code{RETURN}
and do not fall out at the end.

@item -fnil
turns on runtime checking to detect accessing data through a
@code{NIL} value pointer.

@item -fcase
turns on runtime checking to check whether a @code{CASE} statement
requires an @code{ELSE} clause when on was not specified.

@item -fcheck-all
turns on all runtime checks. This is the same as invoking
GNU Modula-2 using the command options
@code{-fbounds} @code{-freturn} @code{-fnil} @code{-fcase}.

@item -v
display all calls to subsidiary programs, such as the C preprocessor,
the GNU Modula-2 linker and compiler.

@item -fstatistics
generates quadruple information: number of quadruples generated,
number of quadruples remaining after optimisation.

@item -fmakelist
this option is only applicable when linking a program module.  The
compiler will generate a @file{modulename.lst} file which contains a
list indicating the initialisation order of all modules which are to
be linked. The actual link does not occur.  The GNU Modula-2 linker
scans all @code{IMPORT}s, generates a list of dependencies and
produces an ordered list for initialisation. It will probably get the
order wrong if your project has cyclic dependencies, but the
@file{.lst} file is plain text and can be modified if required.  Once
the @file{.lst} file is created it can be used by the compiler to link
your project via the @samp{-fuselist} option.  It has no effect if the
@samp{-c} option is present.

@item -fuselist
providing @samp{gm2} has been told to link the program module this
option uses the file @file{modulename.lst} for the initialisation
order of modules.

@item -fcpp
preprocess the source with @samp{cpp -lang-asm -traditional-cpp}
For further details about these options see @xref{Invocation, , ,cpp}.
If @samp{-fcpp} is supplied then all definition modules and
implementation modules which are parsed will be preprocessed by
@samp{cpp}.

@item -fiso
turn on ISO standard features. Currently this enables the ISO
@code{SYSTEM} module and alters the default library search path so
that the ISO libraries are searched before the PIM libraries.  It also
effects the behaviour of @code{DIV} and @code{MOD} operators.
See @xref{Dialect, , ,gm2}.

@item -fpim
turn on PIM standard features. Currently this enables the PIM
@code{SYSTEM} module and determines which identifiers are pervasive
(declared in the base module). If no other @samp{-fpim[234]} switch is
used then division and modulus operators behave as defined in PIM4.
See @xref{Dialect, , ,gm2}.

@item -fpim2
turn on PIM-2 standard features. Currently this removes @code{SIZE}
from being a pervasive identifier (declared in the base module).  It
places @code{SIZE} in the @code{SYSTEM} module.  It also effects the
behaviour of @code{DIV} and @code{MOD} operators.
See @xref{Dialect, , ,gm2}.

@item -fpim3
turn on PIM-3 standard features. Currently this only effects the
behaviour of @code{DIV} and @code{MOD} operators.
See @xref{Dialect, , ,gm2}.

@item -fpim4
turn on PIM-4 standard features. Currently this only effects the
behaviour of @code{DIV} and @code{MOD} operators.
See @xref{Dialect, , ,gm2}.

@item -fpositive-mod-floor-div
forces the @code{DIV} and @code{MOD} operators to behave as defined by PIM4.
All modulus results are positive and the results from the division are
rounded to the floor.
See @xref{Dialect, , ,gm2}.

@item -flibs=ulm
modifies the default library search path so that the University of Ulm
libraries are searched before the other PIM libraries.

@item -flibs=pim
modifies the default library search path so that the PIM libraries
are searched before any others (the default).

@item -flibs=min
modifies the default library search path so that the absolute minimum
of Modula-2 runtime libraries are loaded (a stripped down M2RTS, SYSTEM
and libc).

@item -flibs=iso
modifies the default library search path so that the ISO libraries are
searched before any others (not needed if @samp{-fiso} was specified).

@item -flibs=logitech
modifies the default library search path so that the Logitech compatible
libraries are searched before the base PIM libraries.

@item -flibs=pim-coroutine
modifies the default libraries search path so that the PIM @code{SYSTEM}
module providing coroutine support is searched before the base PIM libraries.
This directory also includes many coroutine related libraries.

@item -fextended-opaque
allows opaque types to be implemented as any type. This is a GNU
Modula-2 extension and it requires that the implementation module
defining the opaque type is available so that it can be resolved when
compiling the module which imports the opaque type.

@item -fsources
displays the path to the source of each module.

@item -fdef=
recognise the specified suffix as a definition module filename.
The default implmentation and module filename suffix is @file{.def}.
If this option is used GNU Modula-2 will still fall back to this
default if a requested definition module is not found.

@item -fmod=
recognise the specified suffix as implementation and module filenames.
The default implmentation and module filename suffix is @file{.mod}.
If this option is used GNU Modula-2 will still fall back to this
default if it needs to read an implmentation module and the specified
suffixed filename does not exist.
Both this option and @code{-fdef=} also work with the @code{-fmakeall}
option.

@item -funbounded-by-reference
enable optimization of unbounded parameters by attempting to pass non
@code{VAR} unbounded parameters by reference.  This optimization
avoids the implicit copy inside the callee procedure. GNU Modula-2
will only allow unbounded parameters to be passed by reference if,
inside the callee procedure, they are not written to, no address is
calculated on the array and it is not passed as a @code{VAR}
parameter.  Note that it is possible to write code to break this
optimization, therefore this option should be used carefully.
For example it would be possible to take the address of an array, pass
the address and the array to a procedure, read from the array in
the procedure and write to the location using the address parameter.

Due to the dangerous nature of this option it is not enabled
when the -O option is specified.

@item -Wverbose-unbounded
inform the user which non @code{VAR} unbounded parameters will be
passed by reference.  This only produces output if the option
@samp{-funbounded-by-reference} is also supplied on the command line.

@item -Wstudents
checks for bad programming style. This option is aimed at new users of
Modula-2 in that it checks for situations which might cause confusion
and thus mistakes.  It checks whether variables of the same name are
declared in different scopes and whether variables look like keywords.
Experienced users might find this option too aggressive.

@item -Wpedantic
forces the compiler to reject nested @code{WITH} statements
referencing the same record type.  Does not allow multiple imports of
the same item from a module.  It also checks that: procedure variables
are written to before being read; variables are not only written to
but read from; variables are declared and used.  If the compiler
encounters a variable being read before written it will terminate with
a message.  It will check that @code{FOR} loop indices are not used
outside the end of this loop without being reset.

@item -Wpedantic-param-names
procedure parameter names are checked in the definition module 
against their implementation module counterpart. This is not
necessary in ISO or PIM versions of Modula-2, but it can be
extremely useful, as long as code is intentionally
written in this way.

@item -Wpedantic-cast
warns if the ISO system function is used and if the size of
the variable is different from that of the type. This is legal
in ISO Modula-2, however it can be dangerous. Some users may prefer
to use @code{VAL} instead in these situations and use @code{CAST}
exclusively for changes in type on objects which have the same size.

@end table

@node Example usage, Elementary data types, Compiler options, Using
@section Example compile and link

This section describes how to compile and link a simple hello world
program.  It provides a few examples of using the different options
mentioned in @xref{Compiler options, , ,gm2}.  Assuming that you have
a file called @file{hello.mod} in your current directory which
contains:

@example
MODULE hello ;

FROM StrIO IMPORT WriteString, WriteLn ;

BEGIN
   WriteString('hello world') ; WriteLn
END hello.
@end example

You should be able to compile it by: @samp{gm2 -c -g -I. hello.mod}
and link via: @samp{gm2 -g -I. hello.mod}.  The result should be an
@samp{a.out} file created in your directory.

Alternatively it may be compiled by:

@samp{gm2 -g -I. -fmakeall hello.mod}
@footnote{To see all the compile actions taken by @samp{gm2} users can also
add the @samp{-v} flag at the command line, for example:

@samp{gm2 -v -g -I. -fmakeall hello.mod}

This displays the subprocesses initiated by @samp{gm2} which can be useful
when trouble shooting.}

@node Elementary data types, Standard procedures, Example usage, Using
@section Elementary data types

This section describes the elementary data types supported by GNU
Modula-2. It also describes the relationship between these data types
and the equivalent C data types.

The following data types are supported: @code{INTEGER},
@code{LONGINT}, @code{SHORTINT}, @code{CARDINAL}, @code{LONGCARD},
@code{SHORTCARD}, @code{BOOLEAN}, @code{REAL}, @code{LONGREAL},
@code{SHORTREAL}, and @code{CHAR}.

An equivalence table is given below:

@example
GNU Modula-2              GNU C
======================================
INTEGER                   int
LONGINT                   long long int
SHORTINT                  short int
CARDINAL                  unsigned int
LONGCARD                  long long unsigned int
SHORTCARD                 short unsigned int
BOOLEAN                   int
REAL                      double
LONGREAL                  long double
SHORTREAL                 float
CHAR                      char
@end example

@node Standard procedures, Dialect, Elementary data types, Using
@section Permanently accessible base procedures.

This section describes the procedures and functions which are
always visible.

@subsection Standard procedures and functions common to PIM and ISO

The following procedures are implemented and conform with Programming
in Modula-2 and ISO Modula-2: @code{NEW}, @code{DISPOSE}, @code{INC},
@code{DEC}, @code{INCL}, @code{EXCL} and @code{HALT}.  The standard
functions are: @code{HIGH}, @code{CAP}, @code{ABS}, @code{ODD},
@code{VAL}, @code{CHR}, @code{MIN}, @code{MAX}. All these functions
and procedures (except @code{HALT}, @code{NEW}, @code{DISPOSE} and,
under non constant conditions, @code{LENGTH}) generate in-line code
for efficiency.

@example

(*
   NEW - the procedure NEW is replaced by:
         ALLOCATE(p, TSIZE(p^)) ;
         The user is expected to import the procedure ALLOCATE
         (normally found in the module, Storage.)

         In:  a variable p: of any pointer type.
         Out: variable, p, is set to some allocated memory
              which is large enough to hold all the contents of p^.
*)

@findex NEW
PROCEDURE NEW (VAR p:<any pointer type>) ;
@end example

@example

(*
   DISPOSE - the procedure DISPOSE is replaced by:
             DEALLOCATE(p, TSIZE(p^)) ;
             The user is expected to import the procedure DEALLOCATE
             (normally found in the module, Storage.)

             In:  a variable p: of any pointer type which has been
                  initialized by a call to NEW.
             Out: the area of memory
                  holding p^ is returned to the system.
                  Note that the underlying procedure DEALLOCATE
                  procedure in module Storage will assign p to NIL.
*)

@findex DISPOSE
PROCEDURE DISPOSE (VAR p:<any pointer type>) ;
@end example

@example

(*
   INC - can take one or two parameters. If supplied with one
         parameter it adds 1 to the variable, v.
         If two parameters are supplied then the value, a, is
         added to, v.
*)

@findex INC
PROCEDURE INC (VAR v: <any base type>; [a: <any base type> = 1]) ;
@end example

@example

(*
   DEC - can take one or two parameters. If supplied with one
         parameter it subtracts 1 from the variable, v.
         If two parameters are supplied then the value, a, is
         subtracted from, v.
*)

@findex DEC
PROCEDURE DEC (VAR v: <any base type>; [a: <any base type> = 1]) ;
@end example

@example

(*
   INCL - includes bit element, e, to a set type, s.
*)

@findex INCL
PROCEDURE INCL (VAR s: <any set type>; e: <element of set type s>) ;
@end example

@example

(*
   EXCL - excludes bit element, e, from a set type, s.
*)

@findex EXCL
PROCEDURE EXCL (VAR s: <any set type>; e: <element of set type s>) ;
@end example

@example

(*
   HALT - will call the HALT procedure inside the module M2RTS.
          Users can replace M2RTS.
*)

@findex HALT
PROCEDURE HALT ;

@end example

The following define the standard set of functions which conform with
Programming in Modula-2 and ISO Modula-2.

@example

(*
   HIGH - returns the last accessible index of an parameter declared as
          ARRAY OF CHAR. Thus

          PROCEDURE foo (a: ARRAY OF CHAR) ;
          VAR
             c: CARDINAL ;
          BEGIN
             c := HIGH(a)
          END foo ;

          BEGIN
             foo('hello')
          END

          will cause the local variable, c, to contain the value 4
*)

@findex HIGH
PROCEDURE HIGH (a: ARRAY OF CHAR) : CARDINAL ;
@end example

@example

(*
   CAP - returns the capital of character, ch, providing
         ch lies within the range 'a'..'z'. Otherwise, ch,
         is returned unaltered.
*)

@findex CAP
PROCEDURE CAP (ch: CHAR) : CHAR ;

@end example

@example

(*
   ABS - returns the positive value of, i.
*)

@findex ABS
PROCEDURE ABS (i: <any signed type>) : <any signed type> ;

@end example

@example

(*
   VAL - converts data, i, of <any simple data type 2> to
         <any simple data type 1> and returns this value.
         No range checking is performed during this conversion.
*)

@findex VAL
PROCEDURE VAL (<any simple data type 1>,
               i: <any simple data type 2>) : <any simple data type 1> ;

@end example

@example
(*
   CHR - converts a value of a <whole number type> into a CHAR.
         CHR(x) is shorthand for VAL(CHAR, x).
*)

@findex CHR
PROCEDURE CHR (x: <whole number type>) : CHAR ;

@end example

@example
(*
   ODD - returns TRUE if the value is not divisible by 2.
*)

@findex ODD
PROCEDURE ODD (x: <whole number type>) : BOOLEAN ;

@end example

@example
(*
   MIN - returns the lowest legal value of an ordinal type.
*)

@findex MIN
PROCEDURE MIN (t: <ordinal type>) : <ordinal type> ;

@end example

@example
(*
   MAX - returns the largest legal value of an ordinal type.
*)

@findex MAX
PROCEDURE MAX (t: <ordinal type>) : <ordinal type> ;

@end example


@subsection ISO specific standard procedures and functions

The standard function @code{LENGTH} is specific to ISO Modula-2 and
is defined as:

@example

(*
   LENGTH - returns the length of string, a.
*)

@findex LENGTH
PROCEDURE LENGTH (a: ARRAY OF CHAR) : CARDINAL ;

@end example

This function is evaluated at compile time, providing that string
@code{a} is a constant. If @code{a} cannot be evaluated then a call is
made to @code{M2RTS.Length}.

@c complete other ISO functions

@node Dialect, Extensions, Standard procedures, Using
@section GNU Modula-2 supported dialects

This section describes the dialects understood by GNU Modula-2.
It also describes the differences between the dialects and
any command line switches which determine dialect behaviour.

The GNU Modula-2 compiler is based on the language as defined in
'Programming in Modula-2' 2nd Edition, Springer Verlag, 1982, 1983 by
Niklaus Wirth (PIM2), 'Programming in Modula-2', 3rd Corrected
Edition, Springer Verlag, 1985 (PIM3) and 'Programming in Modula-2',
4th Edition, Springer Verlag, 1988 (PIM4).  It also includes ISO M2
features and GNU Modula-2 extensions. Currently GNU Modula-2
(@value{version-GM2}) implements all PIM dialects of the language,
eventually GNU Modula-2 will be fully compliant with ISO Modula-2.

The command line switches @samp{-fpim2}, @samp{-fpim3},
@samp{-fpim4} and @samp{-fiso} can be used to force mutually
exclusive features. However by default the compiler will not
agressively fail if a non mutually exclusive feature is used
from another dialect. For example it is possible to specify
@samp{-fpim2} and still utilise @samp{DEFINITION} @samp{MODULES}
which have no export list.

Some dialect differences will force a compile time error, for example
in PIM2 the user must @code{IMPORT} @code{SIZE} from the module
@code{SYSTEM}, whereas in PIM3 and PIM4 @code{SIZE} is a pervasive
function. Thus compiling PIM4 source code with the @samp{-fpim2}
switch will cause a compile time error. This can be fixed quickly
with an additional @code{IMPORT} or alternatively by compiling with
the @samp{-fpim4} switch.

However there are some very important differences between the dialects
which are mutually exclusive and therefore it is vital that users
choose the dialects with care when these language features are used.

@subsection Integer division, remainder and modulus

The most dangerous set of mutually exclusive features found in the
four dialects supported by GNU Modula-2 are the @code{INTEGER}
division, remainder and modulus arithmetic operators.  It is important
to note that the same source code can be compiled to give different
runtime results depending upon these switches! The reference manual
for the various dialects of Modula-2 are quite clear about this
behaviour and sadly there are three distinct definitions.

The table below illustrates the problem when a negative operand is
used.

@example
                  Pim2/3          Pim4                ISO
               -----------    -----------    ----------------------
lval    rval   DIV     MOD    DIV     MOD    DIV    MOD    /    REM
 31      10      3       1      3       1      3      1     3     1
-31      10     -3      -1     -4       9     -4      9    -3    -1
 31     -10     -3       1     -3       1     Exception    -3     1
-31     -10      3      -1      4       9     Exception     3    -1
@end example

See also P24 of PIM2, P27 of PIM3, P29 of PIM4 and P201 of the ISO Standard.
At present all dialect division, remainder and modulus are implemented as
above, apart from the exception calling in the ISO dialect. Instead of
exception handling the results are the same as the PIM4 dialect. This
is a temporary implementation situation.

@node Extensions, Interface to C, Dialect, Using
@section GNU Modula-2 language extensions

This section introduces the GNU Modula-2 language extensions.
The GNU Modula-2 compiler allows abstract data types to be any type,
not just restricted to a pointer type providing the
@samp{-fextended-opaque} option is supplied
@xref{Compiler options, , ,gm2}.

Declarations can be made in any order, whether they are
types, constants, procedures, nested modules or variables
(see @xref{Passes, , ,}.)

GNU Modula-2 also allows programmers to interface to @code{C} and
assembly language.

GNU Modula-2 provides support for the special tokens @code{__LINE__},
@code{__FILE__}, @code{__FUNCTION__} and @code{__DATE__}. Support for
these tokens will occur even if the @samp{-fcpp} option is not
supplied. A table of these identifiers and their data type and values
is given below:

@example
Scope       GNU Modula-2 token      Data type and example value

anywhere    __LINE__                Constant Literal compatible
                                    with CARDINAL, INTEGER and WORD.
                                    Example 1234

anywhere    __FILE__                Constant string compatible
                                    with parameter ARRAY OF CHAR or
                                    an ARRAY whose SIZE is >= string
                                    length. Example
                                    "hello.mod"

procedure   __FUNCTION__            Constant string compatible
                                    with parameter ARRAY OF CHAR or
                                    an ARRAY whose SIZE is >= string
                                    length. Example
                                    "calc"

module      __FUNCTION__            Example
                                    "module hello initialization"

anywhere    __DATE__                Constant string compatible
                                    with parameter ARRAY OF CHAR or
                                    an ARRAY whose SIZE is >= string
                                    length. Example
                                    "Thu Apr 29 10:07:16 BST 2004"

@end example

The preprocessor @samp{cpp} can be invoked via the @samp{-fcpp}
command line option. This in turn invokes @samp{cpp} with the
following arguments @samp{-traditional -lang-asm}.  These options
preserve comments and all quotations.  @samp{gm2} treats a @samp{#}
character in the first column as a preprocessor directive.

For example here is a module which calls @code{FatalError}
via the macro @code{ERROR}.

@example
MODULE cpp ;

FROM SYSTEM IMPORT ADR, SIZE ;
FROM libc IMPORT exit, printf, malloc ;

PROCEDURE FatalError (a, file: ARRAY OF CHAR;
                         line: CARDINAL;
                         func: ARRAY OF CHAR) ;
VAR
   r: INTEGER ;
BEGIN
   r := printf("%s:%d:fatal error, %s, in %s\n",
               ADR(file), line, ADR(a), ADR(func)) ;
   exit(1)
END FatalError ;

#define ERROR(X)  FatalError(X, __FILE__, __LINE__, __FUNCTION__)

VAR
   pc: POINTER TO CARDINAL;
BEGIN
   pc := malloc(SIZE(CARDINAL)) ;
   IF pc=NIL
   THEN
      ERROR('out of memory')
   END
END cpp.
@end example

@subsection Optional procedure parameter

GNU Modula-2 allows the last parameter to a procedure or function
parameter to be optional. For example in the ISO library
@file{COROUTINES.def} the procedure @code{NEWCOROUTINE} is defined as
having an optional fifth argument (@code{initProtection}) which, if
absent, is automatically replaced by @code{NIL}.

@example
@findex NEWCOROUTINE
PROCEDURE NEWCOROUTINE (procBody: PROC; workspace: SYSTEM.ADDRESS;
                        size: CARDINAL; VAR cr: COROUTINE;
                        [initProtection: PROTECTION = NIL]);

  (* Creates a new coroutine whose body is given by procBody,
     and returns the identity of the coroutine in cr.
     workspace is a pointer to the work space allocated to
     the coroutine; size specifies the size of this workspace
     in terms of SYSTEM.LOC.

     The optional fifth argument may contain a single parameter
     which specifies the initial protection level of the coroutine.
  *)
@end example

The implementation module @file{COROUTINES.mod} implements this
procedure using the following syntax:

@example
PROCEDURE NEWCOROUTINE (procBody: PROC; workspace: SYSTEM.ADDRESS;
                        size: CARDINAL; VAR cr: COROUTINE;
                        [initProtection: PROTECTION]);
BEGIN
   
END NEWCOROUTINE ;
@end example

Note that it is illegal for this declaration to contain an initialiser
value for @code{initProtection}. However it is necessary to surround
this parameter with the brackets @code{[} and @code{]}. This serves to
remind the programmer that the last parameter was declared as optional
in the definition module.

Local procedures can be declared to have an optional final parameter
in which case the initializer is mandatory in the implementation or
program module.

@node Interface to C, h2def, Extensions, Using
@section Interfacing GNU Modula-2 to C

The GNU Modula-2 compiler tries to use the C calling convention wherever
possible however some parameters have no C equivalent and
thus a language specific method is used. For example unbounded
arrays are passed as a @code{struct void *address, unsigned int high}
and the contents of these arrays are copied by callee functions
when they are declared as non @code{VAR} parameters.
The @code{VAR} equivalent unbounded array parameters need no copy,
but still use the @code{struct} representation.

The recommended method of interfacing GNU Modula-2 to C is by telling
the definition module that the implementation is in the C language.
This is achieved by using the tokens @code{DEFINITION MODULE FOR "C"}.
Here is an example which can be found in the source tree
@file{gcc-@var{version}/gcc/gm2/examples/callingC/libprintf.def}

@example
DEFINITION MODULE FOR "C" libprintf ;

EXPORT UNQUALIFIED printf ;

PROCEDURE printf (a: ARRAY OF CHAR; ...) ;

END libprintf.
@end example

the @code{UNQUALIFIED} keyword in the definition module informs
GNU Modula-2 not to prefix the module name to exported references
in the object file.

The @code{printf} declaration states that the first parameter semantically
matches @code{ARRAY OF CHAR} but since the module is for the C language
it will be mapped onto @code{char *}. The token @code{...} indicates
a variable number of arguments (varargs) and all parameters passed
here are mapped onto their C equivalents. Arrays and constant strings
are passed as pointers.

The hello world program can be rewritten as:

@example
MODULE hello ;

FROM libprintf IMPORT printf ;

BEGIN
   printf("hello world\n")
END hello.
@end example

and it can be compiled by:

@samp{gm2 -fmakeall -g -I. hello.mod -lc}

In reality the @samp{-lc} is redundant as libc is always included in the
linking process. It is shown here to emphasize that the C library or
object file containing @code{printf} must be present.

@node h2def, Assembly language, Interface to C, Using
@section Semi-automatic translation of C header files

The tool @samp{h2def} can be used to semi-automatically generate
@code{DEFINITION MODULE FOR "C"} modules. The tool takes as input a C
header file and generates as output a corresponding textual definition
module.  While the tool will not automatically translate complex C
header files it will generate definition modules for simple header
files.

For example consider the following excerpt from the
header file (@file{vga.h}):

@example
/* blit flags */
#define HAVE_BITBLIT 1
#define HAVE_FILLBLIT 2
#define HAVE_IMAGEBLIT 4
#define HAVE_HLINELISTBLIT 8
#define HAVE_BLITWAIT 16

    typedef struct @{
	int width;
	int height;
	int bytesperpixel;
	int colors;
	int linewidth;		/* scanline width in bytes */
	int maxlogicalwidth;	/* maximum logical scanline width */
	int startaddressrange;	/* changeable bits set */
	int maxpixels;		/* video memory / bytesperpixel */
	int haveblit;		/* mask of blit functions available */
	int flags;		/* other flags */

	/* Extended fields: */

	int chiptype;		/* Chiptype detected */
	int memory;		/* videomemory in KB */
	int linewidth_unit;	/* Use only a multiple of this as parameter for set_logicalwidth and
				   set_displaystart */
	char *linear_aperture;	/* points to mmap secondary mem aperture of card (NULL if unavailable) */
	int aperture_size;	/* size of aperture in KB if size>=videomemory. 0 if unavail */
	void (*set_aperture_page) (int page);
	/* if aperture_size<videomemory select a memory page */
	void *extensions;	/* points to copy of eeprom for mach32 */
	/* depends from actual driver/chiptype.. etc. */
    @} vga_modeinfo;

    extern vga_modeinfo *vga_getmodeinfo(int mode);
    extern int vga_getdefaultmode(void);
    extern int vga_getcurrentmode(void);
    extern int vga_getcurrentchipset(void);
    extern char *vga_getmodename(int mode);
@end example

Using the following command line @code{h2def vga.h} will generate
the module below:

@example
DEFINITION MODULE FOR "C" vga ;

CONST
     HAVE_BITBLIT =  1 ;
     HAVE_FILLBLIT =  2 ;
     HAVE_IMAGEBLIT =  4 ;
     HAVE_HLINELISTBLIT =  8 ;
     HAVE_BLITWAIT =  16 ;

TYPE
     vga_modeinfo =   RECORD
                         width: INTEGER ;
                         height: INTEGER ;
                         bytesperpixel: INTEGER ;
                         colors: INTEGER ;
                         linewidth: INTEGER ;
                         maxlogicalwidth: INTEGER ;
                         startaddressrange: INTEGER ;
                         maxpixels: INTEGER ;
                         haveblit: INTEGER ;
                         flags: INTEGER ;
                         chiptype: INTEGER ;
                         memory: INTEGER ;
                         linewidth_unit: INTEGER ;
                         linear_aperture: POINTER TO CHAR ;
                         aperture_size: INTEGER ;
                         set_aperture_page:  PROCEDURE (INTEGER) ;
                         extensions: ADDRESS ;
                      END ;
    
 PROCEDURE vga_getmodeinfo (mode: INTEGER) : ADDRESS ;
 PROCEDURE vga_getdefaultmode () : INTEGER ;
 PROCEDURE vga_getcurrentmode () : INTEGER ;
 PROCEDURE vga_getcurrentchipset () : INTEGER ;
 PROCEDURE vga_getmodename (mode: INTEGER) : ADDRESS ;

END vga.
@end example

The main limitation of @code{h2def} is in the preprocessing handling.
It does not understand the C preprocessor token constructor directives
@code{#} and @code{##}. Also it will not combine successive string
tokens.

Support for the @code{#define} mechanism is limited. Initially the
macro is parsed to check whether it is a constant expression.  If it
fails it is reassigned as a macro definition.  A macro which contains
C statement code cannot be translated into a definition module. These
macros and all dependents are poisoned and are not translated.
At present it does not understand macros with arguments.

The @samp{-I} option to @code{h2def} allows include directories to be
specified and the @samp{-C} option states that a macro definition must
be computed at compile time.  For example consider the following
header file called @code{ifdef.h}:

@example
#if !defined(FOOBAR)
# define FOOBAR
# define MAXIMUM 1000
#else
# define MAXIMUM 2000
#endif
@end example

which if processed by @code{h2def -CFOOBAR ifdef.h} yields the following code:

@example
DEFINITION MODULE FOR "C" ifdef ;

# if (!(defined(FOOBAR)))
CONST
   MAXIMUM = 1000 ;
# else
   MAXIMUM = 2000 ;
# endif
     
END ifdef.
@end example

The @samp{-a} option provides a method whereby the C parameter
construct @code{sometype *foo} is translated in Modula-2 as
@code{foo: ARRAY OF sometype}.

Normally output for @code{h2def} will require some manual
intervention. Some header files need more help than others, for
example the GNU/Linux svga header file @code{vga.h} requires a little
help whereas the GNU pthread file @code{pthread.h} requires more.
Nevertheless the effort required is considerably less than writing the
modules by hand.

The @samp{-e} option will emit an error message if a C syntax error is
encountered. The @samp{-p} option generate a comment for every
occurance of an object which cannot be translated into Modula-2.

@node Assembly language, Built-ins, h2def, Using
@section Interface to assembly language

The interface for GNU Modula-2 to assembly language is almost
identical to GNU C.  The only alterations are that the keywords
@code{asm} and @code{volatile} are in capitals, following the Modula-2
convention.

A simple, but highly non optimal, example is given below. Here we want
to add the two @code{CARDINAL}s @code{foo} and @code{bar} together and
return the result.

@example
PROCEDURE Example (foo, bar: CARDINAL) : CARDINAL ;
VAR
   myout: CARDINAL ;
BEGIN
   ASM VOLATILE ("movl %1,%%eax; addl %2,%%eax; movl %%eax,%0"
      : "=g" (myout)           (* outputs *)
      : "g" (foo), "g" (bar)   (* inputs  *)
      : "eax") ;               (* we trash *)
   RETURN( myout )
END Example ;
@end example

For a full description of this interface we refer the reader to the GNU C manual.

@xref{Extended Asm, ,Extensions to the C Language Family,gcc}.

@node Built-ins, The PIM system module, Assembly language, Using
@section Accessing GNU Modula-2 Built-ins

This section describes the built-in constants and functions defined in
GNU Modula-2.  The following compiler constants can be accessed using
the @code{__ATTRIBUTE__} @code{__BUILTIN__} keywords. These are not
part of the Modula-2 language and they may differ depending upon the
target architecture but they provide a method whereby common
libraries can interface to a different underlying architecture.

The built-in constants are: @code{BITS_PER_UNIT}, @code{BITS_PER_WORD},
@code{BITS_PER_CHAR} and @code{UNITS_PER_WORD}. They are integrated into
GNU Modula-2 by an extension to the @code{ConstFactor} rule:

@example
ConstFactor := ConstQualidentOrSet | Number | ConstString |
               "(" ConstExpression ")" | "NOT" ConstFactor |
               ConstAttribute =:

ConstAttribute := "__ATTRIBUTE__" "__BUILTIN__" "(" "(" Ident ")" ")" =:
@end example

Here is an example taken from the ISO library @code{SYSTEM.def}:

@example
CONST
   BITSPERLOC    = __ATTRIBUTE__ __BUILTIN__ ((BITS_PER_UNIT)) ;
   LOCSPERWORD   = __ATTRIBUTE__ __BUILTIN__ ((UNITS_PER_WORD)) ;
@end example

Built-in functions are transparent to the end user. All built-in
functions are declared in @code{DEFINITION MODULE}s and are imported
as and when required.  Built-in functions are declared in definition
modules by using the @code{__BUILTIN__} keyword. Here is a section of
the ISO library @code{LongMath.def} which demonstrates this feature.

@example
PROCEDURE __BUILTIN__ sqrt (x: LONGREAL): LONGREAL;
  (* Returns the square root of x *)
@end example

This indicates that the function @code{sqrt} will be implemented using
the gcc built-in maths library. If gcc cannot utilise the built-in
function (for example if the programmer requested the address of
@code{sqrt}) then code is generated to call the alternative function
implemented in the @code{IMPLEMENTATION} @code{MODULE}.

Sometimes a function exported from the @code{DEFINITION} @code{MODULE}
will have a different name from the built-in function within gcc. In such
cases the mapping between the GNU Modula-2 function name and the gcc name
is expressed using the keywords @code{__ATTRIBUTE__} @code{__BUILTIN__}
@code{((Ident))}. For example the function @code{sqrt} in @code{LongMath.def}
maps onto the gcc built-in function @code{sqrtl} and this is expressed as:

@example
PROCEDURE __ATTRIBUTE__ __BUILTIN__ ((sqrtl)) sqrt
                                    (x: LONGREAL) : LONGREAL;
  (* Returns the positive square root of x *)
@end example

The following module @code{Builtins.def} enumerates the list of built-in functions
which can be accessed in GNU Modula-2. It also serves to define the parameter
and return value for each function:

@example
DEFINITION MODULE Builtins ;

FROM SYSTEM IMPORT ADDRESS ;

PROCEDURE __BUILTIN__ sinf (x: SHORTREAL) : SHORTREAL ;
PROCEDURE __BUILTIN__ sin (x: REAL) : REAL ;
PROCEDURE __BUILTIN__ sinl (x: LONGREAL) : LONGREAL ;

PROCEDURE __BUILTIN__ cosf (x: SHORTREAL) : SHORTREAL ;
PROCEDURE __BUILTIN__ cos (x: REAL) : REAL ;
PROCEDURE __BUILTIN__ cosl (x: LONGREAL) : LONGREAL ;

PROCEDURE __BUILTIN__ sqrtf (x: SHORTREAL) : SHORTREAL ;
PROCEDURE __BUILTIN__ sqrt (x: REAL) : REAL ;
PROCEDURE __BUILTIN__ sqrtl (x: LONGREAL) : LONGREAL ;

PROCEDURE __BUILTIN__ fabsf (x: SHORTREAL) : SHORTREAL ;
PROCEDURE __BUILTIN__ fabs (x: REAL) : REAL ;
PROCEDURE __BUILTIN__ fabsl (x: LONGREAL) : LONGREAL ;

PROCEDURE __BUILTIN__ alloca (i: CARDINAL) : ADDRESS ;
PROCEDURE __BUILTIN__ memcpy (dest, src: ADDRESS; n: CARDINAL) : ADDRESS ;
PROCEDURE __BUILTIN__ index (s: ADDRESS; c: INTEGER) : ADDRESS ;
PROCEDURE __BUILTIN__ rindex (s: ADDRESS; c: INTEGER) : ADDRESS ;
PROCEDURE __BUILTIN__ memcmp (s1, s2: ADDRESS; n: CARDINAL) : INTEGER ;
PROCEDURE __BUILTIN__ memset (s: ADDRESS; c: INTEGER; n: CARDINAL) : ADDRESS ;
PROCEDURE __BUILTIN__ strcat (dest, src: ADDRESS) : ADDRESS ;
PROCEDURE __BUILTIN__ strncat (dest, src: ADDRESS; n: CARDINAL) : ADDRESS ;
PROCEDURE __BUILTIN__ strcpy (dest, src: ADDRESS) : ADDRESS ;
PROCEDURE __BUILTIN__ strncpy (dest, src: ADDRESS; n: CARDINAL) : ADDRESS ;
PROCEDURE __BUILTIN__ strcmp (s1, s2: ADDRESS) : INTEGER ;
PROCEDURE __BUILTIN__ strncmp (s1, s2: ADDRESS; n: CARDINAL) : INTEGER ;
PROCEDURE __BUILTIN__ strlen (s: ADDRESS) : INTEGER ;
PROCEDURE __BUILTIN__ strstr (haystack, needle: ADDRESS) : ADDRESS ;
PROCEDURE __BUILTIN__ strpbrk (s, accept: ADDRESS) : ADDRESS ;
PROCEDURE __BUILTIN__ strspn (s, accept: ADDRESS) : CARDINAL ;
PROCEDURE __BUILTIN__ strcspn (s, accept: ADDRESS) : CARDINAL ;
PROCEDURE __BUILTIN__ strchr (s: ADDRESS; c: INTEGER) : ADDRESS ;
PROCEDURE __BUILTIN__ strrchr (s: ADDRESS; c: INTEGER) : ADDRESS ;
PROCEDURE __BUILTIN__ huge_val (r: REAL) : REAL ;
PROCEDURE __BUILTIN__ huge_valf (s: SHORTREAL) : SHORTREAL ;
PROCEDURE __BUILTIN__ huge_vall (l: LONGREAL) : LONGREAL ;

END Builtins.
@end example

Although this module exists and will result in the generation of
in-line code if optimization flags are passed to GNU Modula-2, users
are advised to utilize the same functions from more generic libraries.
The built-in mechanism will be applied to these generic
libraries where appropriate. Note for the mathematical routines to
be in-lined you need to specify the @samp{-ffast-math -O} options.

@node The PIM system module, The ISO system module, Built-ins, Using
@section The PIM system module

@example
DEFINITION MODULE SYSTEM ;

EXPORT QUALIFIED (* the following are built into the compiler: *)
                 ADDRESS, WORD, BYTE, BITSET,
                 ADR, TSIZE, SIZE, ROTATE, SHIFT ;

(*
   all the procedures below are declared internally to gm2
   ======================================================

PROCEDURE ADR (VAR v: <anytype>): ADDRESS;
  (* Returns the address of variable v. *)

PROCEDURE SIZE (v: <type>) : CARDINAL;
  (* Returns the number of BYTES used to store a v of
     any specified <type>.
  *)

PROCEDURE TSIZE (<type>) : CARDINAL;
  (* Returns the number of BYTES used to store a value of the
     specified <type>.
  *)

PROCEDURE ROTATE (val: <a set type>;
                  num: INTEGER): <type of first parameter>;
  (* Returns a bit sequence obtained from val by rotating up or down
     (left or right) by the absolute value of num.  The direction is
     down if the sign of num is negative, otherwise the direction is up.
  *)

PROCEDURE SHIFT (val: <a set type>;
                 num: INTEGER): <type of first parameter>;
  (* Returns a bit sequence obtained from val by shifting up or down
     (left or right) by the absolute value of num, introducing
     zeros as necessary.  The direction is down if the sign of
     num is negative, otherwise the direction is up.
  *)
*)

(* The following procedures are invoked by GNU Modula-2 to
   shift non word sized set types. They are not part of PIM Modula-2
   but are used by GNU Modula-2 to implement the SHIFT procedure
   defined above. *)

(*
   ShiftVal - is a runtime procedure whose job is to implement
              the SHIFT procedure of ISO SYSTEM. GNU Modula-2 will
              inline a SHIFT of a single WORD sized set and will only
              call this routine for larger sets.
*)

PROCEDURE ShiftVal (VAR s, d: ARRAY OF BITSET;
                    SetSizeInBits: CARDINAL;
                    ShiftCount: INTEGER) ;


(*
   ShiftLeft - performs the shift left for a multi word set.
               This procedure might be called by the back end of
               GNU Modula-2 depending whether amount is known at compile
               time.
*)

PROCEDURE ShiftLeft (VAR s, d: ARRAY OF BITSET;
                     SetSizeInBits: CARDINAL;
                     ShiftCount: INTEGER) ;

(*
   ShiftRight - performs the shift left for a multi word set.
                This procedure might be called by the back end of
                GNU Modula-2 depending whether amount is known at compile
                time.
*)

PROCEDURE ShiftRight (VAR s, d: ARRAY OF BITSET;
                     SetSizeInBits: CARDINAL;
                     ShiftCount: INTEGER) ;


(*
   RotateVal - is a runtime procedure whose job is to implement
               the ROTATE procedure of ISO SYSTEM. GNU Modula-2 will
               inline a ROTATE of a single WORD (or less)
               sized set and will only call this routine for larger sets.
*)

PROCEDURE RotateVal (VAR s, d: ARRAY OF BITSET;
                     SetSizeInBits: CARDINAL;
                     RotateCount: INTEGER) ;


(*
   RotateLeft - performs the rotate left for a multi word set.
                This procedure might be called by the back end of
                GNU Modula-2 depending whether amount is known at compile
                time.
*)

PROCEDURE RotateLeft (VAR s, d: ARRAY OF BITSET;
                      SetSizeInBits: CARDINAL;
                      RotateCount: INTEGER) ;


(*
   RotateRight - performs the rotate right for a multi word set.
                 This procedure might be called by the back end of
                 GNU Modula-2 depending whether amount is known at compile
                 time.
*)

PROCEDURE RotateRight (VAR s, d: ARRAY OF BITSET;
                       SetSizeInBits: CARDINAL;
                       RotateCount: INTEGER) ;

END SYSTEM.
@end example

The different dialects of Modula-2 PIM-[234] and ISO Modula-2 declare
the function @code{SIZE} in different places.  PIM-[34] and ISO
Modula-2 declare @code{SIZE} as a pervasive function (declared in the
base module).  PIM-2 defined @code{SIZE} in the @code{SYSTEM} module
(as shown above).

GNU Modula-2 allows users to specify the dialect of Modula-2
by using the @code{-fiso} and @code{-fpim2} command line switches.

@node The ISO system module, , The PIM system module, Using
@section The ISO system module

@example
DEFINITION MODULE SYSTEM;

  (* Gives access to system programming facilities that are probably
     non portable. *)

  (* The constants and types define underlying properties of storage *)

EXPORT QUALIFIED BITSPERLOC, LOCSPERWORD,
                 LOC, BYTE, WORD, BITSET, ADDRESS,
                 ADDADR, SUBADR, DIFADR, MAKEADR, ADR, ROTATE,
                 SHIFT, CAST, TSIZE,

                 (* Internal GM2 compiler functions *)
                 ShiftVal, ShiftLeft, ShiftRight,
                 RotateVal, RotateLeft, RotateRight ;

CONST
                  (* <implementation-defined constant> ; *)
  BITSPERLOC    = __ATTRIBUTE__ __BUILTIN__ ((BITS_PER_UNIT)) ;
                  (* <implementation-defined constant> ; *)
  LOCSPERWORD   = __ATTRIBUTE__ __BUILTIN__ ((UNITS_PER_WORD)) ;
                  (* <implementation-defined constant> ; *)
  LOCSPERBYTE = 8 DIV BITSPERLOC ;

(*
   all the objects below are declared internally to gm2
   ====================================================

TYPE
  LOC; (* A system basic type. Values are the uninterpreted
          contents of the smallest addressable unit of storage *)
  ADDRESS = POINTER TO LOC;
  WORD = ARRAY [0 .. LOCSPERWORD-1] OF LOC;

  (* BYTE and LOCSPERBYTE are provided if appropriate for machine *)

TYPE
  BYTE = ARRAY [0 .. LOCSPERBYTE-1] OF LOC;

PROCEDURE ADDADR (addr: ADDRESS; offset: CARDINAL): ADDRESS;
  (* Returns address given by (addr + offset), or may raise
     an exception if this address is not valid.
  *)

PROCEDURE SUBADR (addr: ADDRESS; offset: CARDINAL): ADDRESS;
  (* Returns address given by (addr - offset), or may raise an
     exception if this address is not valid.
  *)

PROCEDURE DIFADR (addr1, addr2: ADDRESS): INTEGER;
  (* Returns the difference between addresses (addr1 - addr2),
     or may raise an exception if the arguments are invalid
     or address space is non-contiguous.
  *)

PROCEDURE MAKEADR (high: <some type>; ...): ADDRESS;
  (* Returns an address constructed from a list of values whose
     types are implementation-defined, or may raise an
     exception if this address is not valid.

     In GNU Modula-2, MAKEADR can take any number of arguments
     which are mapped onto the type ADDRESS. The first parameter
     maps onto the high address bits and subsequent parameters map
     onto lower address bits. For example:

     a := MAKEADR(BYTE(0FEH), BYTE(0DCH), BYTE(0BAH), BYTE(098H),
                  BYTE(076H), BYTE(054H), BYTE(032H), BYTE(010H)) ;

     then the value of, a, on a 64 bit machine is: 0FEDCBA9876543210H

     The parameters do not have to have the same type, but constants
     _must_ be typed.
  *)

PROCEDURE ADR (VAR v: <anytype>): ADDRESS;
  (* Returns the address of variable v. *)

PROCEDURE ROTATE (val: <a packedset type>;
                  num: INTEGER): <type of first parameter>;
  (* Returns a bit sequence obtained from val by rotating up or down
     (left or right) by the absolute value of num.  The direction is
     down if the sign of num is negative, otherwise the direction is up.
  *)

PROCEDURE SHIFT (val: <a packedset type>;
                 num: INTEGER): <type of first parameter>;
  (* Returns a bit sequence obtained from val by shifting up or down
     (left or right) by the absolute value of num, introducing
     zeros as necessary.  The direction is down if the sign of
     num is negative, otherwise the direction is up.
  *)

PROCEDURE CAST (<targettype>; val: <anytype>): <targettype>;
  (* CAST is a type transfer function.  Given the expression
     denoted by val, it returns a value of the type <targettype>.
     An invalid value for the target value or a
     physical address alignment problem may raise an exception.
  *)

PROCEDURE TSIZE (<type>; ... ): CARDINAL;
  (* Returns the number of LOCS used to store a value of the
     specified <type>.   The extra parameters, if present,
     are used to distinguish variants in a variant record.
  *)
*)


(* The following procedures are invoked by GNU Modula-2 to
   shift non word set types. They are not part of ISO Modula-2
   but are used by GNU Modula-2 to implement the SHIFT procedure
   defined above. *)

(*
   ShiftVal - is a runtime procedure whose job is to implement
              the SHIFT procedure of ISO SYSTEM. GNU Modula-2 will
              in-line a SHIFT of a single WORD sized set and will only
              call this routine for larger sets.
*)

PROCEDURE ShiftVal (VAR s, d: ARRAY OF BITSET;
                    SetSizeInBits: CARDINAL;
                    ShiftCount: INTEGER) ;


(*
   ShiftLeft - performs the shift left for a multi word set.
               This procedure might be called by the back end of
               GNU Modula-2 depending whether amount is known at compile
               time.
*)

PROCEDURE ShiftLeft (VAR s, d: ARRAY OF BITSET;
                     SetSizeInBits: CARDINAL;
                     ShiftCount: INTEGER) ;

(*
   ShiftRight - performs the shift left for a multi word set.
                This procedure might be called by the back end of
                GNU Modula-2 depending whether amount is known at compile
                time.
*)

PROCEDURE ShiftRight (VAR s, d: ARRAY OF BITSET;
                     SetSizeInBits: CARDINAL;
                     ShiftCount: INTEGER) ;


(*
   RotateVal - is a runtime procedure whose job is to implement
               the ROTATE procedure of ISO SYSTEM. GNU Modula-2 will
               in-line a ROTATE of a single WORD (or less)
               sized set and will only call this routine for larger sets.
*)

PROCEDURE RotateVal (VAR s, d: ARRAY OF BITSET;
                     SetSizeInBits: CARDINAL;
                     RotateCount: INTEGER) ;


(*
   RotateLeft - performs the rotate left for a multi word set.
                This procedure might be called by the back end of
                GNU Modula-2 depending whether amount is known at compile
                time.
*)

PROCEDURE RotateLeft (VAR s, d: ARRAY OF BITSET;
                      SetSizeInBits: CARDINAL;
                      RotateCount: INTEGER) ;


(*
   RotateRight - performs the rotate right for a multi word set.
                 This procedure might be called by the back end of
                 GNU Modula-2 depending whether amount is known at compile
                 time.
*)

PROCEDURE RotateRight (VAR s, d: ARRAY OF BITSET;
                       SetSizeInBits: CARDINAL;
                       RotateCount: INTEGER) ;


END SYSTEM.
@end example

@node Obtaining, Licence, Using, Top
@chapter Obtaining GNU Modula-2.

@section Warning

This code is currently in development and it is not yet complete.
Nevertheless the compiler is sufficiently stable to support itself on
Debian GNU/Linux x86 systems. The PIM libraries are complete but the
ISO libraries and ISO language features are still in development.
Patches and development volunteers highly welcome! 
@xref{Contributing, Contributing to GNU Modula-2}.

@section Getting GNU Modula-2

Currently you have several options, you could either download a source
tar ball from @uref{ftp://floppsie.comp.glam.ac.uk/pub/c} and
search for files which look like @file{gm2+gcc-@var{version}.tar.gz}.
Prebuilt binary packages are also available from
@uref{http://www.nongnu.org/gm2/}
in debian @code{.deb} package format.

Alternatively the development sources can be downloaded via CVS.
Please be aware that as gm2 is in development it might fail to compile
with a more recent version of gcc than @samp{gcc-@value{version-GCC}}.

@section Development sources via CVS

To get the latest sources to GNU Modula-2 type the following:

@example
cvs -z3 -d:pserver:anoncvs@@cvs.sv.gnu.org:/sources/gm2 co gm2
@end example

This will checkout a copy of GNU Modula-2 into one subdirectory,
@file{gm2}.  This version of GNU Modula-2 needs to be placed inside
the GCC source tree in the position gcc-@value{version-GCC}/gcc before
GNU Modula-2 can be built. Please check the GNU Modula-2 homepage
@uref{http://www.nongnu.org/gm2} for details about which GCC releases
are supported by GNU Modula-2.

Once you have downloaded the correct GCC release from
@uref{http://gcc.gnu.org} or a mirror site you should unpack the GCC
archive.  Assuming that both the @file{gcc-@value{version-GCC}} and
@file{gm2} dicectories are at the same level, you can graft @file{gm2}
onto @file{gcc-@value{version-GCC}} by:

@example   
mv gm2 gcc-@value{version-GCC}/gcc
@end example

If the directory
@samp{gcc-@value{version-GCC}/gcc/gm2/patches/gcc/@value{version-GCC}}
exists then the patch files inside that directory can be applied to the
@samp{gcc-@value{version-GCC}} tree. This is done via:

@example
cd gcc-@value{version-GCC}
if [ -d gcc/gm2/patches/gcc/@value{version-GCC}/gm2 ] ; then
   for i in gcc/gm2/patches/gcc/@value{version-GCC}/gm2/* ; do
      if [ -f $i ] ; then
         patch -p1 < $i
      fi
   done
fi
@end example

Note that if you download a tarball from
@url{http://floppsie.comp.glam.ac.uk} as described in @xref{Getting
GNU Modula-2, , ,} then any patching will have already
been applied.

@section Building GNU Modula-2

This section assumes you are building on a GNU/Linux system and that
your shell is @file{/bin/bash}.  To build GNU Modula-2 type:

@example
mkdir -p $HOME/opt
mkdir -p host-build
cd host-build
../gcc-@value{version-GCC}/configure --enable-languages=c,gm2 \
  --enable-checking=all --disable-multilib --prefix=$HOME/opt
make
cd ..
@end example

Installing GNU Modula-2 is achieved by:

@example
cd host-build
make install
@end example

Now you should be able to perform:

@example
export PATH=$HOME/opt/bin:$PATH
cd gcc-@value{version-GCC}/gcc/gm2/examples/hello
make
@end example

which will create an @file{a.out} for the infamous hello world
example.  Alternatively if you would rather install precompiled
binaries, they are available in Debian package format.  To install
these binary and source packages append these repository descriptions
to your @file{/etc/apt/sources.list} file.

@example
#
#  GNU Modula-2 repo
#

deb http://floppsie.comp.glam.ac.uk/debian/ etch main non-free contrib
deb-src http://floppsie.comp.glam.ac.uk/debian/ etch main non-free contrib
@end example

Now as root type:

@example
apt-get update
apt-get install gm2-doc gm2
@end example

The repository has binaries for the amd64, ps3 (ppc64) and i386
processors.  As a normal user you can obtain the source code via:

@example
apt-get source gm2
@end example

@section Stress testing GM2

Currently there are two automated methods to test GNU Modula-2.
The first method is @samp{make gm2.paranoid} in which @code{gm2}
builds itself and finally the test runs both parent and child
generations of the compiler and compares the output. Be warned
that this test can take some time to execute.
This test is invoked by:

@example
cd host-build/gcc ; make gm2.paranoid
@end example

The second method used to test GNU Modula-2 is to run the regression
test suite.  The GNU Modula-2 regression test suite is available for
download.  To install and run the GNU Modula-2 regression suite you
need to have installed the @file{dejagnu} and @file{expect}
packages. Note that you need to ensure that you have at least the
following releases of dejagnu components:

@example
$ runtest --version

Expect version is	5.42.1
Tcl version is		8.4
Framework version is	1.4.4
@end example

otherwise some of the tests may not run.

You also need to have downloaded the gcc testsuite and
grafted it onto the GCC source tree. Finally you need to graft the GNU
Modula-2 testsuite onto the gcc testsuite. To ease this process there
are pre grafted versions available from
@uref{ftp://floppsie.comp.glam.ac.uk/pub/c}.

Assuming that the root of the GCC source tree is in the current
working directory you can use the following commands to install
the test suite:

@example
cvs -z3 -d:pserver:anoncvs@@cvs.sv.gnu.org:/sources/gm2 co testsuite
tar cf - testsuite | ( cd gcc-@var{version}/gcc ; tar xf - )
@end example

Do not simply move the directory @file{testsuite} into
@file{gcc-@var{version}/gcc} as the GNU Modula-2 regression
tests have to be overlaid on top of the gcc testsuite.

Thereafter you can run the GNU Modula-2 testsuite by:

@example
cd host-build/gcc
make check-gm2
@end example

Depending on the speed of your computer these tests may take a while
to complete.

@section Building GNU Modula-2 under FreeBSD

When building GNU Modula-2 under FreeBSD, there are essentially three
issues that need to be addressed.

The first, is the system shell, @file{/bin/sh}. GNU Modula-2's build
script uses some @file{bash} constructs that are not understood by
@file{sh}.  Therefore @file{bash} must be installed and this can be
obtained from the ports package collection (ports:shells/bash).

The second, is the compiler used to bootstrap GNU Modula-2. On
FreeBSD4.x the system compiler is from the 2.95.x generation, and
should work without problems.  On 5-RELEASE and 6-CURRENT, the system
compiler is from the 3.4.x generation or greater, and it is known to
create a faulty GNU Modula-2 compiler. Therefore you will need to
install an earlier gcc on your machine. Known to work are gcc 3.2.3
(ports:lang/gcc32), gcc 3.3.4, 3.3.5 and 3.3.6 (ports:lang/gcc33).

Finally, @file{gmake} is required.

It is recommended that the same options are used to configure GNU
Modula-2 as those suggested in the ports collection.  A number of
options are not relevant for building GNU Modula-2 and these can be
safely omitted. The only two which apply directly to GNU Modula-2's
build process are @code{--with-system-zlib} and @code{--disable-nls}.

The example below assumes that @code{gcc-3.2.3} is installed (from the
ports collection) and the compiler is called @file{gcc32}. The example
assumes that the bash shell has been installed (as described above).

@example
  mkdir host-build
  cd host-build
  env CONFIG_SHELL=/usr/local/bin/bash CC=gcc32 ../gcc-@var{version}/configure
      --with-system-zlib --disable-nls --enable-languages=c,gm2
  gmake
@end example

If you choose to install the generated compiler, you are urged to make
use of the name rewriting options of configure
(@code{--program-prefix} and @code{--program-suffix} work fine), and
to avoid possible conflicts with a port that installs it's own gcc,
you may also want to add @code{--host}. Here is the author of this
section's full configure line:

@example
  env CONFIG_SHELL=/usr/local/bin/bash CC=gcc32 ../gcc-@var{version}/configure
      --with-system-zlib --disable-nls --enable-languages=c,gm2
      --program-prefix=m2 --host=i386-gm2bld-freebsd5.3
@end example

@node Licence, GNU Project, Obtaining, Top
@section Licence of GNU Modula-2

@include gpl.texi

@node GNU Project, Contributing, Licence, Top

@include gnu.texi

@node Contributing, Internals, GNU Project, Top
@section Contributing to GNU Modula-2

Please do. But also please read the GNU Emacs info under

@example
* Standards: (standards).       GNU coding standards.
* Intellectual Property::       Keeping Free Software Free
* Reading Non-Free Code::       Referring to Proprietary Programs
* Contributions::               Accepting Contributions
@end example

You might consider joining the GM2 Mailing list available via
a web brouser at

@uref{http://lists.nongnu.org/mailman/listinfo/gm2}
available via email: @uref{mail:gm2-subscribe@@nongnu.org} before you
start coding.

Many thanks and enjoy your coding!

@node Internals, EBNF, Contributing, Top
@chapter GNU Modula-2 Internals

This document is a small step in the long journey of documenting the GNU
Modula-2 compiler and how it integrates with GCC.
The document is still in it's infancy.

@menu
* History::                 How GNU Modula-2 came about.
* Overview::                Overview of the structure of GNU Modula-2.
* Integrating::             How the front end integrates with gcc.
* Passes::                  What gets processed during each pass.
* Run time::                Integration of run time modules with the compiler.
* Scope rules::             Clarification of some the scope rules.
* Done list::               Progression of the GNU Modula-2 project.
* To do list::              Outstanding issues.
@end menu

@node History, Overview, , Internals
@section History

The Modula-2 compiler sources have come from the m2f compiler which
runs under GNU/Linux. The original m2f compiler was written in Modula-2
and was bootstrapped via a modified version of p2c 1.20. The m2f
compiler was a recursive descent which generated quadruples as
intermediate code. It also used C style calling convention wherever
possible and utilized a C structure for dynamic arrays.

@node Overview, Integrating, History, Internals
@section Overview

GNU Modula-2 uses flex and a machine generated recursive descent
parser. Most of the source code is written in Modula-2 and
bootstrapping is achieved via a modified version of p2c-1.20.
The modified p2c-1.20 is contained in the GNU Modula-2 source
tree as are a number of other tools necessary for bootstrapping.

The changes to p2c include:

@itemize @bullet
@item
allowing @code{DEFINITION MODULE FOR "C"}
@item
fixes to abstract data types.
@item
making p2c understand the 2nd Edition dialect of Modula-2.
@item
introducing the @code{UNQUALIFIED} keyword.
@item
allowing varargs (@code{...}) inside @code{DEFINITION MODULE FOR "C"} modules.
@item
fixing the parser to understand commented @code{FORWARD} prototypes,
which are ignored by GNU Modula-2.
@item
fixes to the @code{CASE} syntax for 2nd Edition Modula-2.
@item
fixes to a @code{FOR} loop counting down to zero using a @code{CARDINAL}.
@item
introducing an initialization section for each implementation module.
@item
various porting improvements and general tidying up so that
it compiles with the gcc option @code{-Wall}.
@end itemize

GNU Modula-2 comes with PIM and ISO style libraries. The compiler
is built using PIM libraries and the source of the compiler
complies with the PIM dialect together with a few @code{C}
library calling extensions.

The compiler is a four pass compiler. The first pass tokenizes
the source code, creates scope and enumeration type symbols.
All tokens are placed into a dynamic buffer and subsequent passes reread
tokens and build types, quadruples and resolve hidden types.
@xref{Passes, , ,}.

GNU Modula-2 uses a technique of double book keeping @footnote{See the
excellent tutorial by Joachim Nadler translated by Tim Josling}.
@xref{Back end Access to Symbol Table, , , gcc}.
The front end builds a complete symbol table and a list of quadruples.
Each symbol is translated into a @code{gcc} equivalent after which
each quadruple is translated into a @code{gcc} @code{tree}.

@node Integrating, Passes, Overview, Internals
@section How the front end integrates with gcc

The M2Base and M2System
modules contain base types and system types respectively they
map onto GCC back-end data types.

@node Passes, Run time, Integrating, Internals
@section Passes

This section describes the general actions of each pass.  The key to
building up the symbol table correctly is to ensure that the symbols
are only created in the scope where they were declared.  This may seem
obvious (and easy) but it is complicated by two issues: firstly GNU
Modula-2 does not generate @code{.sym} files and so all imported
definition modules are parsed after the module is parsed; secondly the
import/export rules might mean that you can see and use a symbol
before it is declared in a completely different scope.

Here is a brief description of the lists of symbols maintained within
@code{DefImp} and @code{Module} symbols. It is these lists and actions
at each pass which manipulate these lists which solve the scoping and
visability of all symbols.

The @code{DefImp} symbol maintains the: @code{ExportQualified},
@code{ExportUnQualified}, @code{ExportRequest}, @code{IncludeList},
@code{ImportTree}, @code{ExportUndeclared},
@code{NeedToBeImplemented}, @code{LocalSymbols},
@code{EnumerationScopeList}, @code{Unresolved}, @code{ListOfVars},
@code{ListOfProcs} and @code{ListOfModules} lists.

The @code{Module} symbol maintains the: @code{LocalSymbols},
@code{ExportTree}, @code{IncludeList}, @code{ImportTree},
@code{ExportUndeclared}, @code{EnumerationScopeList},
@code{Unresolved}, @code{ListOfVars}, @code{ListOfProcs} and
@code{ListOfModules} lists.

Initially we discuss the lists which are common to both @code{DefImp}
and @code{Module} symbols, thereafter the lists peculiar to @code{DefImp}
and @code{Module} symbols are discussed.

The @code{ListOfVars}, @code{ListOfProcs} and @code{ListOfModules}
lists (common to both symbols) and simply contain a list of
variables, procedures and inner modules which are declared with this
definition/implementation or program module.

The @code{LocalSymbols} list (common to both symbols) contains a
complete list of symbols visible in this modules scope. The symbols in
this list may have been imported or exported from an inner module.

The @code{EnumerationScope} list (common to both symbols) defines all
visible enumeration symbols.  When this module is parsed the contents
of these enumeration types are marked as visible. Internally to GNU
Modula-2 these form a pseudo scope (rather like a @code{WITH}
statement which temporarily makes the fields of the record visible).

The @code{ExportUndeclared} list (common to both symbols) contains a
list of all symbols marked as exported but are as yet undeclared.

The @code{IncludeList} is (common to both symbols) contains a list of
all modules imported by the @code{IMPORT modulename ;} construct.

The @code{ImportTree} (common to both symbols) contains a tree of all
imported identifiers.

The @code{ExportQualified} and @code{ExportUnQualified} trees (only
present in the @code{DefImp} symbol) contain identifiers which are
marked as @code{EXPORT QUALIFIED} and @code{EXPORT UNQUALIFIED}
respectively.

The @code{NeedToBeImplemented} list (only present in the @code{DefImp}
symbol) and contains a list of all unresolved symbols which are exported.

@subsection Pass 1

During pass 1 each @code{DefImp} and @code{Module} symbol is
created. These are also placed into a list of outstanding sources to
be parsed.  The import and export lists are recorded and each object
imported is created in the module from whence it is exported and added
into the imported list of the current module. Any exported objects are
placed into the export list and marked as qualified or unqualified.

Inner module symbols are also created and their import and export
lists are also processed. An import list will result in a symbol being
fetched (or created if it does not exist) from the outer scope and
placed into the scope of the inner module. An export list results in
each symbol being fetched or created in the current inner scope and
added to the outer scope. If the symbol has not yet been declared then
it is added to the current modules @code{ExportUndeclared} list.

Procedure symbols are created (the parameters are parsed but no more
symbols are created). Enumerated types are created, hidden types in
the definition modules are marked as such. All the rest of the Modula-2
syntax is parsed but no symbols are created.

@subsection Pass 2

This section discuss varient records and their representation within
the front end @file{gm2/gm2-compiler/SymbolTable.mod}. Records and
varient records are declared in pass 2.

Ordinary records are represented by the following symbol table entries:

@example
TYPE
   this = RECORD
             foo: CARDINAL ;
             bar: CHAR ;
          END ;


    SymRecord [1]
   +-------------+
   | Name = this |        SymRecordField [2]
   | ListOfSons  |       +-------------------+
   |    +--------|       | Name = foo        |
   |    | [2] [3]|       | Parent = [1]      |
   +-------------+       | Type = [Cardinal] |
   | LocalSymbols|       +-------------------+
   | +-----------+
   | | foo bar   |
   | +-----------+
   +-------------+


    SymRecordField [3]
   +-------------------+
   | Name = bar        |
   | Parent = [1]      |
   | Type = [Cardinal] |
   +-------------------+
@end example

Whereas varient records are represented by the following symbol table
entries:

@example
TYPE
   this = RECORD
             CASE tag: CHAR OF
             'a': foo: CARDINAL ;
                  bar: CHAR |
             'b': an:  REAL |
             ELSE
             END
          END ;


    SymRecord [1]
   +-------------+
   | Name = this |        SymRecordField [2]
   | ListOfSons  |       +-------------------+
   |    +--------|       | Name = tag        |
   |    | [2] [3]|       | Parent = [1]      |
   |    +--------+       | Type = [CHAR]     |
   | LocalSymbols|       +-------------------+
   | +-----------+
   | | tag foo   |
   | | bar an    |
   | +-----------+
   +-------------+

    SymVarient [3]          SymFieldVarient [4]
   +-------------------+   +-------------------+
   | Parent = [1]      |   | Parent = [1]      |
   | ListOfSons        |   | ListOfSons        |  
   |    +--------------|   |    +--------------|
   |    | [4] [5]      |   |    | [6] [7]      |
   +-------------------+   +-------------------+

    SymFieldVarient [5]
   +-------------------+
   | Parent = [1]      |
   | ListOfSons        |  
   |    +--------------|
   |    | [8]          |
   +-------------------+

    SymRecordField [6]      SymRecordField [7]
   +-------------------+   +-------------------+
   | Name = foo        |   | Name = bar        |
   | Parent = [1]      |   | Parent = [1]      |
   | Type = [CARDINAL] |   | Type = [CHAR]     |
   +-------------------+   +-------------------+

    SymRecordField [8]
   +-------------------+
   | Name = an         |
   | Parent = [1]      |
   | Type = [REAL]     |
   +-------------------+
@end example

Varient records which have nested @code{CASE} statements are
represented by the following symbol table entries:

@example
TYPE
   this = RECORD
             CASE tag: CHAR OF
             'a': foo: CARDINAL ;
                  CASE bar: BOOLEAN OF
                  TRUE : bt: INTEGER |
                  FALSE: bf: CARDINAL
                  END |
             'b': an:  REAL |
             ELSE
             END
          END ;


    SymRecord [1]
   +-------------+
   | Name = this |        SymRecordField [2]
   | ListOfSons  |       +-------------------+
   |    +--------|       | Name = tag        |
   |    | [2] [3]|       | Parent = [1]      |
   |    +--------+       | Type = [CHAR]     |
   | LocalSymbols|       +-------------------+
   | +-----------+
   | | tag foo   |
   | | bar bt bf |
   | | an        |
   | +-----------+
   +-------------+

      ('1st CASE')            ('a' selector)
    SymVarient [3]          SymFieldVarient [4]
   +-------------------+   +-------------------+
   | Parent = [1]      |   | Parent = [1]      |
   | ListOfSons        |   | ListOfSons        |  
   |    +--------------|   |    +--------------|
   |    | [4] [5]      |   |    | [6] [7] [8]  |
   +-------------------+   +-------------------+

     ('b' selector)
    SymFieldVarient [5]
   +-------------------+
   | Parent = [1]      |
   | ListOfSons        |  
   |    +--------------|
   |    | [9]          |
   +-------------------+

    SymRecordField [6]      SymRecordField [7]
   +-------------------+   +-------------------+
   | Name = foo        |   | Name = bar        |
   | Parent = [1]      |   | Parent = [1]      |
   | Type = [CARDINAL] |   | Type = [BOOLEAN]  |
   +-------------------+   +-------------------+

      ('2nd CASE')
    SymVarient [8]
   +-------------------+
   | Parent = [1]      |
   | ListOfSons        |
   |    +--------------|
   |    | [12] [13]    |
   +-------------------+

    SymRecordField [9]
   +-------------------+
   | Name = an         |
   | Parent = [1]      |
   | Type = [REAL]     |
   +-------------------+

    SymRecordField [10]     SymRecordField [11]
   +-------------------+   +-------------------+
   | Name = bt         |   | Name = bf         |
   | Parent = [1]      |   | Parent = [1]      |
   | Type = [REAL]     |   | Type = [REAL]     |
   +-------------------+   +-------------------+

    (TRUE selector)            (FALSE selector)
    SymFieldVarient [12]    SymFieldVarient [13]
   +-------------------+   +-------------------+
   | Parent = [1]      |   | Parent = [1]      |
   | ListOfSons        |   | ListOfSons        |
   |    +--------------|   |    +--------------|
   |    | [10]         |   |    | [11]         |
   +-------------------+   +-------------------+
@end example

@subsection Pass 3

To do

@subsection Pass H

To do

@subsection Declaration ordering

This section gives a few stress testing examples and walks though
the mechanics of the passes and how the lists of symbols are created.

The first example contains a nested module in which an enumeration
type is created and exported. A procedure declared before the nested
module uses the enumeration type.

@example
MODULE colour ;

   PROCEDURE make (VAR c: colours) ;
   BEGIN
      c := yellow
   END make ;

   MODULE inner ;
   EXPORT colours ;

   TYPE
      colours = (red, blue, yellow, white) ;
   END inner ;

VAR
   g: colours
BEGIN
   make(g)
END colour.
@end example

@node Run time, Scope rules, Passes, Internals
@section Run time

This section describes how the GNU Modula-2 compiler interfaces with
the run time system.  The modules which must be common to all library
collections are @code{M2RTS} and @code{SYSTEM}. In the PIM library
collection an implementation of @code{M2RTS} and @code{SYSTEM} exist;
likewise in the ISO library and ULM library collection these modules
also exist.

The @code{M2RTS} module contains many of the base runtime features
required by the GNU Modula-2 compiler. For example @code{M2RTS}
contains the exception handling routines which are called if a pointer
whose value is @code{NIL} is dereferenced or an array index goes out
of bounds. If the @samp{-fbounds} options is specified then the GNU
Modula-2 compiler will call the procedure @code{ArraySubscriptError}
or @code{SubrangeAssignmentError} when an illegal reference or illegal
assignment is about to be performed. @code{M2RTS} also contains
the exception handlers @code{FunctionReturnError},
@code{NilPointerError} and @code{CaseElseError}.

The @code{M2RTS} module also contains the @code{HALT} and @code{LENGTH}
procedure. The ISO @code{SYSTEM} module contains a number of
@code{SHIFT} and @code{ROTATE} procedures which GNU Modula-2 will call
when wishing to shift and rotate multi-word set types.

@node Scope rules, Done list, Run time, Internals
@section Scope rules

This section describes my understanding of the Modula-2 scope rules
with respect to enumerated types.  If they are incorrect please
correct me by email @email{gaius@@gnu.org}. They also serve to
document the behaviour of GNU Modula-2 in these cirumstances.

In GNU Modula-2 the syntax for a type declaration is defined as:

@example
TypeDeclaration := Ident "=" Type =:

Type :=  SimpleType | ArrayType
          | RecordType          
          | SetType             
          | PointerType         
          | ProcedureType
      =:								   
									   
SimpleType := Qualident | Enumeration | SubrangeType =:

@end example

If the @code{TypeDeclaration} rule is satisfied by
@code{SimpleType} and @code{Qualident} ie:

@example
TYPE
   foo = bar ;
@end example

then @code{foo} is said to be equivalent to @code{bar}. Thus
variables, parameters and record fields declared with either type will
be compatible with each other.

If, however, the @code{TypeDeclaration} rule is satisfied by any
alternative clause @code{ArrayType}, @code{RecordType},
@code{SetType}, @code{PointerType}, @code{ProcedureType},
@code{Enumeration} or @code{SubrangeType} then in these cases a new
type is created which is distinct from all other types.  It will be
incompatible with all other user defined types.

It also has furthur consequences in that if bar was defined as an
enumerated type and foo is imported by another module then the
enumerated values are also visible in this module.

Consider the following modules:

@example
DEFINITION MODULE impc ;

TYPE
   C = (red, blue, green) ;

END impc.
@end example

@example
DEFINITION MODULE impb ;

IMPORT impc ;

TYPE
   C = impc.C ;

END impb.
@end example

@example
MODULE impa ;

FROM impb IMPORT C ;

VAR
   a: C ;
BEGIN
   a := red
END impa.
@end example

Here we see that the type @code{C} defined in module @code{impb} is
equivalent to the type @code{C} in module @code{impc}. Module
@code{impa} imports the type @code{C} from module @code{impb}
and at that point the enumeration values @code{red, blue, green}
(declared in module @code{impc}) are also visible.

The ISO Standand (p.41) in section 6.1.8 Import Lists states:

``Following the module heading, a module may have a sequence of import
lists. An import list includes a list of the identifiers that are to
be explicitly imported into the module. Explicit import of an
enumeration type identifier implicitly imports the enumeration
constant identifiers of the enumeration type.

Imported identifiers are introduced into the module, thus extending
their scope, but they have a defining occurrence that appears elsewhere.

Every kind of module may include a sequence of import lists, whether it
is a program module, a definition module, an implementation module or
a local module. In the case of any other kind of module, the imported
identifiers may be used in the block of the module.''

These statements confirm that the previous example is legal. But it
prompts the question, what about implicit imports othersise known
as qualified references.

In section 6.10 Implicit Import and Export of the ISO Modula-2 standard
it says:

``The set of identifiers that is imported or exported if an identifier
is explicitly imported or exported is called the (import and export)
closure of that identifier. Normally, the closure includes only the
explicitly imported or exported identifier. However, in the case
of the explicit import or export of an identifier of an enumeration
type, the closure also includes the identifiers of the values of that
type.

Implicit export applies to the identifiers that are exported (qualified)
from separate modules, by virtue of their being the subject of a
definition module, as well as to export from a local module that
uses an export list.''

Clearly this means that the following is legal:

@example
MODULE impd ;

IMPORT impc ;

VAR
   a: impc.C ;
BEGIN
   a := impc.red
END impd.
@end example

It also means that the following code is legal:

@example
MODULE impe ;

IMPORT impb ;

VAR
   a: impb.C ;
BEGIN
   a := impb.red
END impe.
@end example

And also this code is legal:

@example
MODULE impf ;

FROM impb IMPORT C ;

VAR
   a: C ;
BEGIN
   a := red
END impf.
@end example

And also that this code is legal:

@example
DEFINITION MODULE impg ;

IMPORT impc;

TYPE
   C = impc.C ;

END impg.
@end example

@example
IMPLEMENTATION MODULE impg ;

VAR
   t: C ;
BEGIN
   t := red
END impg.
@end example

Furthermore the following code is also legal as the new type, @code{C}
is declared and exported. Once exported all its enumerated fields
are also exported.

@example
DEFINITION MODULE imph;

IMPORT impc;
TYPE
   C = impc.C;

END imph.
@end example

Here we see that the current scope is populated with the enumeration
fields @code{red, blue, green} and also it is possible to reference
these values via a qualified identifier.

@example
IMPLEMENTATION MODULE imph;

IMPORT impc;

VAR
   a: C ;
   b: impc.C ;
BEGIN
   a := impc.red ;
   b := red ;
   a := b ;
   b := a
END imph.
@end example


@node Done list, To do list, Scope rules, Internals
@section Done list

What has been done:

@itemize @bullet

@item
Coroutines have been implemented. The @code{SYSTEM} module in
PIM-[234] now includes @code{TRANSFER}, @code{IOTRANSFER} and
@code{NEWPROCESS}. This module is available in the directory
@file{gm2/gm2-libs-coroutines}.  Users of this module also have to
link with GNU Pthreads @code{-lpth}.

@item
GM2 now works on the @code{opteron} 64 bit architecture. @code{make
gm2.paranoid} and @code{make check-gm2} pass.

@item
GM2 can now be built as a cross compiler to the MinGW platform under
GNU/Linux i386.

@item
GM2 now works on the @code{sparc} architecture. @code{make
gm2.paranoid} and @code{make check-gm2} pass.

@item
converted the regression test suite into the GNU dejagnu format.
In turn this can be grafted onto the GCC testsuite and can be
invoked as @code{make check-gm2}. GM2 should now pass all
regression tests.

@item
provided access to a few compiler built-in constants
and twenty seven built-in C functions.

@item
definition modules no longer have to @code{EXPORT QUALIFIED}
objects (as per PIM-3, PIM-4 and ISO).

@item
implemented ISO Modula-2 sets. Large sets are now allowed,
no limits imposed. The comparison operators
@code{# = <= >= < >} all behave as per ISO standard.
The obvious use for large sets is
@code{SET OF CHAR}. These work well with gdb once it has been
patched to understand Modula-2 sets.

@item
added @code{DEFINITION MODULE FOR "C"} method of linking
to C. Also added varargs handling in C definition modules.

@item
cpp can be run on definition and implementation modules.

@item
@samp{-fmakell} generates a temporary @code{Makefile} and
will build all dependant modules.

@item
compiler will bootstrap itself and three generations of the
compiler all produce the same code.

@item
the back end will generate code and assembly declarations for
modules containing global variables of all types. Procedure
prologue/epilogue is created.

@item
all loop constructs, if then else, case statements and expressions.

@item
nested module initialization.

@item
pointers, arrays, procedure calls, nested procedures.

@item
front end @samp{gm2} can now compile and link modules.

@item
the ability to insert gnu asm statements within GNU Modula-2.

@item
inbuilt functions, @code{SIZE}, @code{ADR}, @code{TSIZE}, @code{HIGH} etc

@item
block becomes and complex procedure parameters (unbounded arrays, strings).

@item
the front end now utilizes GCC tree constants and types and is no
longer tied to a 32 bit architecture, but reflects the 'configure'
target machine description.

@item
fixed all C compiler warnings when gcc compiles the p2c generated C
with -Wall.

@item
built a new parser which implements error recovery.

@item
added mechanism to invoke cpp to support conditional compilation if required.

@item
all @samp{Makefile}s are generated via @samp{./configure}

@end itemize

@node To do list, , Done list, Internals
@section To do list

What needs to be done:

@itemize @bullet

@item
ISO library implementation needs to be completed
(use FIO.mod as the underlying substructure).

@item
Easy access to other libraries using @code{-flibs=} so that libraries
can be added into the @file{/usr/.../gcc-lib/gm2/...} structure. ISO
language complience.

@item
implement many of the ISO built-in functions and procedures.

@item
investigate the use of collect2 during link/module initialization.

@item
improve documentation, specifically this document which should
also include a synopsis of 2nd Edition Modula-2.

@item
shared library access and generation

@item
modifying @file{SymbolTable.mod} and @file{M2Quads.mod} to
make all the data structures dynamic.

@item
testing and fixing bugs

@end itemize

@node EBNF, Libraries, Internals, Top
@chapter EBNF of GNU Modula-2

This chapter contains the EBNF of GNU Modula-2. This grammer
currently supports PIM and a number of ISO features. It is intended
to be altered to become fully complient with ISO in the future.
The rules here are automatically extracted from the grammer files in
GNU Modula-2 and serve to document the syntax of the extensions described
earlier and how they fit in with the base language.

Note that the first six productions are built into the lexical analysis
phase.

@include gm2-ebnf.texi

@node Libraries, Function Index, EBNF, Top
@chapter PIM and ISO library definitions

This chapter contains M2F, ULM, PIM and ISO libraries. The ISO
libraries are currently work in progress, many are incomplete and even
more have no implementation module. The M2F libraries are very mature
as the compiler uses them extensively. Permission has been kindly
granted by the authors of the ULM libraries to include them with GNU
Modula-2. These libraries (under the GNU GPL) were written at the
University of Ulm and were originally shipped with the ULM sparc
Modula-2 compiler.

@include gm2-libs.texi

@node Function Index, , Libraries, Top

@c @printindex cp
@printindex fn

@summarycontents
@contents
@bye
